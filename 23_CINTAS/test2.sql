CREATE OR REPLACE PROCEDURE EXT.HSBC_SP_OUTBOUNDS()
LANGUAGE SQLSCRIPT
AS
BEGIN

    -- Declare variables
    DECLARE LV_SQL NVARCHAR(5000);
    DECLARE LV_COLUMNS NVARCHAR(1000) := '';
    DECLARE LV_FROM NVARCHAR(1000) := '';
    DECLARE LV_WHERE NVARCHAR(1000) := ' WHERE 1=1 ';
    DECLARE LV_JOIN NVARCHAR(1000) := '';
    DECLARE V_CommasCount INTEGER;
    DECLARE DELIMITER NVARCHAR(1) := ',';
    DECLARE START_POS INT := 1;
	DECLARE END_POS INT := 0;
	DECLARE ITEM NVARCHAR(128);

    -- Variables for cursor
    DECLARE COLUMN_NAME NVARCHAR(255);
    DECLARE DISPLAY_ORDER INTEGER;

    -- Variables for source info
    DECLARE TABLE_NAMES NVARCHAR(1000);
    DECLARE JOIN_CONDITION NVARCHAR(1000);
    DECLARE FILTER_CONDITION NVARCHAR(1000);
    DECLARE TABLE_ARRAY TABLE ( TABLE_NAME NVARCHAR(128) );
    
    DECLARE CURSOR CUR_ROW_COLUMNS FOR SELECT CL.CLASSIFIERID FROM CS_GENERICCLASSIFIER GC, CS_CLASSIFIER CL WHERE GC.GENERICATTRIBUTE1='BASICCOMM' AND GC.REMOVEDATE='2200-01-01' 
    AND CL.REMOVEDATE='2200-01-01' AND GC.CLASSIFIERSEQ=CL.CLASSIFIERSEQ ORDER BY GENERICATTRIBUTE3 ;
    
    DECLARE CURSOR CUR_ROW_SOURCEINFO FOR SELECT GC.GENERICATTRIBUTE1 AS SOURCE_TABLE_NAMES, GC.GENERICATTRIBUTE2 AS CONDITIONS, GC.GENERICATTRIBUTE3 AS FILTERS FROM CS_GENERICCLASSIFIER GC, CS_CLASSIFIER CL WHERE GC.GENERICATTRIBUTE4='BASICCOMM-CONDITIONS' 
    AND CL.CLASSIFIERID='BASICCOMM' AND GC.REMOVEDATE='2200-01-01' 
    AND CL.REMOVEDATE='2200-01-01' AND GC.CLASSIFIERSEQ=CL.CLASSIFIERSEQ;
    
    -- Building the SELECT clause
    
    FOR CUR_SQL as CUR_ROW_COLUMNS DO
    FETCH CUR_SQL INTO COLUMN_NAME;
    WHILE CUR_SQL::ROWCOUNT > 0 DO
        LV_COLUMNS := LV_COLUMNS || COLUMN_NAME || ', ';
        FETCH CUR_SQL INTO COLUMN_NAME;
    END WHILE;
    CLOSE CUR_SQL;

    -- Remove trailing comma
    LV_COLUMNS := SUBSTR_BEFORE(LV_COLUMNS, ', ');

    -- Building FROM, JOIN, and WHERE clauses
    FOR CUR_SQL as CUR_ROW_SOURCEINFO DO
    WHILE CUR_SQL::ROWCOUNT > 0 DO
    SELECT LENGTH(:CUR_SQL.GENERICATTRIBUTE1) - LENGTH(REPLACE(:CUR_SQL.GENERICATTRIBUTE1, ',', '')) INTO V_CommasCount FROM DUMMY;
        -- Splitting TABLE_NAMES by comma
        -- Loop to split the string
		WHILE LOCATE(DELIMITER, :CUR_SQL.GENERICATTRIBUTE1, START_POS) > 0 DO
		    END_POS := LOCATE(DELIMITER, ORIGINAL_STRING, START_POS);
		    ITEM := SUBSTRING(ORIGINAL_STRING, START_POS, END_POS - START_POS);
		    INSERT INTO TABLE_ARRAY VALUES (ITEM);
		    START_POS := END_POS + 1;
		END WHILE;
		-- Capture the last or only item
		IF START_POS <= LENGTH(ORIGINAL_STRING) THEN
		    ITEM := SUBSTRING(ORIGINAL_STRING, START_POS, LENGTH(ORIGINAL_STRING) - START_POS + 1);
		    INSERT INTO TABLE_ARRAY VALUES (ITEM);
		END IF;
        END WHILE;
        -- Iterate over the split table names and construct the FROM and JOIN clauses
        FOR EACH_ROW IN SELECT * FROM :TABLE_ARRAY DO
            DECLARE LV_TABLE_NAME NVARCHAR(128);
            LV_TABLE_NAME := TRIM(EACH_ROW.TABLE_NAME);
            
            -- Assuming the first table is the base table and others are to be joined
            IF :LV_FROM = '' THEN
                LV_FROM := LV_FROM || LV_TABLE_NAME;
            ELSE
                LV_JOIN := LV_JOIN || ' JOIN ' || LV_TABLE_NAME || ' ON ' || :JOIN_CONDITION;
            END IF;
        END FOR;

        -- Adding filter conditions
        IF FILTER_CONDITION IS NOT NULL THEN
            LV_WHERE := LV_WHERE || ' AND (' || FILTER_CONDITION || ')';
        END IF;

        FETCH C_SOURCEINFO INTO TABLE_NAMES, JOIN_CONDITION, FILTER_CONDITION;
    END WHILE;
    CLOSE C_SOURCEINFO;

    -- Combine all parts
    LV_SQL := 'SELECT ' || LV_COLUMNS || LV_FROM || LV_JOIN || LV_WHERE;

    INSERT INTO EXT.DYNAMICSQLLog (GeneratedSQL) VALUES (:LV_SQL);
    -- Execute the dynamic SQL
    EXECUTE IMMEDIATE LV_SQL;

END;




