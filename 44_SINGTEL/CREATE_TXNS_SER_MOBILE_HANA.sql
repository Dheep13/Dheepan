/*
 * This file      : DBMTK_USER_NAME.OUTBOUND_LOG_STATS.PROCEDURE.sqlscript
 * Converted from : DBMTK_USER_NAME.OUTBOUND_LOG_STATS.PROCEDURE.plsql
 *
 * Source DBMS          : Oracle, version unknown
 * Source DB servername : -undefined-
 * Target DBMS          : SAP Hana 2 >= SP05 (SQLScript)
 *
 *
 * User config(id=101) : Include default configuration settings in header of generated files: Setting=yes
 * User config(id=423) : Report identifier upper/lowercase analysis: Setting=no
 * User config(id=330) : Case mapping for usernames: Setting=nomap
 * User config(id=331) : Case mapping for names of schema objects (tables,views,columns,indexes,sequences,etc.): Setting=nomap
 * User config(id=332) : Case mapping for names of SQL objects (procedures, functions; not for variables/parameters): Setting=nomap
 * User config(id=335) : Apply case mappings also when source DBMS is case-sensitive for identifiers: Setting=no
 * User config(id=211) : Include an 'ORIGSQL' comment with the original SQL in the converted SQL: Setting=yes
 * User config(id=212) : Max. number of characters of original SQL in 'ORIGSQL' comment: Setting=80
 * User config(id=215) : Append 'NOT CONVERTED' comment to unconverted statements in the converted SQL: Setting=yes
 * User config(id=217) : Report additional details about some conversion categories, either for all files or only the totals: Setting=all
 * User config(id=218) : Report details ordered by functionality or by impact: Setting=functionality
 * User config(id=220) : Datatype to convert Oracle INT, INTEGER or SMALLINT (which have 38-digit precision): Setting=BIGINT
 * User config(id=221) : Length to convert Oracle (VAR)CHAR(2) declared without length: Setting=75
 * User config(id=222) : For variables/parameters, datatype to convert Oracle NUMBER declared without precision: Setting=NUMERIC(38,10)
 * User config(id=223) : For table/view columns, datatype to convert Oracle NUMBER declared without precision: Setting=NUMERIC(38,10)
 * User config(id=224) : For variables/parameters, datatype to convert Oracle NUMBER declared with precision but without scale(see User Guide): Setting=optimized_integer
 * User config(id=225) : For table/view columns, datatype to convert Oracle NUMBER declared with precision but without scale(see User Guide): Setting=optimized_integer
 * User config(id=231) : Length to convert a CHAR/BINARY datatype exceeding the target DBMS length: Setting=MAX
 * User config(id=265) : Convert Oracle packages to Hana User-Defined Libraries: Setting=no
 * User config(id=290) : Default conversion of DBMS_OUTPUT.PUT_LINE/GET_LINE: Setting=print
 * User config(id=292) : Conversion of PRINT-style statements: Setting=sqlscript_print
 * User config(id=300) : Conversion of REF CURSOR output parameters in procedures called from the client app: Setting=table_variable
 * User config(id=310) : Generate a SQL SECURITY/EXECUTE AS clause for procedures/functions: Setting=yes
 * User config(id=320) : Ignore or keep the leading 'N' in Unicode string notation N'...': Setting=ignore
 * User config(id=441) : Generate identity columns as BY DEFAULT or ALWAYS: Setting=by_default
 * User config(id=380) : How aggressively to convert identifiers in SQL objects (higher=slower): Setting=medium
 * User config(id=382) : How to rename identifiers that are reserved words: delimited, or with a suffix: Setting=delimited
 * User config(id=383) : How to handle identifiers that are non-recommended words (e.g. ANSI-reserved): Setting=ignore
 * User config(id=385) : When to substitute a column alias with the expression, when referenced in the query(settings are cumulative): Setting=simple_expression
 * User config(id=600) : Schema for run-time components: Setting=sapdbmtk
 * User config(id=704) : Show warning counts in Hana when running run_ddl/run_sql generated shell scripts: Setting=yes
 * User config(id=720) : Include the original SQL code at the end of the converted file: Setting=no
 * User config(id=781) : Generate call to customizable procedure after each object creation: Setting=yes
 *   NB: Settings marked '*' are set to non-defaults (use config #101=no for condensed overview))
 *
 * Project directory : C:/HANAMigrations/STELLND
 *
 *-----------------------------------------------------------------------------
 * Generated by SAP Advanced SQL Migration v.3.5.3 at 09-May-2024 20:51:40
 * (generated with: sapdbmtk convert, 64791)
 * SAP Advanced SQL Migration is property of SAP SE.
 *-----------------------------------------------------------------------------
 */
go
CALL sapdbmtk.sp_dbmtk_report_connect('DBMTK_USER_NAME.OUTBOUND_LOG_STATS.PROCEDURE.sqlscript') WITH HINT(IGNORE_PLAN_CACHE)
go

-- Verify the target database has the expected version (or later).
-- This proc aborts the script if the version is earlier than expected:
CALL sapdbmtk.sp_dbmtk_target_dbms_version_check('HANA', '2SP05', 'DBMTK_USER_NAME.OUTBOUND_LOG_STATS.PROCEDURE.sqlscript') WITH HINT(IGNORE_PLAN_CACHE)
go
CALL sapdbmtk.sp_dbmtk_hang_session  -- NB: hangs only when waiting for user to abort session with CTRL-C (message is printed first)
go

-- Verify Hana database being used
CALL sapdbmtk.sp_dbmtk_HANA_db_check()
go
CALL sapdbmtk.sp_dbmtk_hang_session  -- NB: hangs only when waiting for user to abort session with CTRL-C (message is printed first)
go

-- Verify we have the required permissions
CALL sapdbmtk.sp_dbmtk_target_permissions_check()
go
CALL sapdbmtk.sp_dbmtk_hang_session  -- NB: hangs only when waiting for user to abort session with CTRL-C (message is printed first)
go
DO BEGIN
	if exists (select * from SYS.USERS where user_name = upper('DBMTK_USER_NAME')) THEN
		EXECUTE IMMEDIATE 'CONNECT DBMTK_USER_NAME PASSWORD "JBQue%eSMPF069Wp"';
		SELECT 'Reconnected as user '''||SESSION_USER||'''' FROM SYS.DUMMY;
	END IF;
END
go
SET SCHEMA DBMTK_USER_NAME
go

/********************* Converted SQL code starts here:*************************/

/*
 * This file was extracted from 'C:/HANAMigrations/STELLND/OracleObjects/OUTBOUND_LOG_STATS.sql'
 * at 09-May-2024 20:47:14 with the 'extract_offline' command of SAP Advanced SQL Migration v.3.5.3 (64791)
 * User config setting for 'extract_offline' (id=132) was '0'.
 */
go

--********** Creating procedure 'DBMTK_USER_NAME.OUTBOUND_LOG_STATS' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.OUTBOUND_LOG_STATS''...' );
go

/* ORIGSQL: CREATE OR REPLACE PROCEDURE OUTBOUND_LOG_STATS AS v_inbound_cfg_parameter inboun(...) */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.OUTBOUND_LOG_STATS
()
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE Message1 VARCHAR(255) = 'Stage 1: File to Staging';  /* ORIGSQL: Message1 VARCHAR(255) := 'Stage 1: File to Staging'; */
    DECLARE Message2 VARCHAR(255) = 'Stage 3: Validation on Staging';  /* ORIGSQL: Message2 VARCHAR(255) := 'Stage 3: Validation on Staging'; */
    DECLARE Message3 VARCHAR(255) = 'Stage 4: Staging to ODS Table :';  /* ORIGSQL: Message3 VARCHAR(255) := 'Stage 4: Staging to ODS Table :'; */
    DECLARE Message4 VARCHAR(255) = 'Stage 5: ODS Table to Callidus Final File : ';  /* ORIGSQL: Message4 VARCHAR(255) := 'Stage 5: ODS Table to Callidus Final File : '; */
    DECLARE v_success_rec DECIMAL(38,10) = 0;  /* ORIGSQL: v_success_rec NUMBER := 0; */
    DECLARE v_failure_rec DECIMAL(38,10) = 0;  /* ORIGSQL: v_failure_rec NUMBER := 0; */
    DECLARE v_sql VARCHAR(4000);  /* ORIGSQL: v_sql VARCHAR2(4000); */
    DECLARE v_statusflag DECIMAL(38,10);  /* ORIGSQL: v_statusflag NUMBER; */

    /* ORIGSQL: FOR i IN (SELECT DISTINCT nvl(b.tablename,a.tgttable) tgttable FROM inbound_cfg_(...) */
    DECLARE CURSOR dbmtk_cursor_873
    FOR  
        SELECT   /* ORIGSQL: SELECT DISTINCT nvl(b.tablename,a.tgttable) tgttable FROM inbound_cfg_txnfield a(...) */
            DISTINCT   
            IFNULL(b.tablename,a.tgttable) AS tgttable
        FROM
            inbound_cfg_txnfield a
        LEFT OUTER JOIN
            inbound_cfg_tgttable b
            ON a.tgttable = b.tgttable
        WHERE
            filetype = v_inbound_cfg_parameter.file_type;

    /* ORIGSQL: FOR i IN (select rownum rn,tgttable from (SELECT DISTINCT nvl(b.tablename,a.tgtt(...) */
    DECLARE CURSOR dbmtk_cursor_876
    FOR
        SELECT   /* ORIGSQL: select ROW_NUMBER() OVER (ORDER BY 0*0) rn,tgttable from (SELECT DISTINCT nvl(b.(...) */
            ROW_NUMBER() OVER (ORDER BY 0*0) AS rn,  /* ORIGSQL: rownum */
            tgttable
            /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.INBOUND_CFG_TXNFIELD' not found */
            /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.INBOUND_CFG_TGTTABLE' not found */
        FROM
            (
                SELECT   /* ORIGSQL: (SELECT DISTINCT nvl(b.tablename,a.tgttable) tgttable FROM inbound_cfg_txnfield (...) */
                    DISTINCT   
                    IFNULL(b.tablename,a.tgttable) AS tgttable
                FROM
                    inbound_cfg_txnfield a
                LEFT OUTER JOIN
                    inbound_cfg_tgttable b
                    ON a.tgttable = b.tgttable
                WHERE
                    filetype = v_inbound_cfg_parameter.file_type
            ) AS dbmtk_corrname_886;

    v_inbound_cfg_parameter   inbound_cfg_parameter%ROWTYPE;;/* NOT CONVERTED! */  /* RESOLVE: Identifier not found: Table 'DBMTK_USER_NAME.inbound_cfg_parameter' not found (for %ROWTYPE declaration) */
    --  EXECUTE IMMEDIATE 'truncate table Outbound_log_details drop storage';

    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.INBOUND_CFG_PARAMETER' not found */

    SELECT *
    INTO
        v_inbound_cfg_parameter
    FROM
        inbound_cfg_parameter;

    --delete from Outbound_log_details
    --where (FILE_TYPE,FILE_NAME,FILE_DATE) not in (select FILE_TYPE,
        --FILE_NAME,
    --FILE_DATE from inbound_cfg_parameter);
    --
    --commit;

    /* ORIGSQL: dbms_output.put_line (v_inbound_cfg_parameter.file_date); */
    CALL sapdbmtk.sp_dbmtk_buffered_output_writeln(v_inbound_cfg_parameter.file_date);

    -- Get Count for Stage 1
    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.INBOUND_DATA_STAGING' not found */

    SELECT
        COUNT(*)
    INTO
        v_success_rec
    FROM
        inbound_data_staging
    WHERE
        (filetype, filename, filedate) IN
        (
            SELECT   /* ORIGSQL: (SELECT v_inbound_cfg_parameter.file_type, v_inbound_cfg_parameter.file_name, v_(...) */
                v_inbound_cfg_parameter.file_type,
                v_inbound_cfg_parameter.file_name,
                v_inbound_cfg_parameter.file_date
            FROM
                SYS.DUMMY   /* ORIGSQL: FROM DUAL) */
        );

    /*
       INSERT INTO Outbound_log_details (FILE_TYPE,FILE_NAME,FILE_DATE,STEPS_PROCESSED,RECORDS_PROCESSED,RECORDS_REJECTED)
           VALUES (v_inbound_cfg_parameter.file_type,
                       v_inbound_cfg_parameter.file_name,
                       v_inbound_cfg_parameter.file_date,
                       Message1,
                       v_success_rec,
                   0);
    */

    /* ORIGSQL: COMMIT; */
    COMMIT;

    -- Get count for Stage 2 
    SELECT
        COUNT(*) 
    INTO
        v_failure_rec
    FROM
        inbound_data_staging
    WHERE
        (filetype, filename, filedate) IN
        (
            SELECT   /* ORIGSQL: (SELECT v_inbound_cfg_parameter.file_type, v_inbound_cfg_parameter.file_name, v_(...) */
                v_inbound_cfg_parameter.file_type,
                v_inbound_cfg_parameter.file_name,
                v_inbound_cfg_parameter.file_date
            FROM
                SYS.DUMMY   /* ORIGSQL: FROM DUAL) */
        )
        AND IFNULL(error_flag, 0) <> 0;  /* ORIGSQL: NVL(error_flag, 0) */

    v_success_rec = :v_success_rec - :v_failure_rec;

    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.OUTBOUND_LOG_DETAILS' not found */

    /* ORIGSQL: INSERT INTO Outbound_log_details (FILE_TYPE,FILE_NAME,FILE_DATE,STEPS_PROCESSED,(...) */
    INSERT INTO Outbound_log_details
        (
            FILE_TYPE, FILE_NAME, FILE_DATE, STEPS_PROCESSED, RECORDS_PROCESSED, RECORDS_REJECTED
        )
    VALUES (
            v_inbound_cfg_parameter.file_type,
            v_inbound_cfg_parameter.file_name,
            v_inbound_cfg_parameter.file_date,
            :Message2,
            :v_success_rec,
            :v_failure_rec
    );

    /* ORIGSQL: COMMIT; */
    COMMIT;

    -- Get count for Stage 3
    v_failure_rec = 0;

    v_statusflag = 0;

    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.INBOUND_CFG_GENERICPARAMETER' not found */

    SELECT
        VALUE
    INTO
        v_statusflag
    FROM
        INBOUND_CFG_GENERICPARAMETER
    WHERE
        KEY = 'VALIDRECORDSTATUS';

    FOR i AS dbmtk_cursor_873
    DO
        v_sql = 'select count(*) from ';
        v_sql = IFNULL(:v_sql,'') || IFNULL(:i.tgttable,'');

        v_sql = IFNULL(:v_sql,'') || ' where (filename,filedate) in ';
        v_sql = IFNULL(:v_sql,'')
        || ' (select file_name,file_date from inbound_cfg_parameter) ';

        v_sql = IFNULL(:v_sql,'') || ' and nvl(recordstatus,0)<> ';

        v_sql = IFNULL(:v_sql,'') || IFNULL(TO_VARCHAR(:v_statusflag),'');

        /* ORIGSQL: DBMS_OUTPUT.put_line (v_sql); */
        CALL sapdbmtk.sp_dbmtk_buffered_output_writeln(:v_sql);

        /* RESOLVE: Dynamically generated SQL: Dynamically generated SQL, as executed by Execute-Immediate, convert manually */
        /* ORIGSQL: EXECUTE IMMEDIATE v_sql INTO v_failure_rec; */
        EXECUTE IMMEDIATE :v_sql INTO v_failure_rec;

        v_sql = 'select count(*) from ';
        v_sql = IFNULL(:v_sql,'') || IFNULL(:i.tgttable,'');

        v_sql = IFNULL(:v_sql,'') || ' where (filename,filedate) in ';
        v_sql = IFNULL(:v_sql,'')
        || ' (select file_name,file_date from inbound_cfg_parameter) ';

        v_sql = IFNULL(:v_sql,'') || ' and nvl(recordstatus,0)= ';

        v_sql = IFNULL(:v_sql,'') || IFNULL(TO_VARCHAR(:v_statusflag),'');

        /* ORIGSQL: DBMS_OUTPUT.put_line (v_sql); */
        CALL sapdbmtk.sp_dbmtk_buffered_output_writeln(:v_sql);

        /* RESOLVE: Dynamically generated SQL: Dynamically generated SQL, as executed by Execute-Immediate, convert manually */
        /* ORIGSQL: EXECUTE IMMEDIATE v_sql INTO v_success_rec; */
        EXECUTE IMMEDIATE :v_sql INTO v_success_rec;

        Message3 = IFNULL(:Message3,'') || ' '|| IFNULL(:i.tgttable,''); 

        /* ORIGSQL: INSERT INTO Outbound_log_details (FILE_TYPE,FILE_NAME,FILE_DATE,STEPS_PROCESSED,(...) */
        INSERT INTO Outbound_log_details
            (
                FILE_TYPE, FILE_NAME, FILE_DATE, STEPS_PROCESSED, RECORDS_PROCESSED, RECORDS_REJECTED
            )
        VALUES (
                v_inbound_cfg_parameter.file_type,
                v_inbound_cfg_parameter.file_name,
                v_inbound_cfg_parameter.file_date,
                :Message3,
                :v_success_rec,
                :v_failure_rec
        );

        /* ORIGSQL: COMMIT; */
        COMMIT;
    END FOR;  /* ORIGSQL: END LOOP; */

    -- Get count for Stage 4
    v_failure_rec = 0;

    v_statusflag = 0; 

    SELECT
        VALUE
    INTO
        v_statusflag
    FROM
        INBOUND_CFG_GENERICPARAMETER
    WHERE
        KEY = 'VALIDRECORDSTATUS';

    FOR i AS dbmtk_cursor_876
    DO
        v_sql = 'select count(*) from ';
        v_sql = IFNULL(:v_sql,'') || IFNULL(:i.tgttable,'');

        v_sql = IFNULL(:v_sql,'') || ' where (filename,filedate) in ';
        v_sql = IFNULL(:v_sql,'')
        || ' (select file_name,file_date from inbound_cfg_parameter) ';

        v_sql = IFNULL(:v_sql,'') || ' and nvl(recordstatus,0)<> ';

        v_sql = IFNULL(:v_sql,'') || IFNULL(TO_VARCHAR(:v_statusflag),'');

        /* ORIGSQL: DBMS_OUTPUT.put_line (v_sql); */
        CALL sapdbmtk.sp_dbmtk_buffered_output_writeln(:v_sql);

        /* RESOLVE: Dynamically generated SQL: Dynamically generated SQL, as executed by Execute-Immediate, convert manually */
        /* ORIGSQL: EXECUTE IMMEDIATE v_sql INTO v_failure_rec; */
        EXECUTE IMMEDIATE :v_sql INTO v_failure_rec;

        v_sql = 'select count(*) from ';
        v_sql = IFNULL(:v_sql,'') || IFNULL(:i.tgttable,'');

        v_sql = IFNULL(:v_sql,'') || ' where (filename,filedate) in ';
        v_sql = IFNULL(:v_sql,'')
        || ' (select file_name,file_date from inbound_cfg_parameter) ';

        v_sql = IFNULL(:v_sql,'') || ' and nvl(recordstatus,0)= ';

        v_sql = IFNULL(:v_sql,'') || IFNULL(TO_VARCHAR(:v_statusflag),'');

        /* ORIGSQL: DBMS_OUTPUT.put_line (v_sql); */
        CALL sapdbmtk.sp_dbmtk_buffered_output_writeln(:v_sql);

        /* RESOLVE: Dynamically generated SQL: Dynamically generated SQL, as executed by Execute-Immediate, convert manually */
        /* ORIGSQL: EXECUTE IMMEDIATE v_sql INTO v_success_rec; */
        EXECUTE IMMEDIATE :v_sql INTO v_success_rec;

        --    Message4 := Message4 || ' ' || i.rn; 

        /* ORIGSQL: INSERT INTO Outbound_log_details (FILE_TYPE,FILE_NAME,FILE_DATE,STEPS_PROCESSED,(...) */
        INSERT INTO Outbound_log_details
            (
                FILE_TYPE, FILE_NAME, FILE_DATE, STEPS_PROCESSED, RECORDS_PROCESSED, RECORDS_REJECTED
            )
        VALUES (
                v_inbound_cfg_parameter.file_type,
                v_inbound_cfg_parameter.file_name,
                v_inbound_cfg_parameter.file_date,
                IFNULL(:Message4,'') || ' '|| IFNULL(TO_VARCHAR(:i.rn),''),
                :v_success_rec,
                :v_failure_rec
        );

        /* ORIGSQL: COMMIT; */
        COMMIT;
    END FOR;  /* ORIGSQL: END LOOP; */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'OUTBOUND_LOG_STATS') WITH HINT(IGNORE_PLAN_CACHE);
go

/*
 * end of 'DBMTK_USER_NAME.OUTBOUND_LOG_STATS.PROCEDURE.sqlscript'
 */
go

