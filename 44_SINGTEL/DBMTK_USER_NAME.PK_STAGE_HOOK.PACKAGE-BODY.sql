/*
 * This file      : DBMTK_USER_NAME.PK_STAGE_HOOK.PACKAGE-BODY.sqlscript
 * Converted from : DBMTK_USER_NAME.PK_STAGE_HOOK.PACKAGE-BODY.plsql
 *
 * Source DBMS          : Oracle, version unknown
 * Source DB servername : -undefined-
 * Target DBMS          : SAP Hana 2 >= SP05 (SQLScript)
 *
 *
 * User config(id=101) : Include default configuration settings in header of generated files: Setting=yes
 * User config(id=423) : Report identifier upper/lowercase analysis: Setting=no
 * User config(id=330) : Case mapping for usernames: Setting=nomap
 * User config(id=331) : Case mapping for names of schema objects (tables,views,columns,indexes,sequences,etc.): Setting=nomap
 * User config(id=332) : Case mapping for names of SQL objects (procedures, functions; not for variables/parameters): Setting=nomap
 * User config(id=335) : Apply case mappings also when source DBMS is case-sensitive for identifiers: Setting=no
 * User config(id=211) : Include an 'ORIGSQL' comment with the original SQL in the converted SQL: Setting=yes
 * User config(id=212)*: Max. number of characters of original SQL in 'ORIGSQL' comment: Setting=200
 * User config(id=215) : Append 'NOT CONVERTED' comment to unconverted statements in the converted SQL: Setting=yes
 * User config(id=217) : Report additional details about some conversion categories, either for all files or only the totals: Setting=all
 * User config(id=218) : Report details ordered by functionality or by impact: Setting=functionality
 * User config(id=220) : Datatype to convert Oracle INT, INTEGER or SMALLINT (which have 38-digit precision): Setting=BIGINT
 * User config(id=221)*: Length to convert Oracle (VAR)CHAR(2) declared without length: Setting=255
 * User config(id=222) : For variables/parameters, datatype to convert Oracle NUMBER declared without precision: Setting=NUMERIC(38,10)
 * User config(id=223) : For table/view columns, datatype to convert Oracle NUMBER declared without precision: Setting=NUMERIC(38,10)
 * User config(id=224) : For variables/parameters, datatype to convert Oracle NUMBER declared with precision but without scale(see User Guide): Setting=optimized_integer
 * User config(id=225) : For table/view columns, datatype to convert Oracle NUMBER declared with precision but without scale(see User Guide): Setting=optimized_integer
 * User config(id=231) : Length to convert a CHAR/BINARY datatype exceeding the target DBMS length: Setting=MAX
 * User config(id=265) : Convert Oracle packages to Hana User-Defined Libraries: Setting=no
 * User config(id=290) : Default conversion of DBMS_OUTPUT.PUT_LINE/GET_LINE: Setting=print
 * User config(id=292) : Conversion of PRINT-style statements: Setting=sqlscript_print
 * User config(id=300) : Conversion of REF CURSOR output parameters in procedures called from the client app: Setting=table_variable
 * User config(id=310) : Generate a SQL SECURITY/EXECUTE AS clause for procedures/functions: Setting=yes
 * User config(id=320) : Ignore or keep the leading 'N' in Unicode string notation N'...': Setting=ignore
 * User config(id=441) : Generate identity columns as BY DEFAULT or ALWAYS: Setting=by_default
 * User config(id=380) : How aggressively to convert identifiers in SQL objects (higher=slower): Setting=medium
 * User config(id=382) : How to rename identifiers that are reserved words: delimited, or with a suffix: Setting=delimited
 * User config(id=383) : How to handle identifiers that are non-recommended words (e.g. ANSI-reserved): Setting=ignore
 * User config(id=385) : When to substitute a column alias with the expression, when referenced in the query(settings are cumulative): Setting=simple_expression
 * User config(id=600) : Schema for run-time components: Setting=sapdbmtk
 * User config(id=704) : Show warning counts in Hana when running run_ddl/run_sql generated shell scripts: Setting=yes
 * User config(id=720) : Include the original SQL code at the end of the converted file: Setting=no
 * User config(id=781) : Generate call to customizable procedure after each object creation: Setting=yes
 *   NB: Settings marked '*' are set to non-defaults (use config #101=no for condensed overview))
 *
 * Project directory : C:/HANAMigrations/AIASG
 *
 *-----------------------------------------------------------------------------
 * Generated by SAP Advanced SQL Migration v.3.5.3 at 26-May-2024 15:42:55
 * (generated with: sapdbmtk convert, 64791)
 * SAP Advanced SQL Migration is property of SAP SE.
 *-----------------------------------------------------------------------------
 */
go
CALL sapdbmtk.sp_dbmtk_report_connect('DBMTK_USER_NAME.PK_STAGE_HOOK.PACKAGE-BODY.sqlscript') WITH HINT(IGNORE_PLAN_CACHE)
go

-- Verify the target database has the expected version (or later).
-- This proc aborts the script if the version is earlier than expected:
CALL sapdbmtk.sp_dbmtk_target_dbms_version_check('HANA', '2SP05', 'DBMTK_USER_NAME.PK_STAGE_HOOK.PACKAGE-BODY.sqlscript') WITH HINT(IGNORE_PLAN_CACHE)
go
CALL sapdbmtk.sp_dbmtk_hang_session  -- NB: hangs only when waiting for user to abort session with CTRL-C (message is printed first)
go

-- Verify Hana database being used
CALL sapdbmtk.sp_dbmtk_HANA_db_check()
go
CALL sapdbmtk.sp_dbmtk_hang_session  -- NB: hangs only when waiting for user to abort session with CTRL-C (message is printed first)
go

-- Verify we have the required permissions
CALL sapdbmtk.sp_dbmtk_target_permissions_check()
go
CALL sapdbmtk.sp_dbmtk_hang_session  -- NB: hangs only when waiting for user to abort session with CTRL-C (message is printed first)
go
DO BEGIN
	if exists (select * from SYS.USERS where user_name = upper('DBMTK_USER_NAME')) THEN
		EXECUTE IMMEDIATE 'CONNECT DBMTK_USER_NAME PASSWORD "xhvz7&FN204489@y"';
		SELECT 'Reconnected as user '''||SESSION_USER||'''' FROM SYS.DUMMY;
	END IF;
END
go
SET SCHEMA DBMTK_USER_NAME
go

/********************* Converted SQL code starts here:*************************/


go

--********** Creating function 'DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__Txt_User' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating function ''DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__Txt_User''...' );
go

CREATE OR REPLACE FUNCTION DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__Txt_User
()
RETURNS dbmtk_function_result VARCHAR(20)
LANGUAGE SQLSCRIPT
AS
BEGIN
    /* ORIGSQL: Txt_User Constant Varchar2(20) := 'HookUser' ; */
    dbmtk_function_result = 'HookUser';
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('function', 'DBMTK_USER_NAME', 'f_dbmtk_constant__PK_STAGE_HOOK__Txt_User') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating function 'DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating function ''DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime''...' );
go

CREATE OR REPLACE FUNCTION DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime
()
RETURNS dbmtk_function_result TIMESTAMP
LANGUAGE SQLSCRIPT
AS
BEGIN
    /* ORIGSQL: cdt_EndOfTime constant date := to_date('01/01/2200 00:00:00', 'MM/DD/YYYY HH24:MI:SS') ; */
    dbmtk_function_result = sapdbmtk.sp_f_dbmtk_format_string_to_datetime('01/01/2200 00:00:00',  
    'MM/DD/YYYY HH24:MI:SS');
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('function', 'DBMTK_USER_NAME', 'f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime') WITH HINT(IGNORE_PLAN_CACHE);
go

/*
 * This file was extracted from 'C:/HANAMigrations/AIASG/OracleObjects/PK_STAGE_HOOK.sql'
 * at 26-May-2024 15:33:55 with the 'extract_offline' command of SAP Advanced SQL Migration v.3.5.3 (64791)
 * User config setting for 'extract_offline' (id=132) was '0'.
 */

/* ORIGSQL: CREATE OR REPLACE PACKAGE BODY PK_STAGE_HOOK AS */
/*---TYPE definition moved to  scripts/dbmtk_create_types.sqlscript ---
Type  R_Agydisttrxn Is Record(
Salestransactionseq  Int,
SALESORDERSEQ  INT,
Wagency  Varchar2(30),
wAgencyLeader  varchar2(30),
Wagyldrtitle  Varchar2(30),
LdrCurRole  Varchar2(30), /* -- add by Nelson */
Wagyldrdistrict  Varchar2(30),
CurDistrict  Varchar2(30),  /* -- add by Nelson */
Policyissuedate  Date,
Compensationdate  Date,
Wagtclass  Varchar2(30),
Commissionagy  Varchar2(30),
Runningtype  Varchar(100),
Eventtypeid  Varchar2(30),
Productname  Varchar2(100),
Businessunitmap  Varchar2(100),
Orphanpolicy  Varchar2(30),
Managerseq  Int, /* -- add for spin off */
Agyspinoffindicator  Varchar2(30),
Agyspinoffflag  Int,
Versioningdate  Date,
Periodseq  Int,
Spinstartdate  Date,
Spindaterange  Number,
Txnclasscode  Varchar2(10),
Spinenddate  Date,
actualOrphanPolicy  varchar2(30),
wAgyLdrCde  varchar2(30), /* -- add by Nelson */
setup  varchar2(30), /* -- add by Nelson */
txnCode  varchar2(30) /* -- add by Nelson */
) ;
 ---end of TYPE definition commented out---*/ 
go

/* The procedure DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global initializes the package/session variables */ 
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global''...' );
go

CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global
()
LANGUAGE SQLSCRIPT
READS SQL DATA
AS
BEGIN
    DECLARE init_timestamp VARCHAR(50) := TO_VARCHAR(CURRENT_TIMESTAMP);
    /* do not execute further if package already initialized */
    IF SESSION_CONTEXT('DBMTK_PKG_INIT_DBMTK_USER_NAME_DBMTK_PK_STAGE_HOOK__DBMTK_INIT_SESSION_GLOBAL') IS NOT NULL
    THEN
        RETURN;
    END IF;

    /* mark package as initialized */
    SET SESSION 'DBMTK_PKG_INIT_DBMTK_USER_NAME_DBMTK_PK_STAGE_HOOK__DBMTK_INIT_SESSION_GLOBAL' = :init_timestamp;
    
    BEGIN
        /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
        DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();  /* ORIGSQL: cdt_EndOfTime constant date := to_date('01/01/2200 00:00:00', 'MM/DD/YYYY HH24:MI:SS') ; */
        DECLARE Txt_User CONSTANT VARCHAR(20) = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__Txt_User();  /* ORIGSQL: Txt_User Constant Varchar2(20) := 'HookUser' ; */

        /*
        ************************************************
        Version     Create By       Create Date   Change
        ************************************************
        1           Callidus         20150407    Production version
        2           Endi             20160229    Added query hint to SP_TXA_PIAOR procedure - see Log('40')
        3           Win Tan          20160601    For Fair BSC project
        4           Win Tan          20170124    Revise the logic to process compensation portion in month-end only
        5           Jeff             20170217    PIAOR enhancement
        6           Win Tan          20180629    For BSC clawback recovery
        7           Sammi            20180709    Change Nador logic for Transfer FA agent
        8           Sammi            20181023    fix multiple position version
        9           Sammi            20181114    comment SP_TXA_PIAOR and SP_TXNTXA_YREND_PIAOR,since PIAOR has been rewrite
        10          Sammi            20181127    fix compile issue since cs_credit add a new column
        11          Jeff             201901      SPecial handling for PBU BUyout logic due to 27 Nov 2018 tripple commision load issue
        12          Endi             20190530    specify column for insert into PMCREDITTRACE in SP_CLAWBACK_CALCULATION due to 1905 release
        13          Sammi            20191001    Exclude FYC_Introducer and OFYC_Introducer for PI/AOR/NADOR Pre classify in Comcleanassignment
        14          Amanda           20190522    For BSC SPI/SPI_FA Clawback enhancement
        15          Yang             20220513    Harmonizationn Tier3 lumpsum
        16          Endi             20220917    Add month-end check for PBU Lumpsum
        17          Endi             20220926    Finetune PBU stagehook
        18          Duncan           20221031    don't delete 3rd party transactionassignment
        19          Endi             20230211    BSC CB special batch enhancement
        20          Michael Tang     20230217    Nador issue: Migrate-then-Promote
        21          Zero Wang        20230704    GST enhancement
        22          Zero Wang        20231128    For MAS Section86 project
        23          Wendy Wang       20231207    For MAS Section86 project, PBU Lumpsum
        24          Zero Wang        20240221    For MAS Section86 project Nador
        */

        DECLARE gv_error VARCHAR(1000) = NULL;  /* ORIGSQL: gv_error varchar2(1000); */
        DECLARE gv_prePeriodSeq1 BIGINT = 0;  /* ORIGSQL: gv_prePeriodSeq1 int := 0; */

        -- last period
        DECLARE gv_prePeriodSeq2 BIGINT = 0;  /* ORIGSQL: gv_prePeriodSeq2 int := 0; */

        -- last 2 period
        DECLARE Gv_Periodname VARCHAR(100) = NULL;  /* ORIGSQL: Gv_Periodname Varchar2(100); */
        DECLARE Gv_Processingunitseq BIGINT = 38280596832649218;  /* ORIGSQL: Gv_Processingunitseq Int := 38280596832649218; */
        DECLARE Gv_Periodseq BIGINT = 2533274790398900;  /* ORIGSQL: Gv_Periodseq Int := 2533274790398900; */

        --last period  November 2014
        DECLARE gv_calendarSeq BIGINT = 2251799813685250;  /* ORIGSQL: gv_calendarSeq int := 2251799813685250; */
        DECLARE gv_plStartTime TIMESTAMP = NULL;  /* ORIGSQL: gv_plStartTime timestamp; */
        DECLARE gv_isYearEnd BIGINT = 0;  /* ORIGSQL: gv_isYearEnd int := 0; */
        DECLARE gv_isMonthEnd BIGINT = 0;  /* ORIGSQL: gv_isMonthEnd int := 0; */
        DECLARE Gv_Pipelinerunseq BIGINT = 0;  /* ORIGSQL: Gv_Pipelinerunseq Int := 0; */
        DECLARE gv_CrossoverEffectiveDate TIMESTAMP = NULL;  /* ORIGSQL: gv_CrossoverEffectiveDate date; */

        --for revamp begin
        DECLARE Gv_Setnumbernador1 BIGINT = 6;  /* ORIGSQL: Gv_Setnumbernador1 Int := 6; */

        --for revamp end
        DECLARE Gv_Setnumbernador BIGINT = 5;  /* ORIGSQL: Gv_Setnumbernador Int := 5; */
        DECLARE Gv_Setnumberpi BIGINT = 3;  /* ORIGSQL: Gv_Setnumberpi Int := 3; */
        DECLARE gv_setnumberaor BIGINT = 4;  /* ORIGSQL: gv_setnumberaor Int := 4; */

        --for revamp begin
        DECLARE Gv_Setnumberoragy BIGINT = 101;  /* ORIGSQL: Gv_Setnumberoragy Int := 101; */
        DECLARE Gv_Setnumberordist BIGINT = 102;  /* ORIGSQL: Gv_Setnumberordist Int := 102; */
        DECLARE Gv_Setnumberoragyanddist BIGINT = 103;  /* ORIGSQL: Gv_Setnumberoragyanddist Int := 103; */

        --for revamp end
        DECLARE gv_hryc BIGINT = 16607023625930577;  /* ORIGSQL: gv_hryc int := 16607023625930577; */

        /* Next lines imported from package header (DBMTK_USER_NAME.PK_STAGE_HOOK.PACKAGE.plsql): */
        /* package/session variables start here: */

        /* End lines imported from package header */

        /* saving values of initialized package/session variables: */
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR' = :gv_error;
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PREPERIODSEQ1' = CAST(:gv_prePeriodSeq1 AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PREPERIODSEQ2' = CAST(:gv_prePeriodSeq2 AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODNAME' = :Gv_Periodname;
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ' = CAST(:Gv_Processingunitseq AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ' = CAST(:Gv_Periodseq AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CALENDARSEQ' = CAST(:gv_calendarSeq AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PLSTARTTIME' = TO_VARCHAR(:gv_plStartTime, 'yyyy Mon dd hh24:mi:ss:ff3');
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ISYEAREND' = CAST(:gv_isYearEnd AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ISMONTHEND' = CAST(:gv_isMonthEnd AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PIPELINERUNSEQ' = CAST(:Gv_Pipelinerunseq AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CROSSOVEREFFECTIVEDATE' = TO_VARCHAR(:gv_CrossoverEffectiveDate, 'yyyy Mon dd hh24:mi:ss:ff3');
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERNADOR1' = CAST(:Gv_Setnumbernador1 AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERNADOR' = CAST(:Gv_Setnumbernador AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERPI' = CAST(:Gv_Setnumberpi AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERAOR' = CAST(:gv_setnumberaor AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERORAGY' = CAST(:Gv_Setnumberoragy AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERORDIST' = CAST(:Gv_Setnumberordist AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERORAGYANDDIST' = CAST(:Gv_Setnumberoragyanddist AS VARCHAR(512));
        SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_HRYC' = CAST(:gv_hryc AS VARCHAR(512));
        /* package/session variables end here */
    END;
END;
go

--- must be defined here for testing, otherwise, HRYC will be impact
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__dbmtk_init_session_global') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__Log' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__Log''...' );
go

/* ORIGSQL: procedure Log(inText varchar2) is BEGIN AUTONOMOUS TRANSACTION vText varchar2(4000); */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__Log
(
    IN inText VARCHAR(255)   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                             /* ORIGSQL: inText varchar2 */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE vText VARCHAR(4000);  /* ORIGSQL: vText varchar2(4000); */

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            /* ORIGSQL: rollback; */
            ROLLBACK;

            /* ORIGSQL: raise; */
            RESIGNAL;
        END;



    /* ORIGSQL: pragma autonomous_transaction; */
    BEGIN AUTONOMOUS TRANSACTION
        vText = SUBSTRING(:inText,1,4000);  /* ORIGSQL: substr(inText, 1, 4000) */

        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_DEBUG_CUSTOM' not found */

        /* ORIGSQL: insert into CS_Debug_custom (text, value) values ('STAGEHOOK_' || vText, 1); */
        INSERT INTO CS_Debug_custom
            (
                text, value
            )
        VALUES (
                'STAGEHOOK_' || IFNULL(:vText,''),
                1
        );

        /* ORIGSQL: commit; */
        COMMIT;

        /* ORIGSQL: dbms_output.put_line('STAGEHOOK_' || vText); */
        /* RESOLVE: Statement 'CALL sapdbmtk.sp_dbmtk_buffered_output_writeln' not currently supported in HANA AUTONOMOUS TRANSACTION */
        CALL sapdbmtk.sp_dbmtk_buffered_output_writeln('STAGEHOOK_' || IFNULL(:vText,''));

        /* ORIGSQL: exception when others then */
    END;

    /*
    Modified at Aug 17 2014
    Desc: change tbl_agent_move to DM_tbl_agent_move
    */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__Log') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__Sp_Update_Txn' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__Sp_Update_Txn''...' );
go

/* ORIGSQL: Procedure Sp_Update_Txn(In_Periodseq In Int) as DEC_TXNADJSEQ CS_TransactionAdjustment.transactionadjustmentseq%TYPE; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__Sp_Update_Txn
(
    IN In_Periodseq BIGINT     /* ORIGSQL: In_Periodseq IN Int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN SEQUENTIAL EXECUTION
    DECLARE DBMTK_TMPVAR_INT_6 BIGINT; /*sapdbmtk-generated help variable*/
    DECLARE DBMTK_TMPVAR_INT_7 BIGINT; /*sapdbmtk-generated help variable*/
    DECLARE DBMTK_TMPVAR_STRING_1 VARCHAR(5000); /*sapdbmtk-generated help variable*/
    DECLARE DBMTK_TMPVAR_TIMESTAMP_1 TIMESTAMP; /*sapdbmtk-generated help variable*/
    DECLARE DBMTK_TMPVAR_TIMESTAMP_2 TIMESTAMP; /*sapdbmtk-generated help variable*/
    DECLARE DBMTK_TMPVAR_TIMESTAMP_3 TIMESTAMP; /*sapdbmtk-generated help variable*/
    DECLARE DBMTK_TMPVAR_TIMESTAMP_4 TIMESTAMP; /*sapdbmtk-generated help variable*/
    DECLARE DBMTK_TMPVAR_TIMESTAMP_5 TIMESTAMP; /*sapdbmtk-generated help variable*/
    DECLARE DBMTK_CTV_PROCID INT := sapdbmtk.sp_f_dbmtk_ctv_procid(); /*sapdbmtk-generated help variable*/
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    /* RESOLVE: Identifier not found: Table/Column 'CS_Message.messageSeq' not found (for %TYPE declaration) */

    DECLARE v_transferDate TIMESTAMP;  /* ORIGSQL: v_transferDate date; */
    DECLARE v_componentValue VARCHAR(30) = 'TXNUPD';  /* ORIGSQL: v_componentValue varchar2(30) := 'TXNUPD'; */
    DECLARE vstartdate TIMESTAMP;  /* ORIGSQL: vstartdate date; */
    DECLARE venddate TIMESTAMP;  /* ORIGSQL: venddate date; */
    DECLARE vparname VARCHAR(255);  /* ORIGSQL: vparname varchar2(255); */
    DECLARE v_ET1 DECIMAL(38,10);  /* ORIGSQL: v_ET1 number; */
    DECLARE v_ET2 DECIMAL(38,10);  /* ORIGSQL: v_ET2 number; */
    DECLARE v_ET3 DECIMAL(38,10);  /* ORIGSQL: v_ET3 number; */
    DECLARE v_ET4 DECIMAL(38,10);  /* ORIGSQL: v_ET4 number; */
    DECLARE v_ET5 DECIMAL(38,10);  /* ORIGSQL: v_ET5 number; */
    DECLARE v_ET6 DECIMAL(38,10);  /* ORIGSQL: v_ET6 number; */
    DECLARE v_ET7 DECIMAL(38,10);  /* ORIGSQL: v_ET7 number; */
    DECLARE v_ET8 DECIMAL(38,10);  /* ORIGSQL: v_ET8 number; */
    DECLARE v_ET9 DECIMAL(38,10);  /* ORIGSQL: v_ET9 number; */
    DECLARE vSQL VARCHAR(4000);  /* ORIGSQL: vSQL varchar2(4000); */
    DECLARE vDecodeSQL VARCHAR(1000);  /* ORIGSQL: vDecodeSQL varchar2(1000); */

    /* RESOLVE: Identifier not found: Table/Column 'cs_gasalestransaction.genericdate7' not found (for %TYPE declaration) */

    DECLARE l_txnseq DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__txnseq_t;  /* ORIGSQL: l_txnseq txnseq_t; */
    DECLARE l_transferdt DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__transferdt_t;  /* ORIGSQL: l_transferdt transferdt_t; */
    DECLARE l_contractdt DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__contractdt_t;  /* ORIGSQL: l_contractdt contractdt_t; */
    DECLARE l_welcomepk DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__welcomepk_t;  /* ORIGSQL: l_welcomepk welcomepk_t; */
    DECLARE l_assigndt DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__assigndt_t;  /* ORIGSQL: l_assigndt assigndt_t; */
    DECLARE l_ldrsocdt DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__ldrsocdt_t;  /* ORIGSQL: l_ldrsocdt ldrsocdt_t; */
    DECLARE l_starttxndt DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__starttxndt_t;  /* ORIGSQL: l_starttxndt starttxndt_t; */

    DECLARE indx INT;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: When Others Then */
        BEGIN
            /* ORIGSQL: ROLLBACK; */
            ROLLBACK;

            --Log('Update failure with Error:'||sqlerrm);
            /* ORIGSQL: raise; */
            RESIGNAL;

            /* sapdbmtk: Closing RETURN in exception handler commented out, not supported in HANA */
            --RETURN;
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
        /* end of package/session variables */


    :DEC_TXNADJSEQ     CS_TransactionAdjustment.transactionadjustmentseq%TYPE;;/* NOT CONVERTED! */  /* RESOLVE: Identifier not found: Table/Column 'CS_TransactionAdjustment.transactionadjustmentseq' not found (for %TYPE declaration) */
    :DEC_TXNSEQ        CS_SalesTransaction.salestransactionseq%TYPE;;/* NOT CONVERTED! */  /* RESOLVE: Identifier not found: Table/Column 'CS_SalesTransaction.salestransactionseq' not found (for %TYPE declaration) */
    :DEC_MessageLogSeq CS_Message.messageLogSeq%type;;/* NOT CONVERTED! */  /* RESOLVE: Identifier not found: Table/Column 'CS_Message.messageLogSeq' not found (for %TYPE declaration) */
    :DEC_MessageSeq    CS_Message.messageSeq%type;;/* NOT CONVERTED! */

    /* Mark -20150820 - start */

    /*--- TYPE definition moved to  scripts/dbmtk_create_types.sqlscript ---
    ----- Converted type 'txnseq_t' to 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__txnseq_t'
    TYPE txnseq_t IS TABLE OF cs_salestransaction.salestransactionseq%TYPE;
    ---end of TYPE definition commented out---*/
    /* RESOLVE: Identifier not found: Table/Column 'cs_salestransaction.salestransactionseq' not found (for %TYPE declaration) */

    /*--- TYPE definition moved to  scripts/dbmtk_create_types.sqlscript ---
    ----- Converted type 'transferdt_t' to 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__transferdt_t'
    TYPE transferdt_t IS TABLE OF cs_gasalestransaction.genericdate2%TYPE;
    ---end of TYPE definition commented out---*/
    /* RESOLVE: Identifier not found: Table/Column 'cs_gasalestransaction.genericdate2' not found (for %TYPE declaration) */

    /*--- TYPE definition moved to  scripts/dbmtk_create_types.sqlscript ---
    ----- Converted type 'contractdt_t' to 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__contractdt_t'
    TYPE contractdt_t IS TABLE OF cs_gasalestransaction.genericdate1%TYPE;
    ---end of TYPE definition commented out---*/
    /* RESOLVE: Identifier not found: Table/Column 'cs_gasalestransaction.genericdate1' not found (for %TYPE declaration) */

    /*--- TYPE definition moved to  scripts/dbmtk_create_types.sqlscript ---
    ----- Converted type 'welcomepk_t' to 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__welcomepk_t'
    TYPE welcomepk_t IS TABLE OF cs_gasalestransaction.genericboolean1%TYPE;
    ---end of TYPE definition commented out---*/
    /* RESOLVE: Identifier not found: Table/Column 'cs_gasalestransaction.genericboolean1' not found (for %TYPE declaration) */

    /*--- TYPE definition moved to  scripts/dbmtk_create_types.sqlscript ---
    ----- Converted type 'assigndt_t' to 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__assigndt_t'
    TYPE assigndt_t IS TABLE OF cs_gasalestransaction.genericdate3%TYPE;
    ---end of TYPE definition commented out---*/
    /* RESOLVE: Identifier not found: Table/Column 'cs_gasalestransaction.genericdate3' not found (for %TYPE declaration) */

    /*--- TYPE definition moved to  scripts/dbmtk_create_types.sqlscript ---
    ----- Converted type 'ldrsocdt_t' to 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__ldrsocdt_t'
    TYPE ldrsocdt_t IS TABLE OF cs_gasalestransaction.genericdate5%TYPE;
    ---end of TYPE definition commented out---*/
    /* RESOLVE: Identifier not found: Table/Column 'cs_gasalestransaction.genericdate5' not found (for %TYPE declaration) */

    /*--- TYPE definition moved to  scripts/dbmtk_create_types.sqlscript ---
    ----- Converted type 'starttxndt_t' to 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_TXN__starttxndt_t'
    TYPE starttxndt_t IS TABLE OF cs_gasalestransaction.genericdate7%TYPE;
    ---end of TYPE definition commented out---*/ 
    /* Mark -20150820 - end */

    /* ORIGSQL: comInitialPartition(v_componentValue, v_componentValue, in_periodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__ComInitialpartition(:v_componentValue, :v_componentValue, :In_Periodseq);

    /* ORIGSQL: Log('Start 1') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Start 1');

    --Mark 20150820
    --Maintenance.Enablepdml;

    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_PERIOD' not found */

    SELECT
        Startdate,
        enddate
    INTO
        vstartdate,
        venddate
    FROM
        cs_period per
    WHERE
        per.periodSeq = :In_Periodseq
        AND per.removedate = :cdt_EndOfTime;

    /* ORIGSQL: Log('Looking for partition  ' || gv_ProcessingUnitSeq || ' date ' || to_char(venddate, 'YYYYMMDD') || ' periodseq ' || in_periodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Looking for partition  '|| IFNULL(TO_VARCHAR(:Gv_Processingunitseq),'') || ' date '|| IFNULL(TO_VARCHAR(:venddate,'YYYYMMDD'),'') || ' periodseq '|| IFNULL(TO_VARCHAR(:In_Periodseq),'') 
        );  /* ORIGSQL: to_char(venddate, 'YYYYMMDD') */

    vparname = 'P_AIAS_00002_20161201';
    BEGIN 
        DECLARE EXIT HANDLER FOR SQLEXCEPTION
            /* ORIGSQL: when others then */
            BEGIN
                /* ORIGSQL: RAISE_APPLICATION_ERROR(-20000,'No TX partition found, goodbye') */
                -- sapdbmtk: mapped error code -20000 => 10000: (ABS(-20000)%10000)+10000
                SIGNAL SQL_ERROR_CODE 10000 SET MESSAGE_TEXT = 'No TX partition found, goodbye';
            END;


        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_SALESTRANSACTION' not found */

        SELECT
            (
                SELECT   /* ORIGSQL: (SELECT subobject_name FROM all_objects WHERE data_object_id = dbms_rowid.rowid_object (CS_SALESTRANSACTION.CS_SALESTRANSACTION.ROWID)) */
                    subobject_name
                FROM
                    SYS.OBJECTS  /* RESOLVE: Catalog reference(partly converted): Oracle catalog 'ALL_OBJECTS': verify conversion */
                                 /* ORIGSQL: all_objects (Oracle catalog) */
                WHERE
                    data_object_id = dbms_rowid.rowid_object (CS_SALESTRANSACTION."ROWID")  /* RESOLVE: Standard Package call(not converted): 'dbms_rowid.rowid_object' not supported, manual conversion required */
                                                                                            /* RESOLVE: Identifier renamed, reserved word in target DBMS: column 'ROWID' (=reserved word in HANA) renamed to '"ROWID"'; ensure all calls/references are renamed accordingly */
                                                                                            /* ORIGSQL: CS_SALESTRANSACTION.ROWID */
            )
        INTO
            vparname
        FROM
            CS_SALESTRANSACTION
        WHERE
            tenantid = 'AIAS'
            AND processingUnitseq = :Gv_Processingunitseq
            AND compensationdate >= :vstartdate
            AND compensationdate < :venddate
        LIMIT 1;  /* ORIGSQL: rownum = 1 */

        /* ORIGSQL: exception when others then */
    END;

    /* ORIGSQL: Log('Found partition name  ' || NVL(vParName, 'NULL')) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Found partition name  '|| IFNULL(:vparname, 'NULL') 
        );  /* ORIGSQL: NVL(vParName, 'NULL') */

    v_ET1 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('APF');  /* ORIGSQL: Comgeteventtypeseq('APF') */

    v_ET2 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('APF Payable');  /* ORIGSQL: Comgeteventtypeseq('APF Payable') */

    v_ET3 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('API');  /* ORIGSQL: Comgeteventtypeseq('API') */

    v_ET4 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('FYC');  /* ORIGSQL: Comgeteventtypeseq('FYC') */

    v_ET5 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('OFYC');  /* ORIGSQL: Comgeteventtypeseq('OFYC') */

    v_ET6 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('ORYC');  /* ORIGSQL: Comgeteventtypeseq('ORYC') */

    v_ET7 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('OSSCP');  /* ORIGSQL: Comgeteventtypeseq('OSSCP') */

    v_ET8 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('SSCP');  /* ORIGSQL: Comgeteventtypeseq('SSCP') */

    v_ET9 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('RYC');  /* ORIGSQL: Comgeteventtypeseq('RYC') */

    --Maintenance.Enablepdml;

    vDecodeSQL = 'decode(TXn.EVENTTYPESEQ,'|| IFNULL(TO_VARCHAR(:v_ET1),'') || ',''APF'''|| ','||
        IFNULL(TO_VARCHAR(:v_ET2),'') || ',''APF Payable'''|| ','|| IFNULL(TO_VARCHAR(:v_ET3),'') || ',''API'''|| ','||
        IFNULL(TO_VARCHAR(:v_ET4),'') || ',''FYC'''|| ','|| IFNULL(TO_VARCHAR(:v_ET5),'') || ',''OFYC'''|| ','||
        IFNULL(TO_VARCHAR(:v_ET6),'') || ',''ORYC'''|| ','|| IFNULL(TO_VARCHAR(:v_ET7),'') || ',''OSSCP'''|| ','||
        IFNULL(TO_VARCHAR(:v_ET8),'') || ',''SSCP'''|| ','|| IFNULL(TO_VARCHAR(:v_ET9),'') || ',''RYC'')';

    /* ORIGSQL: Log('Found decode string  ' || vDecodeSQL) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Found decode string  '|| IFNULL(:vDecodeSQL,''));

    vSQL = 'Insert /*+ append  */ Into Sh_Query_Result ';

    vSQL = IFNULL(:vSQL,'') ||
    '(Component,periodseq,Genericsequence1, Genericnumber1, Genericnumber2, Genericattribute1, genericattribute2, Genericattribute3, Genericattribute4, Genericattribute5,   genericboolean1,  Genericboolean2, Genericdate1,  genericdate2,  Genericdate3,  genericsequence2,  Genericattribute6,  Genericattribute7,  Genericattribute8,  Genericdate4,  genericDate5  ) ';

    vSQL = IFNULL(:vSQL,'') ||
    'SELECT   /*+ parallel(8) FULL(st) FULL(ta) USE_HASH(st,ta)*/ '|| ''''||
    IFNULL(:v_componentValue,'') || ''','|| IFNULL(TO_VARCHAR(:In_Periodseq),'') ||
    ', txn.salestransactionseq, ';

    vSQL = IFNULL(:vSQL,'') || '   txn.linenumber, ';

    vSQL = IFNULL(:vSQL,'') || '   txn.sublinenumber, ';

    vSQL = IFNULL(:vSQL,'') || ' '|| IFNULL(:vDecodeSQL,'') || ' as eventtypeid, ';

    vSQL = IFNULL(:vSQL,'') || '   txn.salesorderseq, ';

    vSQL = IFNULL(:vSQL,'') || '   txn.businessunitmap, ';

    vSQL = IFNULL(:vSQL,'') || '   txn.genericattribute14 as classCode, ';

    vSQL = IFNULL(:vSQL,'') || '   Pos.Genericattribute4, ';

    vSQL = IFNULL(:vSQL,'') ||
    '   decode(nvl(pos.genericattribute4,''#''),nvl(txn.genericattribute14,''#''),1,0), ';

    vSQL = IFNULL(:vSQL,'') || '   pos.genericBoolean4 as welcomePackage, ';

    vSQL = IFNULL(:vSQL,'') || '   pa.hireDate as contractDate, ';

    vSQL = IFNULL(:vSQL,'') || '   pos.genericDate4 as assignmentDate, ';

    vSQL = IFNULL(:vSQL,'') || '   Gpa.Genericdate6 As Leadersocdate,  ';

    vSQL = IFNULL(:vSQL,'') || '   pos.ruleElementOwnerSeq as AgtPosSeq, ';

    vSQL = IFNULL(:vSQL,'') || '   txn.genericAttribute12 as agentCode, ';

    vSQL = IFNULL(:vSQL,'') || '   Txn.Genericattribute13 As Agencycode, ';

    vSQL = IFNULL(:vSQL,'') || '   Txn.Businessunitmap, ';

    vSQL = IFNULL(:vSQL,'') || '   Gapos12.Genericdate19 As Starttransactiondate, ';

    vSQL = IFNULL(:vSQL,'') || '   txn.compensationdate as compdate ';

    vSQL = IFNULL(:vSQL,'') || ' FROM Cs_Salestransaction PARTITION('|| IFNULL(:vparname,'') ||
    ') Txn ';

    vSQL = IFNULL(:vSQL,'') || '   INNER JOIN cs_transactionassignment PARTITION('|| IFNULL(:vparname,'') ||
    ') asg ';

    vSQL = IFNULL(:vSQL,'') ||
    '   ON txn.salestransactionseq=asg.salestransactionseq and asg.tenantid=''AIAS'' ';

    vSQL = IFNULL(:vSQL,'') || ' AND asg.positionname like ''%T%'' ';

    vSQL = IFNULL(:vSQL,'') ||
    ' and nvl(txn.genericattribute12,''#'') = substr(asg.positionname,4,8) ';

    vSQL = IFNULL(:vSQL,'') || ' INNER JOIN cs_position pos ';

    vSQL = IFNULL(:vSQL,'') || '   ON pos.removedate = :cdt_EndOfTime ';

    vSQL = IFNULL(:vSQL,'') || ' AND pos.name               = asg.positionname ';

    vSQL = IFNULL(:vSQL,'') || ' And Pos.Effectivestartdate< to_date('''||
        IFNULL(TO_VARCHAR(:venddate,'yyyymmdd'),'') || ''',''yyyymmdd'') ';  /* ORIGSQL: to_char(venddate, 'yyyymmdd') */

    vSQL = IFNULL(:vSQL,'') || ' and pos.tenantid=''AIAS'' and pos.effectiveEnddate>= to_date('''||
        IFNULL(TO_VARCHAR(:venddate,'yyyymmdd'),'') || ''',''yyyymmdd'') ';  /* ORIGSQL: to_char(venddate, 'yyyymmdd') */

    vSQL = IFNULL(:vSQL,'') || ' left join cs_participant pa ';

    vSQL = IFNULL(:vSQL,'') || '   on pos.payeeSeq=pa.payeeSeq ';

    vSQL = IFNULL(:vSQL,'') || ' and pa.tenantid=''AIAS'' and pa.effectiveStartDate < to_date('''||
        IFNULL(TO_VARCHAR(:venddate,'yyyymmdd'),'') || ''',''yyyymmdd'') ';  /* ORIGSQL: to_char(venddate, 'yyyymmdd') */

    vSQL = IFNULL(:vSQL,'') || ' and pa.effectiveEndDate >= to_date('''||
        IFNULL(TO_VARCHAR(:venddate,'yyyymmdd'),'') || ''',''yyyymmdd'') ';  /* ORIGSQL: to_char(venddate, 'yyyymmdd') */

    vSQL = IFNULL(:vSQL,'') || ' and pa.removeDate=:cdt_EndOfTime ';

    vSQL = IFNULL(:vSQL,'') || ' left join cs_gaparticipant gpa ';

    vSQL = IFNULL(:vSQL,'') || '   on pa.payeeSeq=gpa.payeeSeq ';

    vSQL = IFNULL(:vSQL,'') || ' and gpa.tenantid=''AIAS'' and gpa.effectiveStartDate < to_date('''||
        IFNULL(TO_VARCHAR(:venddate,'yyyymmdd'),'') || ''',''yyyymmdd'') ';  /* ORIGSQL: to_char(venddate, 'yyyymmdd') */

    vSQL = IFNULL(:vSQL,'') || ' and gpa.effectiveEndDate >= to_date('''||
        IFNULL(TO_VARCHAR(:venddate,'yyyymmdd'),'') || ''',''yyyymmdd'') ';  /* ORIGSQL: to_char(venddate, 'yyyymmdd') */

    vSQL = IFNULL(:vSQL,'') || ' And Gpa.Removedate=:Cdt_Endoftime ';

    vSQL = IFNULL(:vSQL,'') || ' And Gpa.Pagenumber=0 ';

    vSQL = IFNULL(:vSQL,'') || ' Inner Join Cs_Position Posga12 ';

    vSQL = IFNULL(:vSQL,'') || '   on ''SGT''||txn.Genericattribute12=Posga12.Name ';

    vSQL = IFNULL(:vSQL,'') || ' and Posga12.tenantid=''AIAS'' And Posga12.Removedate=:Cdt_Endoftime ';

    vSQL = IFNULL(:vSQL,'') || ' And Posga12.Effectivestartdate < to_date('''||
        IFNULL(TO_VARCHAR(:venddate,'yyyymmdd'),'') || ''',''yyyymmdd'') ';  /* ORIGSQL: to_char(venddate, 'yyyymmdd') */

    vSQL = IFNULL(:vSQL,'') || ' and Posga12.tenantid=''AIAS'' And Posga12.Effectiveenddate  >= to_date('''||
        IFNULL(TO_VARCHAR(:venddate,'yyyymmdd'),'') || ''',''yyyymmdd'') ';  /* ORIGSQL: to_char(venddate, 'yyyymmdd') */

    vSQL = IFNULL(:vSQL,'') || ' Inner Join Cs_Gaposition Gapos12 ';

    vSQL = IFNULL(:vSQL,'') || '   on Gapos12.Pagenumber=0 and Gapos12.tenantid=''AIAS'' ';

    vSQL = IFNULL(:vSQL,'') ||
    ' And posga12.ruleElementOwnerSeq=Gapos12.ruleElementOwnerSeq ';

    vSQL = IFNULL(:vSQL,'') || ' And Gapos12.Removedate=:Cdt_Endoftime ';

    vSQL = IFNULL(:vSQL,'') || ' And Gapos12.Effectivestartdate < to_date('''||
        IFNULL(TO_VARCHAR(:venddate,'yyyymmdd'),'') || ''',''yyyymmdd'') ';  /* ORIGSQL: to_char(venddate, 'yyyymmdd') */

    vSQL = IFNULL(:vSQL,'') || ' and Gapos12.effectiveEndDate >= to_date('''||
        IFNULL(TO_VARCHAR(:venddate,'yyyymmdd'),'') || ''',''yyyymmdd'') ';  /* ORIGSQL: to_char(venddate, 'yyyymmdd') */

    vSQL = IFNULL(:vSQL,'') || ' WHERE txn.tenantid=''AIAS'' and TXN.EVENTTYPESEQ IN ('|| IFNULL(TO_VARCHAR(:v_ET1),'') || ','|| IFNULL(TO_VARCHAR(:v_ET2),'') || ','||
        IFNULL(TO_VARCHAR(:v_ET3),'') || ','|| IFNULL(TO_VARCHAR(:v_ET4),'') || ','|| IFNULL(TO_VARCHAR(:v_ET5),'') || ','|| IFNULL(TO_VARCHAR(:v_ET6),'') || ','||
        IFNULL(TO_VARCHAR(:v_ET7),'') || ','|| IFNULL(TO_VARCHAR(:v_ET8),'') || ','|| IFNULL(TO_VARCHAR(:v_ET9),'') || ')';

    /* ORIGSQL: dbms_output.put_line('SQL is ' || vSQL); */
    CALL sapdbmtk.sp_dbmtk_buffered_output_writeln('SQL is '|| IFNULL(:vSQL,''));

    /* ORIGSQL: Log('SQL is ' || vSQL) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SQL is '|| IFNULL(:vSQL,''));

    /* RESOLVE: Dynamically generated SQL: Dynamically generated SQL, as executed by Execute-Immediate, convert manually */
    /* ORIGSQL: execute immediate vSQL using Cdt_Endoftime, Cdt_Endoftime, Cdt_Endoftime, Cdt_Endoftime, Cdt_Endoftime; */
    CALL sapdbmtk.sp_dbmtk_prepare_execute_sql(:vSQL, :DBMTK_TMPVAR_STRING_1);
    EXECUTE IMMEDIATE :DBMTK_TMPVAR_STRING_1 USING :cdt_EndOfTime, :cdt_EndOfTime, :cdt_EndOfTime, :cdt_EndOfTime, :cdt_EndOfTime;

    /* ORIGSQL: Log('End 1') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('End 1');

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('Start 2') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Start 2');

    --Mark 20150820
    --  Merge  Into Cs_Salestransaction Txn 
    /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
    /* ORIGSQL: Merge Into Cs_Salestransaction Txn Using (SELECT R.genericsequence1 AS salestransactionseq, R.Genericattribute5 AS Classcode, R.Genericboolean1 AS Classcodeflag FROM Sh_Query_Result R Where Component (...) */
    MERGE INTO Cs_Salestransaction AS Txn
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.SH_QUERY_RESULT' not found */
        USING
        (
            SELECT   /* ORIGSQL: (Select R.genericsequence1 as salestransactionseq, R.Genericattribute5 As Classcode, R.Genericboolean1 As Classcodeflag From Sh_Query_Result R Where Component = v_componentValue and periodseq = in_per(...) */
                R.genericsequence1 AS salestransactionseq,
                /* --R.Genericattribute4 As Classcode, */
                R.Genericattribute5 AS Classcode /* --update by pos.classcode */, R.Genericboolean1 AS Classcodeflag
            FROM
                Sh_Query_Result R
            WHERE
                Component = :v_componentValue
                AND periodseq = :In_Periodseq
                AND r.genericboolean1 = 0 --only the ps.classcode is differet from txn.classcode, then will be update
        ) AS T
        ON (t.salestransactionseq = txn.salestransactionseq
        AND txn.tenantid = 'AIAS')
    WHEN MATCHED THEN
        UPDATE SET Txn.Genericattribute14 = T.Classcode;

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('End  2') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('End  2');

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('Start  3') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Start  3');

    /* Mark -20150820 - start */
    dbmtk_bulk_tabvar_1201 =   /* ORIGSQL: bulk collect into l_txnseq, l_transferdt, l_contractdt, l_welcomepk, l_assigndt, l_ldrsocdt, l_starttxndt */
    WITH 
    transferset   
    AS (
        /* ORIGSQL: select / *+ MATERIALIZE NO_INDEX(R) * / */
        SELECT   /* ORIGSQL: (select p.ruleelementownerseq, r.genericSequence1 as salestransactionseq, 0 as pagenumber, r.genericdate1 as Contractdate, gatxn.genericdate1 as TxnContractdate, r.genericboolean2 as Welcomepackage, g(...) */
            p.ruleelementownerseq,
            r.genericSequence1 AS salestransactionseq,
            0 AS pagenumber,
            r.genericdate1 AS Contractdate,
            gatxn.genericdate1 AS TxnContractdate,
            r.genericboolean2 AS Welcomepackage,
            gatxn.genericboolean1 AS TxnWelcomepackage,
            CASE
                WHEN (p.genericattribute1 = r.genericattribute7
                AND p.Transferdate IS NOT NULL)
                THEN p.Transferdate
                ELSE m.oldTransferDate
            END
            AS TransferDate,
            gatxn.genericdate2 AS TxnTransferdate,
            r.genericdate2 AS AssignmentDate,
            gatxn.genericdate3 AS TxnAssignmentDate,
            r.genericdate3 AS Leadersocdate,
            gatxn.Genericdate5 AS TxnLeadersocdate,
            r.genericdate4 AS StartTransactionDate,
            gatxn.genericdate7 AS TxnStartTransactionDate
        FROM
            Sh_Query_Result r 
        INNER JOIN
            (
                SELECT   /* ORIGSQL: (Select Ruleelementownerseq, Genericattribute1, effectivestartdate, effectiveenddate, MAX(Genericdate3) Transferdate From Cs_Position Pos Where tenantid='AIAS' and Removedate = to_date('01/01/2200', '(...) */
                    Ruleelementownerseq,
                    Genericattribute1,
                    effectivestartdate,
                    effectiveenddate,
                    MAX(Genericdate3) AS Transferdate
                FROM
                    Cs_Position Pos
                WHERE
                    tenantid = 'AIAS'
                    AND Removedate = sapdbmtk.sp_f_dbmtk_format_string_to_datetime('01/01/2200', 'dd/mm/yyyy')  /* ORIGSQL: to_date('01/01/2200', 'dd/mm/yyyy') */
                GROUP BY
                    Ruleelementownerseq,
                    Genericattribute1,
                    effectivestartdate,
                    effectiveenddate
            ) AS p
            ON p.ruleelementownerseq = r.genericSequence2
            AND p.Effectivestartdate <= r.Genericdate5
            AND p.effectiveenddate > r.genericDate5
        INNER JOIN
            Cs_gaSalestransaction gatxn
            ON gatxn.salestransactionseq = r.genericSequence1
            AND gatxn.pagenumber = 0
            /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.DM_TBL_AGENT_MOVE' not found */
        LEFT OUTER JOIN
            (
                /* ORIGSQL: Select / *+use_concat* / */
                SELECT   /* ORIGSQL: (Select Agent_code, New_Agency_code, MAX(Effective_Date) Oldtransferdate from dm_tbl_agent_move where Move_Type In ('31', '30') Or (Move_Type = '20' And Agency_Code != New_Agency_Code) group by agent_(...) */
                    Agent_code,
                    New_Agency_code,
                    MAX(Effective_Date) AS Oldtransferdate
                FROM
                    dm_tbl_agent_move
                WHERE
                    Move_Type IN ('31', '30')
                    OR (Move_Type = '20'
                    AND Agency_Code != New_Agency_Code)
                GROUP BY
                    agent_code, new_agency_code
            ) AS m
            ON m.agent_code = r.genericAttribute6
            AND m.new_agency_code = r.genericAttribute7
        WHERE
            r.periodseq = :In_Periodseq --2533274790398913
            AND component = :v_componentValue --v_component
            AND gatxn.tenantid = 'AIAS'
    
    )
    /* ORIGSQL: select / *+ * / */

    /* ORIGSQL: select salestransactionseq, transferdate, contractdate, welcomepackage, assignmentdate, leadersocdate, starttransactiondate bulk collect into l_txnseq, l_transferdt, l_contractdt, l_welcomepk, l_assig(...) */
    SELECT
        salestransactionseq,
        transferdate,
        contractdate,
        welcomepackage,
        assignmentdate,
        leadersocdate,
        starttransactiondate
        /* ORIGSQL: bulk collect into l_txnseq, l_transferdt, l_contractdt, l_welcomepk, l_assigndt, l_ldrsocdt, l_starttxndt */
    FROM
        transferset t
    WHERE
        (IFNULL(TxnContractdate, sapdbmtk.sp_f_dbmtk_format_string_to_datetime('01/01/2200', 'dd/mm/yyyy')) !=  /* ORIGSQL: nvl(TxnContractdate, to_date('01/01/2200', 'dd/mm/yyyy')) */
            IFNULL(Contractdate, sapdbmtk.sp_f_dbmtk_format_string_to_datetime('01/01/2200', 'dd/mm/yyyy'))  /* ORIGSQL: nvl(Contractdate, to_date('01/01/2200', 'dd/mm/yyyy')) */
            OR IFNULL(TxnWelcomepackage, 0) != IFNULL(Welcomepackage, 0)  /* ORIGSQL: nvl(Welcomepackage, 0) */
                                                                          /* ORIGSQL: nvl(TxnWelcomepackage, 0) */
            OR IFNULL(TxnTransferdate, sapdbmtk.sp_f_dbmtk_format_string_to_datetime('01/01/2200', 'dd/mm/yyyy')) !=  /* ORIGSQL: nvl(TxnTransferdate, to_date('01/01/2200', 'dd/mm/yyyy')) */
            IFNULL(TransferDate, sapdbmtk.sp_f_dbmtk_format_string_to_datetime('01/01/2200', 'dd/mm/yyyy'))  /* ORIGSQL: nvl(TransferDate, to_date('01/01/2200', 'dd/mm/yyyy')) */
            OR IFNULL(TxnAssignmentDate, sapdbmtk.sp_f_dbmtk_format_string_to_datetime('01/01/2200', 'dd/mm/yyyy')) !=  /* ORIGSQL: nvl(TxnAssignmentDate, to_date('01/01/2200', 'dd/mm/yyyy')) */
            IFNULL(AssignmentDate, sapdbmtk.sp_f_dbmtk_format_string_to_datetime('01/01/2200', 'dd/mm/yyyy'))  /* ORIGSQL: nvl(AssignmentDate, to_date('01/01/2200', 'dd/mm/yyyy')) */
            OR IFNULL(TxnLeadersocdate, sapdbmtk.sp_f_dbmtk_format_string_to_datetime('01/01/2200', 'dd/mm/yyyy')) !=  /* ORIGSQL: nvl(TxnLeadersocdate, to_date('01/01/2200', 'dd/mm/yyyy')) */
            IFNULL(Leadersocdate, sapdbmtk.sp_f_dbmtk_format_string_to_datetime('01/01/2200', 'dd/mm/yyyy'))  /* ORIGSQL: nvl(Leadersocdate, to_date('01/01/2200', 'dd/mm/yyyy')) */
            OR IFNULL(TxnStartTransactionDate,  /* ORIGSQL: nvl(TxnStartTransactionDate, to_date('01/01/2200', 'dd/mm/yyyy')) */
                sapdbmtk.sp_f_dbmtk_format_string_to_datetime('01/01/2200', 'dd/mm/yyyy')) !=
            IFNULL(StartTransactionDate, sapdbmtk.sp_f_dbmtk_format_string_to_datetime('01/01/2200', 'dd/mm/yyyy')));  /* ORIGSQL: nvl(StartTransactionDate, to_date('01/01/2200', 'dd/mm/yyyy')) */

    l_txnseq = SELECT *, TO_INT(ROW_NUMBER() OVER ()) AS dbmtk_ix_col FROM :dbmtk_bulk_tabvar_1201;  /* ORIGSQL: SELECT-INTO..BULK COLLECT INTO..l_txnseq */
    t_dbmtk_ix_col = UNNEST(ARRAY_AGG(:l_txnseq.dbmtk_ix_col)) AS (dbmtk_ix_col); CALL sapdbmtk.sp_dbmtk_ctv_pushix('l_txnseq',:DBMTK_CTV_PROCID,:t_dbmtk_ix_col);

    l_transferdt = SELECT *, TO_INT(ROW_NUMBER() OVER ()) AS dbmtk_ix_col FROM :dbmtk_bulk_tabvar_1201;  /* ORIGSQL: SELECT-INTO..BULK COLLECT INTO..l_transferdt */
    t_dbmtk_ix_col = UNNEST(ARRAY_AGG(:l_transferdt.dbmtk_ix_col)) AS (dbmtk_ix_col); CALL sapdbmtk.sp_dbmtk_ctv_pushix('l_transferdt',:DBMTK_CTV_PROCID,:t_dbmtk_ix_col);

    l_contractdt = SELECT *, TO_INT(ROW_NUMBER() OVER ()) AS dbmtk_ix_col FROM :dbmtk_bulk_tabvar_1201;  /* ORIGSQL: SELECT-INTO..BULK COLLECT INTO..l_contractdt */
    t_dbmtk_ix_col = UNNEST(ARRAY_AGG(:l_contractdt.dbmtk_ix_col)) AS (dbmtk_ix_col); CALL sapdbmtk.sp_dbmtk_ctv_pushix('l_contractdt',:DBMTK_CTV_PROCID,:t_dbmtk_ix_col);

    l_welcomepk = SELECT *, TO_INT(ROW_NUMBER() OVER ()) AS dbmtk_ix_col FROM :dbmtk_bulk_tabvar_1201;  /* ORIGSQL: SELECT-INTO..BULK COLLECT INTO..l_welcomepk */
    t_dbmtk_ix_col = UNNEST(ARRAY_AGG(:l_welcomepk.dbmtk_ix_col)) AS (dbmtk_ix_col); CALL sapdbmtk.sp_dbmtk_ctv_pushix('l_welcomepk',:DBMTK_CTV_PROCID,:t_dbmtk_ix_col);

    l_assigndt = SELECT *, TO_INT(ROW_NUMBER() OVER ()) AS dbmtk_ix_col FROM :dbmtk_bulk_tabvar_1201;  /* ORIGSQL: SELECT-INTO..BULK COLLECT INTO..l_assigndt */
    t_dbmtk_ix_col = UNNEST(ARRAY_AGG(:l_assigndt.dbmtk_ix_col)) AS (dbmtk_ix_col); CALL sapdbmtk.sp_dbmtk_ctv_pushix('l_assigndt',:DBMTK_CTV_PROCID,:t_dbmtk_ix_col);

    l_ldrsocdt = SELECT *, TO_INT(ROW_NUMBER() OVER ()) AS dbmtk_ix_col FROM :dbmtk_bulk_tabvar_1201;  /* ORIGSQL: SELECT-INTO..BULK COLLECT INTO..l_ldrsocdt */
    t_dbmtk_ix_col = UNNEST(ARRAY_AGG(:l_ldrsocdt.dbmtk_ix_col)) AS (dbmtk_ix_col); CALL sapdbmtk.sp_dbmtk_ctv_pushix('l_ldrsocdt',:DBMTK_CTV_PROCID,:t_dbmtk_ix_col);

    l_starttxndt = SELECT *, TO_INT(ROW_NUMBER() OVER ()) AS dbmtk_ix_col FROM :dbmtk_bulk_tabvar_1201;  /* ORIGSQL: SELECT-INTO..BULK COLLECT INTO..l_starttxndt */
    t_dbmtk_ix_col = UNNEST(ARRAY_AGG(:l_starttxndt.dbmtk_ix_col)) AS (dbmtk_ix_col); CALL sapdbmtk.sp_dbmtk_ctv_pushix('l_starttxndt',:DBMTK_CTV_PROCID,:t_dbmtk_ix_col);

    /* ORIGSQL: FORALL indx IN 1..l_txnseq.COUNT */

    FOR indx IN 1 .. sapdbmtk.sp_f_dbmtk_ctv_count('l_txnseq',:DBMTK_CTV_PROCID)  /* ORIGSQL: l_txnseq.COUNT */
    DO   
        /* ORIGSQL: update cs_gasalestransaction SET genericdate2 = l_transferdt(indx), genericdate1 = l_contractdt(indx), genericboolean1 = l_welcomepk(indx), genericdate3 = l_assigndt(indx), genericdate5 = l_ldrsocdt(i(...) */
        DBMTK_TMPVAR_TIMESTAMP_1 = :l_assigndt.column_value[:indx];
        DBMTK_TMPVAR_TIMESTAMP_2 = :l_contractdt.column_value[:indx];
        DBMTK_TMPVAR_TIMESTAMP_3 = :l_ldrsocdt.column_value[:indx];
        DBMTK_TMPVAR_TIMESTAMP_4 = :l_starttxndt.column_value[:indx];
        DBMTK_TMPVAR_TIMESTAMP_5 = :l_transferdt.column_value[:indx];
        DBMTK_TMPVAR_INT_6 = :l_txnseq.column_value[:indx];
        DBMTK_TMPVAR_INT_7 = :l_welcomepk.column_value[:indx];
        UPDATE cs_gasalestransaction
            SET
            /* ORIGSQL: genericdate2 = */
            genericdate2 = :DBMTK_TMPVAR_TIMESTAMP_5 /* --to_date('01/01/2200','dd/mm/yyyy'), */,  /* ORIGSQL: l_transferdt(indx) */
            /* ORIGSQL: genericdate1 = */
            genericdate1 = :DBMTK_TMPVAR_TIMESTAMP_2,  /* ORIGSQL: l_contractdt(indx) */
            /* ORIGSQL: genericboolean1 = */
            genericboolean1 = :DBMTK_TMPVAR_INT_7,  /* ORIGSQL: l_welcomepk(indx) */
            /* ORIGSQL: genericdate3 = */
            genericdate3 = :DBMTK_TMPVAR_TIMESTAMP_1,  /* ORIGSQL: l_assigndt(indx) */
            /* ORIGSQL: genericdate5 = */
            genericdate5 = :DBMTK_TMPVAR_TIMESTAMP_3,  /* ORIGSQL: l_ldrsocdt(indx) */
            /* ORIGSQL: genericdate7 = */
            genericdate7 = :DBMTK_TMPVAR_TIMESTAMP_4  /* ORIGSQL: l_starttxndt(indx) */
        FROM
            cs_gasalestransaction
        WHERE
            salestransactionseq = :DBMTK_TMPVAR_INT_6  /* ORIGSQL: l_txnseq(indx) */
            AND pagenumber = 0
            AND tenantid = 'AIAS';
    END FOR;  /* ORIGSQL: END LOOP; */

    /* Mark -20150820 - end */

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('End  3') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('End  3');

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: EXCEPTION When Others Then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__Sp_Update_Txn') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating function 'DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating function ''DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME''...' );
go

/* ORIGSQL: FUNCTION GETSUBPARTITIONNAME(vObjName varchar2,inPeriodSeq number,inPUSeq number) return varchar2 AS vString varchar2(30); */
CREATE OR REPLACE FUNCTION DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME
(
    IN vObjName VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                /* ORIGSQL: vObjName varchar2 */
    IN inPeriodSeq DECIMAL(38,10),   /* ORIGSQL: inPeriodSeq number */
    IN inPUSeq DECIMAL(38,10)   /* ORIGSQL: inPUSeq number */
)
RETURNS dbmtk_function_result VARCHAR(255)   /* ORIGSQL: return varchar2 */
/* RESOLVE: Manual edits required: VARCHAR2 function value(no length): user-configured length=255; adjust as needed */
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
AS
BEGIN
    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE vString VARCHAR(30);  /* ORIGSQL: vString varchar2(30); */
    DECLARE vStr VARCHAR(500);  /* ORIGSQL: vStr varchar(500); */

    --vstr := 'select (SELECT subobject_name FROM all_objects WHERE data_object_id = dbms_rowid.rowid_object(t.ROWID)) from dual where  rownum=1';
    --vStr := 'SELECT /*+ NOPARALLEL */ (SELECT subobject_name FROM all_objects WHERE data_object_id = dbms_rowid.rowid_object(t.ROWID)) X '
    --|| ' from ' || vObjName|| ' t where PERIODSEQ= '||inPeriodSeq||' and processingunitseq='|| inPUSeq||' and  rownum = 1';
    -- dbms_output.put_line('vstr '||  vStr);
    --execute immediate vStr into vString ;
    --dbms_output.put_line('Rerutning partition ' ||  vString || ' '||SQL%ROWCOUNT);

    --SELECT /*+ NOPARALLEL */ (SELECT subobject_name FROM all_objects WHERE data_object_id = dbms_rowid.rowid_object(t.ROWID)) X
    --into vString
    --   from CS_CREDIT t where PERIODSEQ= inPeriodSeq and processingunitseq=inPUSeq and  rownum = 1;
    SELECT
        MAX(x.subpartition_name)   /* RESOLVE: Standard Package call(not converted): 'utl_Raw.cast_to_number' not supported, manual conversion required; use custom solutions */
                                   /* RESOLVE: Standard Package call(not converted): 'utl_Raw.cast_to_number' not supported, manual conversion required; use custom solutions */
    INTO
        vString
    FROM
        ALL_SUBPART_COL_STATISTICS x  /* RESOLVE: Catalog reference(not converted): Convert 'ALL_SUBPART_COL_STATISTICS' Oracle catalog reference manually to HANA equivalent */
    INNER JOIN
        (
            SELECT   /* ORIGSQL: (select * from all_part_Col_statistics where table_name=vObjName and column_name = 'PROCESSINGUNITSEQ' and utl_Raw.cast_to_number (low_Value) = inPUSeq) */
                *
            FROM
                ALL_PART_COL_STATISTICS  /* RESOLVE: Catalog reference(not converted): Convert 'ALL_PART_COL_STATISTICS' Oracle catalog reference manually to HANA equivalent */
            WHERE
                table_name = :vObjName
                AND column_name = 'PROCESSINGUNITSEQ'
                AND utl_Raw.cast_to_number
                (low_Value)

                = :inPUSeq
        ) AS y
        ON y.table_name = x.table_name
    INNER JOIN
        (
            SELECT   /* ORIGSQL: (Select * from all_tab_subpartitions) */
                *
            FROM
                SYS.TABLE_PARTITIONS  /* RESOLVE: Catalog reference(partly converted): Oracle catalog 'ALL_TAB_SUBPARTITIONS': verify conversion */
                                      /* ORIGSQL: all_tab_subpartitions (Oracle catalog) */
        ) AS z
        ON z.table_name = x.table_name
        AND z.subpartition_name = x.subpartition_name
        AND z.partition_name = y.partition_name
    WHERE
        x.table_name = :vObjName
        AND x.column_name = 'PERIODSEQ'
        AND utl_Raw.cast_to_number
        (x.high_Value)

        = :inPeriodSeq;

    dbmtk_function_result = :vString;
    RETURN;

    /*exception
    when others then
     Log('ERROR'||SQLERRM);
     return null;*/
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('function', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__GETSUBPARTITIONNAME') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_NADOR' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_NADOR''...' );
go

/* ORIGSQL: PROCEDURE SP_UPDATE_NADOR(i_periodSeq in int) is v_periodSeq int := i_periodSeq; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_NADOR
(
    IN i_periodSeq BIGINT     /* ORIGSQL: i_periodSeq IN int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN SEQUENTIAL EXECUTION
    DECLARE DBMTK_TMPVAR_STRING_1 VARCHAR(5000); /*sapdbmtk-generated help variable*/
    DECLARE DBMTK_CTV_PROCID INT := sapdbmtk.sp_f_dbmtk_ctv_procid(); /*sapdbmtk-generated help variable*/
    DECLARE gv_error VARCHAR(1000); /* package/session variable */
    DECLARE Gv_Periodname VARCHAR(100); /* package/session variable */
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */
    DECLARE gv_prePeriodSeq1 BIGINT; /* package/session variable */
    DECLARE gv_prePeriodSeq2 BIGINT; /* package/session variable */
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */

    DECLARE v_periodSeq BIGINT = :i_periodSeq;  /* ORIGSQL: v_periodSeq int := i_periodSeq; */
    DECLARE v_rec BIGINT = 0;  /* ORIGSQL: v_rec int := 0; */
    DECLARE v_rtn BIGINT = 0;  /* ORIGSQL: v_rtn int := 0; */
    DECLARE V_Credittypeseq BIGINT;  /* ORIGSQL: V_Credittypeseq Int; */

    --for revamp
    --begin
    DECLARE V_Credittypeseq_w BIGINT;  /* ORIGSQL: V_Credittypeseq_w Int; */
    DECLARE V_Credittypeseq_w_dup BIGINT;  /* ORIGSQL: V_Credittypeseq_w_dup Int; */
    DECLARE V_Credittypeseq_wc_dup BIGINT;  /* ORIGSQL: V_Credittypeseq_wc_dup Int; */

    --end

    DECLARE v_componentValue VARCHAR(30) = 'NADOR_VALIDATION';  /* ORIGSQL: v_componentValue varchar2(30) := 'NADOR_VALIDATION'; */
    DECLARE vSQL VARCHAR(4000);  /* ORIGSQL: vSQL varchar2(4000); */

    DECLARE vParName DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_NADOR__PartName;  /* ORIGSQL: vParName PartName; */

    /* ORIGSQL: for i in 1..3 loop */
    DECLARE i INT;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            /* ORIGSQL: rollback; */
            ROLLBACK;

            gv_error = 'Error [SP_UPDATE_NADOR]: ' || ::SQL_ERROR_MESSAGE || ' - ' ||  /* ORIGSQL: sqlerrm */

            /* RESOLVE: Standard Package call(not converted): 'dbms_utility.format_error_backtrace' not supported, manual conversion required */
            dbms_utility.format_error_backtrace

            || ' - on Period: ' ||
            IFNULL(:Gv_Periodname,'');
            /* Saving modified package/session variable 'gv_error': */ 
            SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR' = :gv_error;

            /* ORIGSQL: raise_application_error(-20000, gv_error) */
            -- sapdbmtk: mapped error code -20000 => 10000: (ABS(-20000)%10000)+10000
            SIGNAL SQL_ERROR_CODE 10000 SET MESSAGE_TEXT = :gv_error;

            /* ORIGSQL: commit; */
            COMMIT;

            /* sapdbmtk: Closing RETURN in exception handler commented out, not supported in HANA */
            --RETURN;
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR') INTO gv_error FROM SYS.DUMMY ;
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODNAME') INTO Gv_Periodname FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PREPERIODSEQ1') AS BIGINT) INTO gv_prePeriodSeq1 FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PREPERIODSEQ2') AS BIGINT) INTO gv_prePeriodSeq2 FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
        /* end of package/session variables */

        /*---TYPE definition moved to  ddl_script_types ---
        type PartName IS VARRAY(10) OF VARCHAR2(255);
        ---end of TYPE definition commented out---*/

        v_rtn = DBMTK_USER_NAME.PK_STAGE_HOOK__comGetQuarterMonth(:i_periodSeq);  /* ORIGSQL: comGetQuarterMonth(i_periodSeq) */

        IF :v_rtn < 1
        THEN 
            RETURN;
        END IF;

        --gv_prePeriodSeq2 :=  2533274790395933;
        --gv_prePeriodSeq2 := 2533274790395934;
        --2533274790395935

        ----clean up temp tables

        /*delete from sh_query_result
        where component='NADOR_VALIDATION';
        COMMIT;*/

        /* ORIGSQL: comInitialPartition('NV', v_componentValue, i_periodSeq) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__ComInitialpartition('NV', :v_componentValue, :i_periodSeq);

        /* ORIGSQL: Log('Start 4') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Start 4');

        /* ORIGSQL: execute immediate 'truncate table sh_sequence'; */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.SH_SEQUENCE' not found */

        /* ORIGSQL: truncate table sh_sequence ; */
        EXECUTE IMMEDIATE 'TRUNCATE TABLE sh_sequence';

        /* ORIGSQL: Log('End  4') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('End  4');

        V_Credittypeseq = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('NADOR');  /* ORIGSQL: Comgetcredittypeseq('NADOR') */

        --for revamp
        --begin
        V_Credittypeseq_w = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('NADOR_W');  /* ORIGSQL: Comgetcredittypeseq('NADOR_W') */

        V_Credittypeseq_w_dup = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('NADOR_W_DUPLICATE');  /* ORIGSQL: Comgetcredittypeseq('NADOR_W_DUPLICATE') */

        V_Credittypeseq_wc_dup = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('NADOR_WC_DUPLICATE');  /* ORIGSQL: Comgetcredittypeseq('NADOR_WC_DUPLICATE') */

        --end

        ---enable parallel server option
        --Maintenance.Enablepdml;

        /* ORIGSQL: Log('Start  5') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Start  5');

        --comDebugger('SQL Performance','Stagehook[SP_UPDATE_NADOR]-SQL1 START:'||SYSDATE);

        /* ORIGSQL: vParName := partname(' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '); */
        :vParName.DELETE();
        vParName.column_value[1] = ' ';    vParName.dbmtk_ix_col[1] = 1;
        vParName.column_value[2] = ' ';    vParName.dbmtk_ix_col[2] = 2;
        vParName.column_value[3] = ' ';    vParName.dbmtk_ix_col[3] = 3;
        vParName.column_value[4] = ' ';    vParName.dbmtk_ix_col[4] = 4;
        vParName.column_value[5] = ' ';    vParName.dbmtk_ix_col[5] = 5;
        vParName.column_value[6] = ' ';    vParName.dbmtk_ix_col[6] = 6;
        vParName.column_value[7] = ' ';    vParName.dbmtk_ix_col[7] = 7;
        vParName.column_value[8] = ' ';    vParName.dbmtk_ix_col[8] = 8;
        vParName.column_value[9] = ' ';    vParName.dbmtk_ix_col[9] = 9;
        vParName.column_value[10] = ' ';    vParName.dbmtk_ix_col[10] = 10;
        t_dbmtk_ix_col = UNNEST(ARRAY_AGG(:vParName.dbmtk_ix_col)) AS (dbmtk_ix_col); CALL sapdbmtk.sp_dbmtk_ctv_pushix('vParName',:DBMTK_CTV_PROCID,:t_dbmtk_ix_col);

        /* ORIGSQL: vParName(1) := DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME('CS_CREDIT', v_periodSeq, gv_ProcessingUnitSeq) ; GETSUBPARTITIONNAME('CS_CREDIT',v_periodSeq,gv_ProcessingUnitSeq) */
        vParName = SELECT * FROM DBMTK_USER_NAME.sp_f_dbmtk_ctv_assign_pk_stage_hook__sp_update_nador__partname('vParName',:vParName,:DBMTK_CTV_PROCID,1,'column_value',column_value => DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME('CS_CREDIT', :v_periodSeq, :Gv_Processingunitseq));  
        /* ORIGSQL: Log('   par name for ' || v_periodSeq || ' is ' || vParName(1)) */
        DBMTK_TMPVAR_STRING_1 = '   par name for '|| IFNULL(TO_VARCHAR(:v_periodSeq),'') || ' is '|| IFNULL(:vParName.column_value[1],'');  
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log(:DBMTK_TMPVAR_STRING_1);

        /* ORIGSQL: vParName(2) := DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME('CS_CREDIT', gv_prePeriodSeq1, gv_ProcessingUnitSeq) ; GETSUBPARTITIONNAME('CS_CREDIT',gv_prePeriodSeq1,gv_ProcessingUnitSeq) */
        vParName = SELECT * FROM DBMTK_USER_NAME.sp_f_dbmtk_ctv_assign_pk_stage_hook__sp_update_nador__partname('vParName',:vParName,:DBMTK_CTV_PROCID,2,'column_value',column_value => DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME('CS_CREDIT', :gv_prePeriodSeq1, :Gv_Processingunitseq));  
        /* ORIGSQL: Log('   par name for ' || gv_prePeriodSeq1 || ' is ' || vParName(2)) */
        DBMTK_TMPVAR_STRING_1 = '   par name for '|| IFNULL(TO_VARCHAR(:gv_prePeriodSeq1),'') || ' is '|| IFNULL(:vParName.column_value[2],'');  
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log(:DBMTK_TMPVAR_STRING_1);

        /* ORIGSQL: vParName(3) := DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME('CS_CREDIT', gv_prePeriodSeq2, gv_ProcessingUnitSeq) ; GETSUBPARTITIONNAME('CS_CREDIT',gv_prePeriodSeq2,gv_ProcessingUnitSeq) */
        vParName = SELECT * FROM DBMTK_USER_NAME.sp_f_dbmtk_ctv_assign_pk_stage_hook__sp_update_nador__partname('vParName',:vParName,:DBMTK_CTV_PROCID,3,'column_value',column_value => DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME('CS_CREDIT', :gv_prePeriodSeq2, :Gv_Processingunitseq));  
        /* ORIGSQL: Log('   par name for ' || gv_prePeriodSeq2 || ' is ' || vParName(3)) */
        DBMTK_TMPVAR_STRING_1 = '   par name for '|| IFNULL(TO_VARCHAR(:gv_prePeriodSeq2),'') || ' is '|| IFNULL(:vParName.column_value[3],'');  
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log(:DBMTK_TMPVAR_STRING_1);

        FOR i IN 1 .. 3
        DO
            /* ORIGSQL: Log('Start  5 Loop ' || i || ' vParName ' || vParName(i)) */
            DBMTK_TMPVAR_STRING_1 = 'Start  5 Loop '|| IFNULL(TO_VARCHAR(:i),'') || ' vParName '|| IFNULL(:vParName.column_value[:i],'');  
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log(:DBMTK_TMPVAR_STRING_1);

            vSQL = 'insert /*+ APPEND */ into  sh_query_result(Component,Objoutputname,Payeeseq,Positionseq,Periodseq,Value,genericSequence1,genericSequence2,genericnumber1,Genericnumber2,Genericsequence3,Genericsequence4,Genericboolean1,Genericnumber3,Genericattribute1,Genericboolean3)';

            vSQL = IFNULL(:vSQL,'') ||
            'select /*+ INDEX(cc CS_CREDIT_CTSEQ) leading(cc) parallel(8) */ ''' ||
            IFNULL(:v_componentValue,'') ||
            ''',''PM_NADOR_CM'',cc.payeeseq, cc.positionseq,' ||
            IFNULL(TO_VARCHAR(:v_periodSeq),'') ||
            ', sum(cc.value), cp.ruleelementownerseq,cp.payeeseq, ';

            --vSQL := vSQL || '   cc.genericnumber4 ,count(*) as recCnt, '; version 7 comment

            vSQL = IFNULL(:vSQL,'') || '   decode(cc.genericnumber6, 9999,cc.genericnumber4, cc.genericnumber6) ,count(*) as recCnt, ';

            --for revamp begin
            vSQL = IFNULL(:vSQL,'') || '  cc.creditTypeSeq, cc.periodSeq,';

            --end revamp

            vSQL = IFNULL(:vSQL,'') ||
            '0 As Validflag, Max(T.Thresholdamt),Cc.Genericattribute12, decode(cc.genericnumber6, 9999,0,1) ';

            vSQL = IFNULL(:vSQL,'') || 'From Cs_Credit ' || '  subpartition  (' || IFNULL(:vParName.column_value[:i],'') || ')' || ' cc, Cs_Position Cp,  Sh_Tmp_Threshold T ';  /* ORIGSQL: vParName(i) */

            --for revamp begin
            vSQL = IFNULL(:vSQL,'') || 'Where cp.tenantid=''AIAS'' and cc.creditTypeSeq in (' || IFNULL(TO_VARCHAR(:V_Credittypeseq),'') || ',' ||
                IFNULL(TO_VARCHAR(:V_Credittypeseq_w),'') || ',' || IFNULL(TO_VARCHAR(:V_Credittypeseq_w_dup),'') || ',' ||
                IFNULL(TO_VARCHAR(:V_Credittypeseq_wc_dup),'') || ')';

            --end revamp

            vSQL = IFNULL(:vSQL,'') || ' and ''SGT''||cc.genericAttribute12=cp.name ';

            vSQL = IFNULL(:vSQL,'') || ' and cp.removeDate=:cdt_EndOfTime';

            vSQL = IFNULL(:vSQL,'') || ' AND cp.effectiveStartDate<=cc.compensationDate ';

            vSQL = IFNULL(:vSQL,'') || ' and cp.effectiveEndDate>cc.compensationDate ';

            --vSQL := vSQL || ' and t.beginQuarter(+) <= cc.genericnumber4 '; version 7 comment
            --vSQL := vSQL || ' and t.endQuarter(+) >=  cc.genericnumber4 ';  version 7 comment

            vSQL = IFNULL(:vSQL,'') || ' and t.beginQuarter(+) <= decode(cc.genericnumber6, 9999,cc.genericnumber4, cc.genericnumber6) ';

            vSQL = IFNULL(:vSQL,'') || ' and t.endQuarter(+) >=  decode(cc.genericnumber6, 9999,cc.genericnumber4, cc.genericnumber6) ';

            vSQL = IFNULL(:vSQL,'') ||
            '  group by cc.payeeseq, cc.positionseq, cp.ruleElementOwnerSeq ,cp.payeeseq, decode(cc.genericnumber6, 9999,cc.genericnumber4, cc.genericnumber6),cc.creditTypeSeq,cc.periodSeq,cc.genericattribute12, decode(cc.genericnumber6, 9999,0,1) ';

            /* ORIGSQL: dbms_output.put_line('Running ' || vSQL); */
            CALL sapdbmtk.sp_dbmtk_buffered_output_writeln('Running ' || IFNULL(:vSQL,''));

            /* ORIGSQL: Log('Running ' || vSQL) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Running '|| IFNULL(:vSQL,''));
            BEGIN 
                DECLARE EXIT HANDLER FOR SQLEXCEPTION
                    /* ORIGSQL: when others then */
                    BEGIN
                        /* ORIGSQL: Log('Error ' || sqlerrm) */
                        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Error '|| ::SQL_ERROR_MESSAGE 
                        );  /* ORIGSQL: sqlerrm */
                    END;



                /* RESOLVE: Dynamically generated SQL: Dynamically generated SQL, as executed by Execute-Immediate, convert manually */
                /* ORIGSQL: execute immediate vSQL using cdt_EndOfTime; */
                CALL sapdbmtk.sp_dbmtk_prepare_execute_sql(:vSQL, :DBMTK_TMPVAR_STRING_1);
                EXECUTE IMMEDIATE :DBMTK_TMPVAR_STRING_1 USING :cdt_EndOfTime;

                /* ORIGSQL: exception when others then */
            END;

            /* ORIGSQL: Log('End  5') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('End  5');

            /* ORIGSQL: commit; */
            COMMIT;
        END FOR;  /* ORIGSQL: end loop; */

        --version 7 update old agent position seqno for FA code   
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_PAYEE' not found */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_GAPARTICIPANT' not found */

        /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
        /* ORIGSQL: Merge into sh_query_result R using (WITH tmp_position_info AS (SELECT cp.name AS code_no, ruleelementownerseq, cd.enddate FROM cs_position cp, cs_period cd where cp.tenantid='AIAS' and cp.tenantid=cd.(...) */
        MERGE INTO sh_query_result AS R
            USING (
                WITH 
                tmp_position_info    
                AS (
                    SELECT   /* ORIGSQL: (select cp.name as code_no,ruleelementownerseq,cd.enddate from cs_position cp,cs_period cd where cp.tenantid='AIAS' and cp.tenantid=cd.tenantid and cp.removeDate=cdt_endoftime and cd.removeDate=cdt_en(...) */
                        cp.name AS code_no,
                        ruleelementownerseq,
                        cd.enddate
                    FROM
                        cs_position cp,
                        cs_period cd
                    WHERE
                        cp.tenantid = 'AIAS'
                        AND cp.tenantid = cd.tenantid
                        AND cp.removeDate = :cdt_EndOfTime
                        AND cd.removeDate = :cdt_EndOfTime
                        AND cd.periodseq = :v_periodSeq
                        AND cp.effectiveStartDate <= cd.enddate-1
                        --version 8
                        --and cp.effectiveEndDate>=cd.enddate-1
                        AND cp.effectiveEndDate > cd.enddate-1
                
                )   
                SELECT   /* ORIGSQL: select ce.payeeid as com_agt, cg.genericattribute5 as old_agt, t1.ruleelementownerseq as old_agt_positonNo from CS_PAYEE ce, Cs_Gaparticipant cg, tmp_position_info t1 where ce.payeeseq=cg.payeeseq and(...) */
                    -- tmp_position_info
                    ce.payeeid AS com_agt,
                    cg.genericattribute5 AS old_agt,
                    t1.ruleelementownerseq AS old_agt_positonNo
                FROM
                    CS_PAYEE ce,
                    Cs_Gaparticipant cg,
                    tmp_position_info t1
                WHERE
                    ce.payeeseq = cg.payeeseq
                    AND ce.islast = 1
                    AND cg.pagenumber = 0
                    AND cg.effectivestartdate >= ce.effectivestartdate
                    AND cg.effectiveenddate <= ce.effectiveenddate
                    AND ce.removedate = :cdt_EndOfTime
                    AND cg.removedate = :cdt_EndOfTime
                    AND cg.genericattribute5 IS NOT NULL
                    AND ce.effectivestartdate <= t1.enddate-1
                    --version 8
                    --and ce.effectiveenddate>=t1.enddate-1
                    AND ce.effectiveenddate > t1.enddate-1
                    AND t1.code_no = 'SGT'||IFNULL(cg.genericattribute5,'')
                ) S
                ON ('SGT'||IFNULL(R.Genericattribute1,'') = S.com_agt
                    AND R.Genericboolean3 = 1
                AND R.Periodseq = :v_periodSeq)
        WHEN MATCHED THEN
            UPDATE SET R.genericSequence5 = S.old_agt_positonNo;

        /* ORIGSQL: log('5a '||SQL%ROWCOUNT) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('5a '||::ROWCOUNT);  

        /* ORIGSQL: commit; */
        COMMIT;

        --version 7 update old agency position seqno for FA code     
        /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
        /* ORIGSQL: Merge into sh_query_result R using (WITH tmp_position_info AS (SELECT cp.name, GENERICATTRIBUTE2, ruleelementownerseq, cd.enddate FROM cs_position cp, cs_period cd where cp.tenantid='AIAS' and cp.tena(...) */
        MERGE INTO sh_query_result AS R
            USING (
                WITH 
                tmp_position_info   
                AS (
                    SELECT   /* ORIGSQL: (select cp.name,GENERICATTRIBUTE2,ruleelementownerseq,cd.enddate from cs_position cp,cs_period cd where cp.tenantid='AIAS' and cp.tenantid=cd.tenantid and cp.removeDate=cdt_endoftime and cd.removeDate(...) */
                        cp.name,
                        GENERICATTRIBUTE2,
                        ruleelementownerseq,
                        cd.enddate
                    FROM
                        cs_position cp,
                        cs_period cd
                    WHERE
                        cp.tenantid = 'AIAS'
                        AND cp.tenantid = cd.tenantid
                        AND cp.removeDate = :cdt_EndOfTime
                        AND cd.removeDate = :cdt_EndOfTime
                        AND cd.periodseq = :v_periodSeq
                        AND cp.effectiveStartDate <= cd.enddate-1
                        --version 8
                        --and cp.effectiveEndDate>=cd.enddate-1
                        AND cp.effectiveEndDate > cd.enddate-1
                
                )   
                SELECT   /* ORIGSQL: select ce.payeeid as Agy_Leader, t1.ruleelementownerseq as Agy_Positionseq, cg.genericattribute6 as old_agy, t2.ruleelementownerseq as old_agy_positonNo, cg.genericattribute5 as old_agt_code, t2.GENER(...) */
                    -- tmp_position_info
                    ce.payeeid AS Agy_Leader,
                    t1.ruleelementownerseq AS Agy_Positionseq,
                    cg.genericattribute6 AS old_agy,
                    t2.ruleelementownerseq AS old_agy_positonNo
                    /* ---v20 Fix: (NADOR issue) */, cg.genericattribute5 AS old_agt_code,
                    t2.GENERICATTRIBUTE2 AS old_agy_leader_code
                    /* ---v20 Fix: (NADOR issue) End */
                FROM
                    CS_PAYEE ce,
                    Cs_Gaparticipant cg,
                    tmp_position_info t1,
                    tmp_position_info t2
                WHERE
                    ce.payeeseq = cg.payeeseq
                    AND ce.islast = 1
                    AND cg.pagenumber = 0
                    AND cg.effectivestartdate >= ce.effectivestartdate
                    AND cg.effectiveenddate <= ce.effectiveenddate
                    AND ce.removedate = :cdt_EndOfTime
                    AND cg.removedate = :cdt_EndOfTime
                    AND cg.genericattribute5 IS NOT NULL
                    AND cg.genericattribute6 IS NOT NULL
                    AND ce.effectivestartdate <= t1.enddate-1
                    --version 8
                    --and ce.effectiveenddate>=t1.enddate-1
                    AND ce.effectiveenddate > t1.enddate-1
                    AND 'SGT'||IFNULL(t1.GENERICATTRIBUTE2,'') = ce.payeeid
                    AND t2.name = 'SGY'||IFNULL(cg.genericattribute6,'')
                ) S
                ON (R.Positionseq = S.Agy_Positionseq
                    AND R.Genericboolean3 = 1
                AND R.Periodseq = :v_periodSeq)
        WHEN MATCHED THEN
            ---v20 original (NADOR issue)
            ---  update set R.Genericboolean2 = S.old_agy_positonNo;
            ---v20 original (NADOR issue) End

            ---v20 Fix: (NADOR issue)
            UPDATE SET R.Genericboolean2 = S.old_agy_positonNo,
                R.Genericboolean4 = S.old_agt_code, -- Participant EA5
                R.Genericboolean5 = S.old_agy_leader_code;

        -- Position leader code
        ---v20 Fix: (NADOR issue) End

        /* ORIGSQL: log('5b '||SQL%ROWCOUNT) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('5b '||::ROWCOUNT);  

        /* ORIGSQL: commit; */
        COMMIT;

        --version 7 update new agent position seqno for AGY code,if exists     
        /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
        /* ORIGSQL: Merge into sh_query_result R using (WITH tmp_position_info AS (SELECT cp.name AS code_no, ruleelementownerseq, cd.enddate FROM cs_position cp, cs_period cd where cp.tenantid='AIAS' and cp.tenantid=cd.(...) */
        MERGE INTO sh_query_result AS R
            USING (
                WITH 
                tmp_position_info   
                AS (
                    SELECT   /* ORIGSQL: (select cp.name as code_no,ruleelementownerseq,cd.enddate from cs_position cp,cs_period cd where cp.tenantid='AIAS' and cp.tenantid=cd.tenantid and cp.removeDate=cdt_endoftime and cd.removeDate=cdt_en(...) */
                        cp.name AS code_no,
                        ruleelementownerseq,
                        cd.enddate
                    FROM
                        cs_position cp,
                        cs_period cd
                    WHERE
                        cp.tenantid = 'AIAS'
                        AND cp.tenantid = cd.tenantid
                        AND cp.removeDate = :cdt_EndOfTime
                        AND cd.removeDate = :cdt_EndOfTime
                        AND cd.periodseq = :v_periodSeq
                        AND cp.effectiveStartDate <= cd.enddate-1
                        --version 8
                        --and cp.effectiveEndDate>=cd.enddate-1
                        AND cp.effectiveEndDate > cd.enddate-1
                
                )   
                SELECT   /* ORIGSQL: select ce.payeeid as AGY_agt, cg.genericattribute4 as FA_agt, t1.ruleelementownerseq as FA_agt_positonNo from CS_PAYEE ce, Cs_Gaparticipant cg, tmp_position_info t1 where ce.payeeseq=cg.payeeseq and c(...) */
                    -- tmp_position_info
                    ce.payeeid AS AGY_agt,
                    cg.genericattribute4 AS FA_agt,
                    t1.ruleelementownerseq AS FA_agt_positonNo
                FROM
                    CS_PAYEE ce,
                    Cs_Gaparticipant cg,
                    tmp_position_info t1
                WHERE
                    ce.payeeseq = cg.payeeseq
                    AND ce.islast = 1
                    AND cg.pagenumber = 0
                    AND cg.effectivestartdate >= ce.effectivestartdate
                    AND cg.effectiveenddate <= ce.effectiveenddate
                    AND ce.removedate = :cdt_EndOfTime
                    AND cg.removedate = :cdt_EndOfTime
                    AND cg.genericattribute4 IS NOT NULL
                    AND ce.effectivestartdate <= t1.enddate-1
                    --version 8
                    --and ce.effectiveenddate>=t1.enddate-1
                    AND ce.effectiveenddate > t1.enddate-1
                    AND t1.code_no = 'SGT'||IFNULL(cg.genericattribute4,'')
                ) S
                ON ('SGT'||IFNULL(R.Genericattribute1,'') = S.AGY_agt
                    AND R.Genericboolean3 = 0
                AND R.Periodseq = :v_periodSeq)
        WHEN MATCHED THEN
            UPDATE SET R.genericSequence5 = S.FA_agt_positonNo;

        /* ORIGSQL: log('5c '||SQL%ROWCOUNT) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('5c '||::ROWCOUNT);  

        /* ORIGSQL: commit; */
        COMMIT;

        SELECT
            COUNT(*)
        INTO
            v_rec 
        FROM
            (
                /* RESOLVE: Review semantics in source vs. target DBMS: LIMIT/OFFSET without ORDER BY: consistent results not guaranteed */
                SELECT   /* ORIGSQL: (select 1 from sh_query_result Where Component = V_Componentvalue and periodSeq = gv_periodseq LIMIT 1) rownum = 1 */
                    1
                FROM
                    sh_query_result
                WHERE
                    Component = :v_componentValue
                    AND periodSeq = :Gv_Periodseq
                LIMIT 1  /* ORIGSQL: rownum = 1 */
            ) AS dbmtk_corrname_2210;

        IF :v_rec = 0
        THEN
            /* ORIGSQL: comDebugger('nador', '0.no nador credit found') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('nador', '0.no nador credit found'); 

            RETURN;
        END IF;

        /* ORIGSQL: Log('6') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('6');

        --merge into sh_query_result r
        --using (SELECT payeeSeq, positionSeq, sum(cm.value) as aggValue
            --         from cs_measurement cm
            --        where tenantid='AIAS' and cm.name in ('PM_FYP_Life', 'PM_FYP_PA')
            -- And Cm.Periodseq In
            --              (V_Periodseq, Gv_Preperiodseq1, Gv_Preperiodseq2)
            -- and cm.processingunitseq = gv_processingunitseq
        --        group by cm.payeeSeq, cm.positionSeq) cm
        --on (cm.payeeseq = r.genericSequence2
            -- and cm.positionseq = r.genericSequence1
            -- and R.Component = V_Componentvalue
        -- and r.periodSeq = gv_periodSeq)
        --when matched then
        --  update
        --     set r.genericNumber4  = cm.aggValue,
        --         r.genericBoolean1 = case
        --                               when cm.aggValue >= r.genericNumber3 then
        --                                1
        --                               else
        --                                0
        --                             end;
        --
        --commit;
        --Log('6');

        --version 7 update transfer agt old biz FYP 

        /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
        /* ORIGSQL: merge into sh_query_result r using (SELECT payeeSeq, positionSeq, SUM(cm.value) AS aggValue FROM cs_measurement cm where tenantid='AIAS' and cm.name in ('PM_FYP_Life', 'PM_FYP_PA','PM_FYP_TPAH_COMP') (...) */
        MERGE INTO sh_query_result AS r
            /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_MEASUREMENT' not found */
            USING
            (
                SELECT   /* ORIGSQL: (SELECT payeeSeq, positionSeq, SUM(cm.value) as aggValue from cs_measurement cm where tenantid='AIAS' and cm.name in ('PM_FYP_Life', 'PM_FYP_PA','PM_FYP_TPAH_COMP') And Cm.Periodseq In (V_Periodseq, G(...) */
                    payeeSeq,
                    positionSeq,
                    SUM(cm.value) AS aggValue
                FROM
                    cs_measurement cm
                WHERE
                    tenantid = 'AIAS'
                    AND cm.name IN ('PM_FYP_Life', 'PM_FYP_PA','PM_FYP_TPAH_COMP')-- version 24 For MAS Section86 project Nador
                    AND Cm.Periodseq IN
                    (:v_periodSeq, :gv_prePeriodSeq1, :gv_prePeriodSeq2)
                    AND cm.processingunitseq = :Gv_Processingunitseq
                GROUP BY
                    cm.payeeSeq, cm.positionSeq
            ) AS cm
            ON (cm.positionseq = r.genericSequence5 --old agent position seq
                AND R.Component = :v_componentValue
            AND r.periodSeq = :Gv_Periodseq)
        WHEN MATCHED THEN
            UPDATE
                SET r.genericNumber4 = cm.aggValue,
                r.genericBoolean1 =
                CASE
                    WHEN cm.aggValue >= r.genericNumber3
                    THEN 1
                    ELSE 0
                END;

        /* ORIGSQL: commit; */
        COMMIT;

        /* ORIGSQL: Log('6a') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('6a'); 

        /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
        /* ORIGSQL: merge into sh_query_result r using (SELECT payeeSeq, positionSeq, SUM(cm.value) AS aggValue FROM cs_measurement cm where tenantid='AIAS' and cm.name in ('PM_FYP_Life', 'PM_FYP_PA','PM_FYP_TPAH_COMP') (...) */
        MERGE INTO sh_query_result AS r 
            USING
            (
                SELECT   /* ORIGSQL: (SELECT payeeSeq, positionSeq, SUM(cm.value) as aggValue from cs_measurement cm where tenantid='AIAS' and cm.name in ('PM_FYP_Life', 'PM_FYP_PA','PM_FYP_TPAH_COMP') And Cm.Periodseq In (V_Periodseq, G(...) */
                    payeeSeq,
                    positionSeq,
                    SUM(cm.value) AS aggValue
                FROM
                    cs_measurement cm
                WHERE
                    tenantid = 'AIAS'
                    AND cm.name IN ('PM_FYP_Life', 'PM_FYP_PA','PM_FYP_TPAH_COMP')-- version 24 For MAS Section86 project Nador
                    AND Cm.Periodseq IN
                    (:v_periodSeq, :gv_prePeriodSeq1, :gv_prePeriodSeq2)
                    AND cm.processingunitseq = :Gv_Processingunitseq
                GROUP BY
                    cm.payeeSeq, cm.positionSeq
            ) AS cm
            ON (cm.payeeseq = r.genericSequence2
                AND cm.positionseq = r.genericSequence1
                AND R.Component = :v_componentValue
            AND r.periodSeq = :Gv_Periodseq)
        WHEN MATCHED THEN
            UPDATE
                SET r.genericNumber4 = MAP(r.genericNumber4, NULL, 0, r.genericNumber4) +cm.aggValue, --version 7 new+old biz value summary
                /* ORIGSQL: decode(r.genericNumber4,null,0,r.genericNumber4) */
                r.genericBoolean1 =
                CASE
                    WHEN MAP(r.genericNumber4, NULL, 0, r.genericNumber4) +cm.aggValue >= r.genericNumber3  /* ORIGSQL: decode(r.genericNumber4,null,0,r.genericNumber4) */
                    THEN 1
                    ELSE 0
                END;

        /* ORIGSQL: commit; */
        COMMIT;

        /* ORIGSQL: Log('6') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('6');

        /* ORIGSQL: Log('7') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('7');

        /* ORIGSQL: insert / *+ append * / */
        /* ORIGSQL: insert into sh_sequence select DISTINCT cc.creditSeq, 'CREDITSEQ', (CASE WHEN (r.Genericboolean4 = r.Genericboolean5) THEN r.Genericboolean2 ELSE r.Positionseq END), cc.positionseq, r.periodSeq from c(...) */
        INSERT INTO sh_sequence
            /* ORIGSQL: select / *+ leading(r,cc) index(cc AIAS_CREDIT_SH) * / */
            SELECT   /* ORIGSQL: select DISTINCT cc.creditSeq, 'CREDITSEQ', (CASE WHEN (r.Genericboolean4 = r.Genericboolean5) THEN r.Genericboolean2 ELSE r.Positionseq END), cc.positionseq, r.periodSeq from cs_credit cc, sh_query_re(...) */
                DISTINCT
                cc.creditSeq,
                'CREDITSEQ',
                /* --cc.payeeseq, */
                /* -- v20 start */
                /* -- r.Genericboolean2,  --old agency code -- v20 original */
                (
                    CASE
                        WHEN (r.Genericboolean4 = r.Genericboolean5)
                        THEN r.Genericboolean2
                        ELSE r.Positionseq
                    END
                ),
                /* -- v20 end */
                cc.positionseq,
                r.periodSeq
            FROM
                cs_credit cc,
                sh_query_result r
            WHERE
                cc.tenantid = 'AIAS'
                AND cc.payeeseq = r.payeeseq
                AND cc.positionseq = r.positionseq
                AND cc.periodSeq = r.genericSequence4
                --and cc.periodSeq in (v_periodSeq,gv_prePeriodSeq1,gv_prePeriodSeq2) -- the period contain entire quarter
                AND cc.creditTypeSeq = r.genericSequence3
                AND cc.genericattribute12 = r.genericattribute1
                AND R.Component = :v_componentValue
                AND r.periodseq = :Gv_Periodseq
                AND r.genericBoolean1 = 1
                AND cc.processingUnitseq = :Gv_Processingunitseq
                AND cc.origintypeid IN ('calculated', 'imported')
                --and cc.genericnumber4 < 13;
                AND MAP(cc.genericnumber6, 9999, cc.genericnumber4, cc.genericnumber6) < 13;  /* ORIGSQL: decode(cc.genericnumber6, 9999,cc.genericnumber4, cc.genericnumber6) */

        /* ORIGSQL: commit; */
        COMMIT;

        /* ORIGSQL: Log('7') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('7');

        ---------------------update eligible NADOR CREDIT

        /* ORIGSQL: Log('8') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('8');

        /* ORIGSQL: Update / *+ index(t OD_CREDIT_CREDITSEQ)* / */
        /* ORIGSQL: Update Cs_Credit t SET Genericboolean3 = 1 Where Processingunitseq = Gv_Processingunitseq and t.Creditseq in (SELECT Sh.Businessseq FROM Sh_Sequence Sh Where Sh.Seqtype = 'CREDITSEQ') ; */
        UPDATE Cs_Credit t
            SET
            /* ORIGSQL: Genericboolean3 = */
            Genericboolean3 = 1
        WHERE
            Processingunitseq = :Gv_Processingunitseq
            AND t.Creditseq  
            IN
            (
                SELECT   /* ORIGSQL: (Select Sh.Businessseq From Sh_Sequence Sh Where Sh.Seqtype = 'CREDITSEQ') */
                    Sh.Businessseq
                FROM
                    Sh_Sequence Sh
                WHERE
                    Sh.Seqtype = 'CREDITSEQ'
            );

        /* ORIGSQL: commit; */
        COMMIT;

        /* ORIGSQL: Log('8') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('8');

        ----DBMS_OUTPUT.put_line('nador credit updated');

        ------INSERT PMSEQ to sequence table

        /* ORIGSQL: Log('9') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('9');

        /* ORIGSQL: insert / *+ append * / */
        /* ORIGSQL: insert into sh_sequence select DISTINCT cm.measurementSeq, 'PMSEQ', cm.payeeseq, cm.positionSeq, cm.periodSeq from cs_measurement cm, sh_query_result r where cm.tenantid='AIAS' and ((cm.payeeseq = r.p(...) */
        INSERT INTO sh_sequence
            /* ORIGSQL: select / *+ * / */
            SELECT   /* ORIGSQL: select DISTINCT cm.measurementSeq, 'PMSEQ', cm.payeeseq, cm.positionSeq, cm.periodSeq from cs_measurement cm, sh_query_result r where cm.tenantid='AIAS' and ((cm.payeeseq = r.payeeseq and cm.positions(...) */
                DISTINCT
                cm.measurementSeq,
                'PMSEQ',
                cm.payeeseq,
                cm.positionSeq,
                cm.periodSeq
            FROM
                cs_measurement cm,
                sh_query_result r
            WHERE
                cm.tenantid = 'AIAS'
                --version 7
                --and cm.payeeseq = r.payeeseq
                --and cm.positionseq = r.positionseq
                AND ((cm.payeeseq = r.payeeseq
                        AND cm.positionseq = r.positionseq
                    AND r.Genericboolean3 = 0)
                    -- v20 start
                    -- or (cm.positionseq=r.Genericboolean2 and r.Genericboolean3=1) -- v20 original
                    OR (cm.payeeseq = r.payeeseq
                        AND cm.positionseq = r.positionseq
                        AND r.Genericboolean3 = 1
                    AND r.Genericboolean4 <> r.Genericboolean5)
                    OR (cm.positionseq = r.Genericboolean2
                        AND r.Genericboolean3 = 1
                    AND r.Genericboolean4 = r.Genericboolean5)
                    -- v20 end
                )
                AND cm.periodSeq = r.periodSeq
                AND cm.name = r.objOutputName
                AND R.Component = :v_componentValue
                AND r.periodseq = :Gv_Periodseq
                AND r.genericBoolean1 = 1
                AND cm.processingUnitseq = :Gv_Processingunitseq;

        /* ORIGSQL: commit; */
        COMMIT;

        /* ORIGSQL: Log('9') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('9');

        --comDebugger('nador','5.get pm seq');

        ---update PM

        /* ORIGSQL: Log('10') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('10'); 

        /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
        /* ORIGSQL: merge into cs_measurement cm using (SELECT s.payeeSeq, s.positionSeq, r.periodSeq, r.objOutputName, r.component, SUM(r.value) AS aggValue, SUM(r.genericnumber2) AS aggRecCnt, s.businessSeq FROM sh_que(...) */
        MERGE INTO cs_measurement AS cm  
            USING
            (
                SELECT   /* ORIGSQL: (SELECT s.payeeSeq, s.positionSeq, r.periodSeq, r.objOutputName, r.component, SUM(r.value) as aggValue, SUM(r.genericnumber2) as aggRecCnt, s.businessSeq from sh_query_result r, sh_sequence s Where Co(...) */
                    s.payeeSeq  /* --r.payeeSeq, */, s.positionSeq  /* --r.positionSeq, */, r.periodSeq,
                    r.objOutputName,
                    r.component,
                    SUM(r.value) AS aggValue,
                    SUM(r.genericnumber2) AS aggRecCnt,
                    s.businessSeq
                FROM
                    sh_query_result r,
                    sh_sequence s
                WHERE
                    Component = :v_componentValue
                    AND r.periodseq = :Gv_Periodseq
                    AND genericBoolean1 = 1
                    --version 7
                    --and s.payeeSeq = r.payeeSeq
                    --and s.positionSeq = r.positionSeq
                    AND ((s.payeeSeq = r.payeeSeq
                            AND s.positionSeq = r.positionSeq
                        AND r.Genericboolean3 = 0)
                        -- v20 start
                        -- or ( s.positionseq=r.Genericboolean2 and r.Genericboolean3=1) -- v20 original
                        OR (s.payeeSeq = r.payeeSeq
                            AND s.positionSeq = r.positionSeq
                            AND r.Genericboolean3 = 1
                        AND r.Genericboolean4 <> r.Genericboolean5)
                        OR (s.positionseq = r.Genericboolean2
                            AND r.Genericboolean3 = 1
                        AND r.Genericboolean4 = r.Genericboolean5)
                        -- v20 end
                    )
                    AND s.periodSeq = r.periodSeq
                    AND s.seqType = 'PMSEQ'
                GROUP BY
                    s.payeeSeq, --r.payeeSeq,
                    s.positionSeq, --r.positionSeq,
                    r.periodSeq,
                    r.objOutputName,
                    r.component,
                    s.businessSeq
            ) AS t
            ON (t.businessSeq = cm.measurementSeq
            AND cm.tenantid = 'AIAS')
        WHEN MATCHED THEN
            UPDATE SET cm.value = t.aggValue, cm.numberOfCredits = t.aggRecCnt;

        /* ORIGSQL: commit; */
        COMMIT;

        /* ORIGSQL: Log('10') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('10');

        /* ORIGSQL: Log('11') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('11');

        --version 7 create PMCredit Trace 

        /* ORIGSQL: delete from cs_PMCreditTrace t where exists (SELECT 1 FROM sh_sequence scm where 1 = 1 and scm.seqType = 'PMSEQ' and t.measurementSeq = scm.businessSeq) ; */
        DELETE
        FROM
            cs_PMCreditTrace
            t
        WHERE 
            EXISTS
            (
                SELECT   /* ORIGSQL: (select 1 from sh_sequence scm where 1 = 1 and scm.seqType = 'PMSEQ' and t.measurementSeq = scm.businessSeq) */
                    1
                FROM
                    sh_sequence scm
                WHERE
                    1 = 1
                    AND scm.seqType = 'PMSEQ'
                    AND t.measurementSeq = scm.businessSeq
            );

        /* ORIGSQL: Commit; */
        COMMIT;

        /* ORIGSQL: Log('11') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('11');

        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_CREDIT' not found */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_PMCREDITTRACE' not found */

        /* ORIGSQL: insert into cs_pmCreditTrace (Tenantid, creditSeq, measurementSeq, ruleSeq, pipelineRunSeq, targetPeriodSeq, sourcePeriodSeq, sourceorigintypeid, contributionValue, unittypeforContributionValue, busin(...) */
        INSERT INTO cs_pmCreditTrace
            (
                Tenantid,
                creditSeq,
                measurementSeq,
                ruleSeq,
                pipelineRunSeq,
                targetPeriodSeq,
                sourcePeriodSeq,
                sourceorigintypeid,
                contributionValue,
                unittypeforContributionValue,
                businessunitMap,
                processingUnitSeq
            )
            SELECT   /* ORIGSQL: select 'AIAS', creditSeq, measurementSeq, nvl(ruleSeq,0), pipelineRunSeq, targetPeriodSeq, sourcePeriodSeq, sourceOriginTypeId, contributionValue, unitTypeForContributionValue, businessUnitMap, proces(...) */
                'AIAS',
                creditSeq,
                measurementSeq,
                IFNULL(ruleSeq,0),  /* ORIGSQL: nvl(ruleSeq,0) */
                pipelineRunSeq,
                targetPeriodSeq,
                sourcePeriodSeq,
                sourceOriginTypeId,
                contributionValue,
                unitTypeForContributionValue,
                businessUnitMap,
                processingunitseq
            FROM
                (
                    SELECT   /* ORIGSQL: (select ROW_NUMBER() OVER (ORDER BY 0*0) as rn, cc.creditSeq, cm.measurementSeq, cm.ruleSeq, (Select MAX(Pipelinerunseq) From Cs_Pipelinerun Where Periodseq = Cc.Periodseq and command = 'PipelineRun')(...) */
                        ROW_NUMBER() OVER (ORDER BY 0*0) AS rn,  /* ORIGSQL: rownum */
                        cc.creditSeq,
                        cm.measurementSeq,
                        cm.ruleSeq,
                        (
                            /* ORIGSQL: Select / *+ INDEX(Cs_Pipelinerun Cs_Pipelinerun_MAX) * / */
                            SELECT   /* ORIGSQL: (Select MAX(Pipelinerunseq) FROM Cs_Pipelinerun Where Periodseq = Cc.Periodseq and command = 'PipelineRun') */
                                MAX(Pipelinerunseq) 
                            FROM
                                Cs_Pipelinerun
                            WHERE
                                Periodseq = Cc.Periodseq
                                AND command = 'PipelineRun'
                        ) AS pipelineRunSeq,
                        cm.periodSeq AS targetPeriodSeq,
                        cc.periodSeq AS sourcePeriodSeq,
                        cc.originTypeId AS sourceOriginTypeId,
                        cc.value AS contributionValue,
                        cc.unitTypeForValue AS unitTypeForContributionValue,
                        cc.businessUnitMap,
                        cc.processingunitseq
                    FROM
                        cs_credit cc, cs_measurement cm,
                        (
                            /* ORIGSQL: select / *+ materialize * / */
                            SELECT   /* ORIGSQL: (select scc.businessSeq as ccseq, scc.periodseq as pseq, scm.businessSeq as pmseq from sh_sequence scc, sh_sequence scm where scc.seqtype = 'CREDITSEQ' and scm.seqtype = 'PMSEQ' and (scc.positionseq =(...) */
                                scc.businessSeq AS ccseq,
                                scc.periodseq AS pseq,
                                scm.businessSeq AS pmseq
                            FROM
                                sh_sequence scc,
                                sh_sequence scm
                            WHERE
                                scc.seqtype = 'CREDITSEQ'
                                AND scm.seqtype = 'PMSEQ'
                                AND (scc.positionseq = scm.positionseq
                                OR scc.payeeseq = scm.positionseq) --PM credit old agency code
                                AND scc.periodSeq = scm.periodSeq
                        ) AS csp
                    WHERE
                        cc.tenantid = 'AIAS'
                        AND cm.tenantid = 'AIAS'
                        AND Cc.Processingunitseq = :Gv_Processingunitseq
                        AND Cm.Processingunitseq = :Gv_Processingunitseq
                        AND Cc.Origintypeid IN ('calculated', 'imported')
                        AND csp.pmseq = cm.measurementSeq
                        AND csp.ccseq = cc.creditseq
                ) AS t;

        /* ORIGSQL: commit; */
        COMMIT;

        --    comUpdPMCreditTrace('SP_UPDATE_NADOR');
        /* ORIGSQL: Log('11') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('11');

        /* ORIGSQL: exception when others then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__SP_UPDATE_NADOR') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_PBUBUYOUT' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_PBUBUYOUT''...' );
go

/* ORIGSQL: procedure SP_UPDATE_PBUBUYOUT(i_periodSeq in int) AS v_periodseq int := i_periodSeq; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_PBUBUYOUT
(
    IN i_periodSeq BIGINT     /* ORIGSQL: i_periodSeq IN int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE gv_error VARCHAR(1000); /* package/session variable */
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();
    DECLARE gv_isMonthEnd BIGINT; /* package/session variable */
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE v_periodseq BIGINT = :i_periodSeq;  /* ORIGSQL: v_periodseq int := i_periodSeq; */
    DECLARE v_periodStartDate TIMESTAMP;  /* ORIGSQL: v_periodStartDate date; */
    DECLARE v_periodEndDate TIMESTAMP;  /* ORIGSQL: v_periodEndDate date; */
    DECLARE v_pirorYearStartDate TIMESTAMP;  /* ORIGSQL: v_pirorYearStartDate Date; */
    DECLARE v_pirorYearEndDate TIMESTAMP;  /* ORIGSQL: v_pirorYearEndDate date; */
    DECLARE v_calendarSeq BIGINT;  /* ORIGSQL: v_calendarSeq int; */
    DECLARE v_periodTypeSeq BIGINT;  /* ORIGSQL: v_periodTypeSeq int; */
    DECLARE v_startPeriodSeq BIGINT;  /* ORIGSQL: v_startPeriodSeq int; */
    DECLARE V_Temp BIGINT;  /* ORIGSQL: V_Temp Int; */
    DECLARE V_Defaultdate TIMESTAMP = sapdbmtk.sp_f_dbmtk_format_string_to_datetime('1/1/1900', 'mm/dd/yyyy');  /* ORIGSQL: V_Defaultdate Date := To_Date('1/1/1900', 'mm/dd/yyyy') ; */

    DECLARE v_componentValue VARCHAR(30) = 'PBU_PM';  /* ORIGSQL: v_componentValue VARCHAR2(30) := 'PBU_PM'; */
    DECLARE V_Credittypeseq_FYC DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_FYC number; */
    DECLARE V_Credittypeseq_API DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_API number; */
    DECLARE V_Credittypeseq_SSCP DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_SSCP number; */
    DECLARE V_Credittypeseq_H_PIB DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_H_PIB number; */

    -- for revamp begin
    DECLARE V_Credittypeseq_RPI DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_RPI number; */
    DECLARE V_Credittypeseq_FYC_W DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_FYC_W number; */
    DECLARE V_Credittypeseq_FYC_W_DUP DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_FYC_W_DUP number; */
    DECLARE V_Credittypeseq_FYC_WC_DUP DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_FYC_WC_DUP number; */
    DECLARE V_Credittypeseq_API_W DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_API_W number; */
    DECLARE V_Credittypeseq_API_W_DUP DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_API_W_DUP number; */
    DECLARE V_Credittypeseq_API_WC_DUP DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_API_WC_DUP number; */
    DECLARE V_Credittypeseq_SSCP_W DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_SSCP_W number; */
    DECLARE V_Credittypeseq_SSCP_W_DUP DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_SSCP_W_DUP number; */
    DECLARE V_Credittypeseq_SSCP_WC_DUP DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_SSCP_WC_DUP number; */

    --for revamp end
    --v23 MAS86 PBU Lumpsum start
    DECLARE V_Credittypeseq_FYC_TPGI DECIMAL(38,10);  /* ORIGSQL: V_Credittypeseq_FYC_TPGI number; */

    --v23 MAS86 PBU Lumpsum end
    DECLARE v_PromoteeCount DECIMAL(38,10) = 0;  /* ORIGSQL: v_PromoteeCount number := 0; */

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            gv_error = 'Error [SP_UPDATE_PBUBUYOUT]: ' || ::SQL_ERROR_MESSAGE || ' - ' ||  /* ORIGSQL: sqlerrm */

            /* RESOLVE: Standard Package call(not converted): 'dbms_utility.format_error_backtrace' not supported, manual conversion required */
            dbms_utility.format_error_backtrace;
            /* Saving modified package/session variable 'gv_error': */ 
            SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR' = :gv_error;

            /* ORIGSQL: rollback; */
            ROLLBACK;

            /* sapdbmtk: Closing RETURN in exception handler commented out, not supported in HANA */
            --RETURN;
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR') INTO gv_error FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ISMONTHEND') AS BIGINT) INTO gv_isMonthEnd FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
        /* end of package/session variables */



    --comDebugger('SP_UPDATE_PBUBUYOUT','StageHook start for period ['||i_periodSeq||']'||'at ['||to_timestamp(sysdate)||']');

    /* TODO implementation required */

    ---clean up temp table
    /*delete from sh_query_result
    where component='PBU_PM';*/

    /* ORIGSQL: comInitialPartition('PBU', v_componentValue, i_periodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__ComInitialpartition('PBU', :v_componentValue, :i_periodSeq);

    /* ORIGSQL: execute immediate 'truncate table sh_sequence'; */
    /* ORIGSQL: truncate table sh_sequence ; */
    EXECUTE IMMEDIATE 'TRUNCATE TABLE sh_sequence';

    --DBMS_OUTPUT.put_line('start pbu------------');

    ----get period info. 

    SELECT
        startDate,
        endDate,
        ADD_MONTHS(startDate, -12),
        ADD_MONTHS(endDate, -12),
        periodTypeSeq,
        calendarSeq
    INTO
        v_periodStartDate,
        v_periodEndDate,
        v_pirorYearStartDate,
        v_pirorYearEndDate,
        v_periodTypeSeq,
        v_calendarSeq
    FROM
        cs_period
    WHERE
        tenantid = 'AIAS'
        AND periodseq = :v_periodseq
        AND removeDate = :cdt_EndOfTime;

    /*DBMS_OUTPUT.put_line('start pbu: periodSeq'||v_pirorYearStartDate||'--start period:'||v_pirorYearEndDate||'--type'
    ||v_periodTypeSeq||'--clendar'||v_calendarSeq);*/

    ---get start periodSeq 
    SELECT
        periodSeq
    INTO
        v_startPeriodSeq
    FROM
        cs_period
    WHERE
        tenantid = 'AIAS'
        AND startDate = :v_pirorYearStartDate
        AND endDate = :v_pirorYearEndDate
        AND periodtypeSeq = :v_periodTypeSeq
        AND calendarSeq = :v_calendarSeq
        AND removeDate = :cdt_EndOfTime;

    -- DBMS_OUTPUT.put_line('start pbu: periodSeq'||v_periodSeq||'--start period:'||v_startPeriodSeq);

    --Maintenance.Enablepdml;

    /* ORIGSQL: comDebugger('SQL Performance', 'Stagehook[SP_UPDATE_PBUBUYOUT]-SQL1 START:' || SYSDATE) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_UPDATE_PBUBUYOUT]-SQL1 START:'|| CURRENT_TIMESTAMP 
    );  /* ORIGSQL: SYSDATE */

    V_Credittypeseq_FYC = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('FYC');  /* ORIGSQL: Comgetcredittypeseq('FYC') */

    V_Credittypeseq_API = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('API');  /* ORIGSQL: Comgetcredittypeseq('API') */

    V_Credittypeseq_SSCP = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('SSCP');  /* ORIGSQL: Comgetcredittypeseq('SSCP') */

    V_Credittypeseq_H_PIB = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('H_PIB');  /* ORIGSQL: Comgetcredittypeseq('H_PIB') */

    --for revamp begin
    V_Credittypeseq_RPI = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('RPI');  /* ORIGSQL: Comgetcredittypeseq('RPI') */

    V_Credittypeseq_FYC_W = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('FYC_W');  /* ORIGSQL: Comgetcredittypeseq('FYC_W') */

    V_Credittypeseq_FYC_W_DUP = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('FYC_W_DUPLICATE');  /* ORIGSQL: Comgetcredittypeseq('FYC_W_DUPLICATE') */

    V_Credittypeseq_FYC_WC_DUP = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('FYC_WC_DUPLICATE');  /* ORIGSQL: Comgetcredittypeseq('FYC_WC_DUPLICATE') */

    V_Credittypeseq_API_W = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('API_W');  /* ORIGSQL: Comgetcredittypeseq('API_W') */

    V_Credittypeseq_API_W_DUP = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('API_W_DUPLICATE');  /* ORIGSQL: Comgetcredittypeseq('API_W_DUPLICATE') */

    V_Credittypeseq_API_WC_DUP = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('API_WC_DUPLICATE');  /* ORIGSQL: Comgetcredittypeseq('API_WC_DUPLICATE') */

    V_Credittypeseq_SSCP_W = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('SSCP_W');  /* ORIGSQL: Comgetcredittypeseq('SSCP_W') */

    V_Credittypeseq_SSCP_W_DUP = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('SSCP_W_DUPLICATE');  /* ORIGSQL: Comgetcredittypeseq('SSCP_W_DUPLICATE') */

    V_Credittypeseq_SSCP_WC_DUP = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('SSCP_WC_DUPLICATE');  /* ORIGSQL: Comgetcredittypeseq('SSCP_WC_DUPLICATE') */

    --for revamp end
    --V23 For MAS86 PBU
    V_Credittypeseq_FYC_TPGI = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('FYC_TPGI_DIRECT');  /* ORIGSQL: Comgetcredittypeseq('FYC_TPGI_DIRECT') */

    -- not going to change
    --vParName := segmentationutils.segmentname('CS_SalesTransaction', pProcessingUnitSeq, vPeriod.endDate);

    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_FIXEDVALUE' not found */

    SELECT
        value
    INTO
        gv_isMonthEnd
    FROM
        cs_fixedValue
    WHERE
        name = 'FV_Mo_End'
        AND Removedate = TO_DATE('22000101','YYYYMMDD')
        AND Effectivestartdate <= :v_periodStartDate
        AND effectiveEndDate > :v_periodStartDate;

    IF :gv_isMonthEnd = 1
    THEN
        /* ORIGSQL: Log('12') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('12');

        ----get eligible credit

        --v17 start

        /* ORIGSQL: execute immediate 'truncate table SH_PBU_TMP_DATAPARTICIPANT'; */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.SH_PBU_TMP_DATAPARTICIPANT' not found */

        /* ORIGSQL: truncate table SH_PBU_TMP_DATAPARTICIPANT ; */
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SH_PBU_TMP_DATAPARTICIPANT';

        /* ORIGSQL: insert into SH_PBU_TMP_DATAPARTICIPANT select pa.userid, pa.payeeseq, gpa.GENERICBOOLEAN2, gpa.genericAttribute6 from cs_participant pa, cs_gaparticipant gpa where pa.tenantid = 'AIAS' and gpa.tenanti(...) */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_PARTICIPANT' not found */
        INSERT INTO SH_PBU_TMP_DATAPARTICIPANT
            SELECT   /* ORIGSQL: select pa.userid, pa.payeeseq, gpa.GENERICBOOLEAN2, gpa.genericAttribute6 from cs_participant pa, cs_gaparticipant gpa where pa.tenantid = 'AIAS' and gpa.tenantid = 'AIAS' and pa.removeDate = cdt_EndO(...) */
                pa.userid,
                pa.payeeseq,
                gpa.GENERICBOOLEAN2,
                gpa.genericAttribute6
            FROM
                cs_participant pa,
                cs_gaparticipant gpa
            WHERE
                pa.tenantid = 'AIAS'
                AND gpa.tenantid = 'AIAS'
                AND pa.removeDate = :cdt_EndOfTime
                AND :v_periodEndDate >= pa.effectiveStartDate
                AND :v_periodEndDate < pa.effectiveEndDate
                AND gpa.removeDate = :cdt_EndOfTime
                AND pa.effectiveStartDate = gpa.effectiveStartDate
                AND pa.payeeseq = gpa.payeeseq
                AND gpa.pagenumber = 0;

        /* ORIGSQL: execute immediate 'truncate table SH_PBU_TMP_DATAPOSITION'; */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.SH_PBU_TMP_DATAPOSITION' not found */

        /* ORIGSQL: truncate table SH_PBU_TMP_DATAPOSITION ; */
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SH_PBU_TMP_DATAPOSITION';

        /* ORIGSQL: insert into SH_PBU_TMP_DATAPOSITION select cp.ruleElementOwnerSeq, cp.Name, cp.Genericattribute2 as ga2, cp.GENERICATTRIBUTE3 as ga3, cp.effectiveStartDate, cp.effectiveEndDate, cp.removeDate, cgp.gen(...) */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_GAPOSITION' not found */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_TITLE' not found */
        INSERT INTO SH_PBU_TMP_DATAPOSITION
            SELECT   /* ORIGSQL: select cp.ruleElementOwnerSeq, cp.Name, cp.Genericattribute2 as ga2, cp.GENERICATTRIBUTE3 as ga3, cp.effectiveStartDate, cp.effectiveEndDate, cp.removeDate, cgp.genericDate5 as ed5, cgp.genericDate11 (...) */
                cp.ruleElementOwnerSeq,
                cp.Name,
                cp.Genericattribute2 AS ga2 /* --leader code */, cp.GENERICATTRIBUTE3 AS ga3 /* --disctrict code */, cp.effectiveStartDate,
                cp.effectiveEndDate,
                cp.removeDate,
                cgp.genericDate5 AS ed5  /* --leader's promotion date */, cgp.genericDate11 AS ed11 /* --leader's Prev_Demotion_date */, tt.name AS title_name,
                pa.genericAttribute6 AS pa_ea6  /* --AIAS unit code for migrated unit */
            FROM
                /* RESOLVE: Oracle Outer Join query (+): Oracle outer join syntax converted to ANSI join syntax, verify correct conversion */
                DBMTK_USER_NAME.cs_gaposition AS cgp
            RIGHT OUTER JOIN
                DBMTK_USER_NAME.cs_position AS cp
                ON cgp.effectiveStartDate = cp.effectivestartdate  /* ORIGSQL: cgp.effectiveStartDate(+) = cp.effectivestartdate */
                AND cgp.pageNumber = 0  /* ORIGSQL: cgp.pageNumber(+) = 0 */
                AND cgp.removeDate = :cdt_EndOfTime  /* ORIGSQL: cgp.removeDate(+) = cdt_EndOfTime */
                AND cgp.ruleElementOwnerSeq = cp.ruleElementOwnerSeq  /* ORIGSQL: cgp.ruleElementOwnerSeq(+) = cp.ruleElementOwnerSeq */
            INNER JOIN
                DBMTK_USER_NAME.SH_PBU_TMP_DATAPARTICIPANT AS pa
                ON 'SGT'|| IFNULL(cp.Genericattribute2,'') = pa.USERID
            INNER JOIN
                DBMTK_USER_NAME.cs_title AS tt
                ON cp.titleseq = tt.ruleelementownerseq
                AND tt.removeDate = :cdt_EndOfTime
                AND v_periodEndDate >= tt.effectiveStartDate
                AND v_periodEndDate < tt.effectiveEndDate
            WHERE
                ((cp.Genericattribute6 = 'AGY') --AIAS
                    OR (cp.Genericattribute6 = 'AFA'
                AND pa.GENERICBOOLEAN2 = 1)) --FA 2.1
                AND cp.tenantid = 'AIAS'
                AND cgp.tenantid = 'AIAS'
                AND cp.name LIKE 'SGY%'
                AND cp.removeDate = :cdt_EndOfTime
                AND :v_periodEndDate < cp.effectiveEndDate
                AND :v_periodEndDate >= cp.effectiveStartDate;

        /* ORIGSQL: execute immediate 'truncate table SH_PBU_TMP_ALLUNIT'; */
        /* ORIGSQL: truncate table SH_PBU_TMP_ALLUNIT ; */
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SH_PBU_TMP_ALLUNIT';     

        /* ORIGSQL: insert into SH_PBU_TMP_ALLUNIT select ed5, ed11, districtName, unitName, pa_ea6, ruleElementOwnerSeq from (SELECT newFSD.ed5 AS ed5, newFSD.ed11 AS ed11, newFSD.Name AS districtName, newFSDUnit.NAME A(...) */
        INSERT INTO SH_PBU_TMP_ALLUNIT
            SELECT   /* ORIGSQL: select ed5, ed11, districtName, unitName, pa_ea6, ruleElementOwnerSeq from (SELECT newFSD.ed5 AS ed5, newFSD.ed11 AS ed11, newFSD.Name AS districtName, newFSDUnit.NAME AS unitName, newFSDUnit.pa_ea6 A(...) */
                ed5,
                ed11,
                districtName,
                unitName,
                pa_ea6,
                ruleElementOwnerSeq
            FROM
                (
                    SELECT   /* ORIGSQL: (Select newFSD.ed5 as ed5, newFSD.ed11 as ed11, newFSD.Name as districtName, newFSDUnit.NAME as unitName, newFSDUnit.pa_ea6 as pa_ea6, newFSDUnit.ruleElementOwnerSeq as ruleElementOwnerSeq from SH_PBU(...) */
                        newFSD.ed5 AS ed5 /* --New FSD's promotion date */, newFSD.ed11 AS ed11 /* --New FSD's Prev_Demotion_Date */, newFSD.Name AS districtName /* --District position name */, newFSDUnit.NAME AS unitName /* --Unit position name */, newFSDUnit.pa_ea6 AS pa_ea6 /* --Unit old AIAS's code */, newFSDUnit.ruleElementOwnerSeq AS ruleElementOwnerSeq
                    FROM
                        SH_PBU_TMP_DATAPOSITION newFSDUnit
                        -- direct and indirect units for FSD/ED that promoted in current month,
                    INNER JOIN
                        SH_PBU_TMP_DATAPOSITION newFSD
                        ON newFSD.name = 'SGY' || IFNULL(newFSDUnit.ga3,'') --direact unit 
                    WHERE
                        newFSD.ed5 >= :v_periodStartDate
                        AND newFSD.ed5 < :v_periodEndDate
                        AND newFSD.title_name IN ('DISTRICT', 'ORGANISATION')
                ) AS newUnit
    UNION ALL
        SELECT   /* ORIGSQL: select ed5, ed11, districtName, unitName, pa_ea6, ruleElementOwnerSeq from (SELECT newFSD.ed5 AS ed5, newFSD.ed11 AS ed11, newFSD.Name AS districtName, oldUnit.NAME AS unitName, oldUnit.pa_ea6 AS pa_e(...) */
            ed5,
            ed11,
            districtName,
            unitName,
            pa_ea6,
            ruleElementOwnerSeq
        FROM
            (
                SELECT   /* ORIGSQL: (Select newFSD.ed5 as ed5, newFSD.ed11 as ed11, newFSD.Name as districtName, oldUnit.NAME as unitName, oldUnit.pa_ea6 as pa_ea6, oldUnit.ruleElementOwnerSeq as ruleElementOwnerSeq from SH_PBU_TMP_DATA(...) */
                    newFSD.ed5 AS ed5 /* --New FSD's promotion date */, newFSD.ed11 AS ed11 /* --New FSD's Prev_Demotion_Date */, newFSD.Name AS districtName /* --District position name */, oldUnit.NAME AS unitName /* --Unit position name */, oldUnit.pa_ea6 AS pa_ea6 /* --Unit old AIAS's code */, oldUnit.ruleElementOwnerSeq AS ruleElementOwnerSeq
                FROM
                    SH_PBU_TMP_DATAPOSITION oldUnit
                    -- direct/indirect units before migrated for ED promoted in current month.
                INNER JOIN
                    SH_PBU_TMP_DATAPOSITION newUnit
                    ON oldUnit.name = 'SGY'|| IFNULL(newUnit.pa_ea6,'')
                INNER JOIN
                    SH_PBU_TMP_DATAPOSITION newFSD
                    ON newFSD.name = 'SGY'|| IFNULL(newUnit.ga3,'')
                WHERE
                    newFSD.ed5 >= :v_periodStartDate
                    AND newFSD.ed5 < :v_periodEndDate
                    AND newFSD.title_name IN ('DISTRICT', 'ORGANISATION')
            ) AS migratedUnit;

        /* ORIGSQL: commit; */
        COMMIT;

        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.SH_PBU_TMP_ALLUNIT' not found */

        SELECT
            COUNT(*)
        INTO
            v_PromoteeCount
        FROM
            SH_PBU_TMP_ALLUNIT;

        IF :v_PromoteeCount > 0
        THEN
            -- credittypeseq index
            /* ORIGSQL: Insert / *+ APPEND * / */
            /* ORIGSQL: Insert Into Sh_Query_Result (Component, Objoutputname, Payeeseq, Positionseq, Periodseq, value, genericSequence1, genericSequence2, Genericdate1, Genericdate2, Genericdate3, GENERICATTRIBUTE1, GENERIC(...) */
            INSERT INTO Sh_Query_Result
                (
                    Component,
                    Objoutputname,
                    Payeeseq,
                    Positionseq,
                    Periodseq,
                    value,
                    genericSequence1,
                    genericSequence2,
                    Genericdate1  /* --New FSD's promotion date */,
                    Genericdate2  /* --New FSD's Prev Demotion_Date */,
                    Genericdate3  /* --Agenct's transfer date */,

                    /* --version 15 begin */
                    GENERICATTRIBUTE1  /* --Nev FSD's position name */,
                    GENERICATTRIBUTE2   /* --Unit agency code */,
                    GENERICATTRIBUTE3   /* --Unit old agency code */
                    /* --version 15 end */
                )
                --version 15 begin
                /*with data_position as
                (select
                       cp.ruleElementOwnerSeq,
                     cp.Name,
                     cp.Genericattribute2 as ga2, --leader code
                     cp.GENERICATTRIBUTE3 as ga3, --disctrict code
                     cp.effectiveStartDate,
                     cp.effectiveEndDate,
                     cp.removeDate,
                     cgp.genericDate5 as ed5,  --leader's promotion date
                     cgp.genericDate11 as ed11, --leader's Prev_Demotion_date
                     tt.name as title_name,
                     gpa.genericAttribute6 as pa_ea6  --AIAS unit code for migrated unit
                     from cs_position cp, cs_gaposition cgp, cs_title tt, cs_participant pa, cs_gaparticipant gpa
                     where
                     cp.tenantid = 'AIAS'
                     and cgp.tenantid = 'AIAS'
                     and pa.tenantid = 'AIAS'
                     and gpa.tenantid = 'AIAS'
                     and cp.name like 'SGY%'
                     and v_periodEndDate >= cp.effectiveStartDate
                     and v_periodEndDate < cp.effectiveEndDate
                     and cp.removeDate = cdt_EndOfTime
                     and cgp.pageNumber(+) = 0
                     and cgp.ruleElementOwnerSeq(+) = cp.ruleElementOwnerSeq
                     and cgp.removeDate(+) = cdt_EndOfTime
                     and cgp.effectiveStartDate(+) <= v_periodEndDate
                     and cgp.effectiveEndDate(+) > v_periodEndDate
                     and cp.titleseq = tt.ruleelementownerseq
                     and tt.removeDate = cdt_EndOfTime
                     and v_periodEndDate >= tt.effectiveStartDate
                     and v_periodEndDate < tt.effectiveEndDate
                     and pa.removeDate = cdt_EndOfTime
                     and v_periodEndDate >= pa.effectiveStartDate
                     and v_periodEndDate < pa.effectiveEndDate
                     and 'SGT' || cp.Genericattribute2 = pa.USERID
                     and gpa.removeDate = cdt_EndOfTime
                     and v_periodEndDate >= gpa.effectiveStartDate
                     and v_periodEndDate < gpa.effectiveEndDate
                     and pa.payeeseq = gpa.payeeseq
                     and ((cp.Genericattribute6 = 'AGY')   --AIAS
                         or (cp.Genericattribute6 = 'AFA'and gpa.GENERICBOOLEAN2 =1)) --FA 2.1
                    
                ),
                allUnit as (
                    select    ed5,
                         ed11,
                         districtName,
                         unitName,
                         pa_ea6,
                         ruleElementOwnerSeq
                    from (Select newFSD.ed5                     as ed5, --New FSD's promotion date
                                      newFSD.ed11                    as ed11, --New FSD's Prev_Demotion_Date
                                      newFSD.Name                    as districtName, --District position name
                                      newFSDUnit.NAME                as unitName, --Unit position name
                                      newFSDUnit.pa_ea6              as pa_ea6, --Unit old AIAS's code
                                      newFSDUnit.ruleElementOwnerSeq as ruleElementOwnerSeq
                                 from data_position newFSDUnit -- direct and indirect units for FSD/ED that promoted in current month,
                                inner join data_position newFSD
                                   on newFSD.name = 'SGY' || newFSDUnit.ga3 --direact unit
                                where newFSD.ed5 >= v_periodStartDate
                         and newFSD.ed5 <  v_periodEndDate
                         and newFSD.title_name in ('DISTRICT', 'ORGANISATION')) newUnit
                            UNION ALL
                            select ed5,
                          ed11,
                          districtName,
                          unitName,
                          pa_ea6,
                          ruleElementOwnerSeq
                     from (Select newFSD.ed5                  as ed5, --New FSD's promotion date
                                     newFSD.ed11                 as ed11, --New FSD's Prev_Demotion_Date
                                       newFSD.Name                 as districtName, --District position name
                                       oldUnit.NAME                as unitName, --Unit position name
                                       oldUnit.pa_ea6              as pa_ea6, --Unit old AIAS's code
                                     oldUnit.ruleElementOwnerSeq as ruleElementOwnerSeq
                                from data_position oldUnit -- direct/indirect units before migrated for ED promoted in current month.
                               inner join data_position newUnit
                                  on oldUnit.name = 'SGY' || newUnit.pa_ea6
                               inner join data_position newFSD
                                  on newFSD.name = 'SGY' || newUnit.ga3
                               where newFSD.ed5 >= v_periodStartDate
                         and newFSD.ed5 < v_periodEndDate
                         and newFSD.title_name in ('DISTRICT', 'ORGANISATION')) migratedUnit
                    
                ) */
                --version 15 end
                /* ORIGSQL: Select / *+ index(cc CS_CREDIT_POSITION) * / */
                SELECT   /* ORIGSQL: Select v_componentValue, 'PM_PBU_Buyout', cc.payeeSeq, cc.positionSeq, v_periodSeq, cc.value, cc.creditSeq, cc.periodSeq, allUnit.ed5, allUnit.ed11, cc.genericDate4, allUnit.districtName, allUnit.unit(...) */
                    :v_componentValue,
                    'PM_PBU_Buyout',
                    cc.payeeSeq,
                    cc.positionSeq,
                    :v_periodseq,
                    cc.value,
                    cc.creditSeq,
                    cc.periodSeq,
                    /* --version 15 begin */
                    /* --cgp.genericDate5, */
                    /* --cgp.genericDate11, */
                    allUnit.ed5  /* --New FSD's promotion date */, allUnit.ed11  /* --New FSD's Prev_Demotion_Date */, cc.genericDate4  /* --Agent's transfer date */, allUnit.districtName  /* --District code */, allUnit.unitName  /* --Unit code */, allUnit.pa_ea6  /* --Unit old code */
                    /* --version 15 end */
                FROM
                    cs_credit cc,
                    --version 15 begin
                    --cs_position cp,
                    --cs_gaposition cgp
                    SH_PBU_TMP_ALLUNIT allUnit
                    --version 15 end
                WHERE
                    cc.tenantid = 'AIAS'
                    --version 15 begin
                    --and cp.tenantid='AIAS'
                    --and cgp.tenantid='AIAS'
                    --And Cp.Name Like 'SGY%'
                    --and cp.removeDate = cdt_EndOfTime
                    --and v_periodEndDate >= cp.effectiveStartDate
                    --and v_periodEndDate < cp.effectiveEndDate
                    --and cgp.genericDate5 >= v_periodStartDate
                    --and cgp.genericDate5 < v_periodEndDate
                    --and cp.ruleElementOwnerSeq = cc.positionSeq

                    --version 15 end

                    AND cc.processingUnitSeq = 38280596832649218
                    AND cc.periodseq >= :v_startPeriodSeq
                    AND cc.periodSeq < :v_periodseq
                    AND cc.origintypeid IN ('calculated', 'imported')
                    AND cc.genericAttribute14 <> '12'
                    AND IFNULL(cc.genericDate4, :V_Defaultdate) <  /* ORIGSQL: nvl(cc.genericDate4, v_defaultDate) */
                    --version 15 begin
                    --add_months(cgp.genericDate5, -36)
                    ADD_MONTHS(allUnit.ed5, -36)
                    --version 15 end
                    AND ((cc.credittypeseq = :V_Credittypeseq_FYC
                            AND -- old policy issued before 12/1/2015, follow the old logic
                            Cc.Genericattribute2 IN ('PA', 'CS', 'CL', 'HS', 'LF')
                            AND cc.genericdate2 < sapdbmtk.sp_f_dbmtk_format_string_to_datetime('12/1/2015', 'mm/dd/yyyy'))  /* ORIGSQL: to_date('12/1/2015', 'mm/dd/yyyy') */
                        OR (cc.credittypeseq = :V_Credittypeseq_FYC
                            AND -- new policy issued after 12/1/2015, CS credit will follow commission agent/agency, gb5 = false
                            Cc.Genericattribute2 IN ('CS', 'CL')
                            AND cc.genericdate2 >= sapdbmtk.sp_f_dbmtk_format_string_to_datetime('12/1/2015', 'mm/dd/yyyy'))  /* ORIGSQL: to_date('12/1/2015', 'mm/dd/yyyy') */
                        OR (cc.credittypeseq IN
                            (:V_Credittypeseq_FYC_W,
                                :V_Credittypeseq_FYC_W_DUP,
                            :V_Credittypeseq_FYC_WC_DUP)
                            AND -- new policy issued after 12/1/2015, Life/PA credit will follow writing agent/agency, gb5 = true
                            Cc.Genericattribute2 IN ('PA', 'HS', 'LF')
                            AND cc.genericdate2 >= sapdbmtk.sp_f_dbmtk_format_string_to_datetime('12/1/2015', 'mm/dd/yyyy'))  /* ORIGSQL: to_date('12/1/2015', 'mm/dd/yyyy') */
                        OR --V23 MAS86 PBU lumpsum
                        (cc.credittypeseq = :V_Credittypeseq_FYC_TPGI
                            AND Cc.Genericattribute1 IN ('TPAH', 'TPCS'))
                        OR (cc.creditTypeseq IN
                            (:V_Credittypeseq_API,
                                :V_Credittypeseq_SSCP,
                                :V_Credittypeseq_H_PIB,
                                :V_Credittypeseq_API_W,
                                :V_Credittypeseq_API_W_DUP,
                                :V_Credittypeseq_API_WC_DUP,
                                :V_Credittypeseq_SSCP_W,
                                :V_Credittypeseq_SSCP_W_DUP,
                        :V_Credittypeseq_SSCP_WC_DUP))
                    )
                    --version 15 begin
                    --and cgp.pageNumber(+) = 0
                    --and cgp.ruleElementOwnerSeq(+) = cc.positionseq
                    --and cgp.removeDate(+) = cdt_EndofTime
                    --and cgp.effectiveStartDate(+) <= v_periodEndDate
                    --and cgp.effectiveEndDate(+) > v_periodEndDate
                    --and ((cgp.genericDate11) IS NULL or
                        --cgp.genericDate11 <= add_months(cgp.genericDate5, -60));
                    AND allUnit.ruleElementOwnerSeq = cc.positionseq
                    AND ((allUnit.ed11) IS NULL
                        OR allUnit.ed11 <= ADD_MONTHS(allUnit.ed5, -60));

            --version 15 end

            /* ORIGSQL: commit; */
            COMMIT;

            /* ORIGSQL: Log('12') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('12');

            ----------for PBU special handling of Nov 27th issue. 
            /* ORIGSQL: delete from Sh_Query_Result t where exists(WITH x AS (SELECT sqr.periodseq, sqr.genericsequence1, sqr.genericsequence2 FROM Sh_Query_Result sqr inner join cs_credit c on sqr.genericsequence1 = c.credi(...) */
            DELETE
            FROM
                Sh_Query_Result
                t
            WHERE
                EXISTS(
                    WITH 
                    x    
                    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.PBU_BUYOUT_TXNEXCL' not found */
                    AS (
                        /* ORIGSQL: select / *+ leading(sqr,c) * / */
                        SELECT   /* ORIGSQL: (select sqr.periodseq, sqr.genericsequence1, sqr.genericsequence2 from Sh_Query_Result sqr inner join cs_credit c on sqr.genericsequence1 = c.creditseq and sqr.genericsequence2 = c.periodseq inner joi(...) */
                            sqr.periodseq,
                            sqr.genericsequence1,
                            sqr.genericsequence2
                        FROM
                            Sh_Query_Result sqr
                        INNER JOIN
                            cs_credit c
                            ON sqr.genericsequence1 = c.creditseq
                            AND sqr.genericsequence2 = c.periodseq
                        INNER JOIN
                            PBU_Buyout_TxnExcl PBT
                            ON c.salestransactionseq =
                            PBT.salestransactionseq
                            AND c.periodseq = PBT.periodseq
                            AND c.tenantid = 'AIAS'
                            AND c.processingUnitSeq = :Gv_Processingunitseq
                        WHERE
                            sqr.component = 'PBU_PM'
                            AND sqr.periodseq = :v_periodseq
                    
                    )
                    SELECT   /* ORIGSQL: select 1 from x where t.periodseq = x.periodseq and t.genericsequence1 = x.genericsequence1 and t.genericsequence2 = x.genericsequence2) and component = 'PBU_PM' and t.periodseq = v_periodSeq ; */
                        1
                    FROM
                        x
                    WHERE
                        t.periodseq = x.periodseq
                        AND t.genericsequence1 = x.genericsequence1
                    AND t.genericsequence2 = x.genericsequence2)
                    AND component = 'PBU_PM'
                    AND t.periodseq = :v_periodseq;

            /* ORIGSQL: commit; */
            COMMIT;

            /* ORIGSQL: Log('13') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('13');

            /* ORIGSQL: insert / *+append * / */
            /* ORIGSQL: insert into sh_sequence select genericSequence1, 'CREDITSEQ', payeeSeq, positionSeq, periodSeq from sh_query_result Where Component = V_Componentvalue and periodSeq = gv_periodseq; */
            INSERT INTO sh_sequence
                SELECT   /* ORIGSQL: select genericSequence1, 'CREDITSEQ', payeeSeq, positionSeq, periodSeq from sh_query_result Where Component = V_Componentvalue and periodSeq = gv_periodseq; */
                    genericSequence1,
                    'CREDITSEQ',
                    payeeSeq,
                    positionSeq,
                    periodSeq
                FROM
                    sh_query_result
                WHERE
                    Component = :v_componentValue
                    AND periodSeq = :Gv_Periodseq;

            /* ORIGSQL: commit; */
            COMMIT;

            /* ORIGSQL: Log('13') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('13');

            /* ORIGSQL: Log('14') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('14');

            /* ORIGSQL: Update / *+index(t OD_CREDIT_CREDITSEQ)* / */
            /* ORIGSQL: Update Cs_Credit t SET Genericboolean4 = 1 Where tenantid='AIAS' and Processingunitseq = Gv_Processingunitseq and T.Creditseq in (SELECT Sh.Businessseq FROM Sh_Sequence Sh Where Sh.Seqtype = 'CREDITSE(...) */
            UPDATE Cs_Credit t
                SET
                /* ORIGSQL: Genericboolean4 = */
                Genericboolean4 = 1
            WHERE
                tenantid = 'AIAS'
                AND Processingunitseq = :Gv_Processingunitseq
                AND T.Creditseq  
                IN
                (
                    SELECT   /* ORIGSQL: (Select Sh.Businessseq From Sh_Sequence Sh Where Sh.Seqtype = 'CREDITSEQ') */
                        Sh.Businessseq
                    FROM
                        Sh_Sequence Sh
                    WHERE
                        Sh.Seqtype = 'CREDITSEQ'
                );

            /* ORIGSQL: commit; */
            COMMIT;

            /* ORIGSQL: Log('14') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('14');

            /* ORIGSQL: Log('15') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('15');

            /* ORIGSQL: insert / *+append * / */
            /* ORIGSQL: insert into sh_sequence select distinct cm.measurementSeq, 'PMSEQ', cm.payeeSeq, cm.positionSeq, cm.periodSeq from cs_measurement cm, sh_query_result r where cm.tenantid='AIAS' and R.Component = V_Com(...) */
            INSERT INTO sh_sequence
                SELECT   /* ORIGSQL: select distinct cm.measurementSeq, 'PMSEQ', cm.payeeSeq, cm.positionSeq, cm.periodSeq from cs_measurement cm, sh_query_result r where cm.tenantid='AIAS' and R.Component = V_Componentvalue and r.period(...) */
                    DISTINCT
                    cm.measurementSeq,
                    'PMSEQ',
                    cm.payeeSeq,
                    cm.positionSeq,
                    cm.periodSeq
                FROM
                    cs_measurement cm,
                    sh_query_result r
                WHERE
                    cm.tenantid = 'AIAS'
                    AND R.Component = :v_componentValue
                    AND r.periodseq = :Gv_Periodseq
                    AND cm.name = r.objOutputName
                    AND cm.payeeSeq = r.payeeSeq
                    AND cm.positionSeq = r.positionSeq
                    AND Cm.Periodseq = R.Periodseq
                    AND cm.processingunitseq = :Gv_Processingunitseq;

            /* ORIGSQL: commit; */
            COMMIT;

            /* ORIGSQL: Log('15') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('15');

            --DBMS_OUTPUT.put_line('save pmseq');

            -----update pm

            /* ORIGSQL: Log('16') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('16'); 

            /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
            /* ORIGSQL: merge into cs_measurement cm using (SELECT objOutputName, payeeSeq, positionSeq, periodSeq, SUM(value) AS aggValue, COUNT(*) AS numberOfCredits FROM sh_query_result where component = v_componentValue (...) */
            MERGE INTO cs_measurement AS cm 
                USING
                (
                    SELECT   /* ORIGSQL: (select objOutputName, payeeSeq, positionSeq, periodSeq, SUM(value) aggValue, COUNT(*) numberOfCredits from sh_query_result where component = v_componentValue and periodSeq = gv_periodseq group by obj(...) */
                        objOutputName,
                        payeeSeq,
                        positionSeq,
                        periodSeq,
                        SUM(value) AS aggValue,
                        COUNT(*) AS numberOfCredits
                    FROM
                        sh_query_result
                    WHERE
                        component = :v_componentValue
                        AND periodSeq = :Gv_Periodseq
                    GROUP BY
                        objOutputName, payeeSeq, positionSeq, periodSeq
                ) AS r
                ON (cm.tenantid = 'AIAS'
                    AND cm.payeeseq = r.payeeseq
                    AND cm.positionseq = r.positionseq
                    AND cm.periodSeq = r.periodSeq
                    AND cm.name = r.objOutputName
                    AND 
                    EXISTS
                    (
                        SELECT   /* ORIGSQL: (select 1 from sh_sequence where businessSeq = cm.measurementSeq and seqType = 'PMSEQ') */
                            1
                        FROM
                            sh_sequence
                        WHERE
                            businessSeq =
                            cm.measurementSeq
                            AND seqType =
                            'PMSEQ'
                    )
                )
            WHEN MATCHED THEN
                UPDATE
                    SET cm.value = r.aggValue, cm.numberOfCredits = r.numberOfCredits;

            /* ORIGSQL: commit; */
            COMMIT;

            /* ORIGSQL: Log('16') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('16');

            /* ORIGSQL: Log('17') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('17');

            /* ORIGSQL: comUpdPMCreditTrace('SP_UPDATE_PBUBUYOUT') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comUpdPMCreditTrace('SP_UPDATE_PBUBUYOUT');
            /* Get potentially modified package/session variable 'gv_error' */
            SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR') INTO gv_error FROM SYS.DUMMY ;

            /* ORIGSQL: Log('17') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('17');
        ELSE 
            /* ORIGSQL: Log('12 - no promotee found') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('12 - no promotee found');
        END IF;
    ELSE 
        /* ORIGSQL: Log('12 - Not month end') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('12 - Not month end');
    END IF;

    /* ORIGSQL: exception when others then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__SP_UPDATE_PBUBUYOUT') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_DO_QUARTERLY' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_DO_QUARTERLY''...' );
go

/* ORIGSQL: procedure SP_UPDATE_DO_QUARTERLY(i_periodSeq in int) aS v_rec int := 0; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_DO_QUARTERLY
(
    IN i_periodSeq BIGINT     /* ORIGSQL: i_periodSeq IN int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN SEQUENTIAL EXECUTION
    DECLARE DBMTK_TMPVAR_STRING_1 VARCHAR(5000); /*sapdbmtk-generated help variable*/
    DECLARE DBMTK_CTV_PROCID INT := sapdbmtk.sp_f_dbmtk_ctv_procid(); /*sapdbmtk-generated help variable*/
    DECLARE gv_error VARCHAR(1000); /* package/session variable */
    DECLARE Gv_Periodname VARCHAR(100); /* package/session variable */
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */
    DECLARE gv_prePeriodSeq2 BIGINT; /* package/session variable */
    DECLARE gv_prePeriodSeq1 BIGINT; /* package/session variable */
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE v_rec BIGINT = 0;  /* ORIGSQL: v_rec int := 0; */
    DECLARE v_threshold BIGINT = 0;  /* ORIGSQL: v_threshold int := 0; */
    DECLARE V_Rtn BIGINT = 0;  /* ORIGSQL: V_Rtn Int := 0; */
    DECLARE V_Credittypeseq BIGINT = 0;  /* ORIGSQL: V_Credittypeseq Int := 0; */
    DECLARE v_componentValue VARCHAR(30) = 'DO_PM';  /* ORIGSQL: v_componentValue VARCHAR2(30) := 'DO_PM'; */
    DECLARE vSQL VARCHAR(4000);  /* ORIGSQL: vSQL varchar2(4000); */

    DECLARE vParName DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_DO_QUARTERLY__PartName;  /* ORIGSQL: vParName PartName; */

    /* ORIGSQL: for i in 1..3 loop */
    DECLARE i INT;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            gv_error = 'Error [SP_UPDATE_DO_QUARTERLY]: ' || ::SQL_ERROR_MESSAGE || ' - ' ||  /* ORIGSQL: sqlerrm */

            /* RESOLVE: Standard Package call(not converted): 'dbms_utility.format_error_backtrace' not supported, manual conversion required */
            dbms_utility.format_error_backtrace

            || ' - on Period:' ||
            IFNULL(:Gv_Periodname,'');
            /* Saving modified package/session variable 'gv_error': */ 
            SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR' = :gv_error;

            /* ORIGSQL: rollback; */
            ROLLBACK;

            /* sapdbmtk: Closing RETURN in exception handler commented out, not supported in HANA */
            --RETURN;
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR') INTO gv_error FROM SYS.DUMMY ;
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODNAME') INTO Gv_Periodname FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PREPERIODSEQ2') AS BIGINT) INTO gv_prePeriodSeq2 FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PREPERIODSEQ1') AS BIGINT) INTO gv_prePeriodSeq1 FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
        /* end of package/session variables */



    /*---TYPE definition moved to  ddl_script_types ---
    type PartName IS VARRAY(10) OF VARCHAR2(255);
    ---end of TYPE definition commented out---*/

    /* ORIGSQL: comDebugger('SP_UPDATE_DO_QUARTERLY', 'StageHook start for period [' || i_periodSeq || ']' || 'at [' || to_timestamp(sysdate) || ']') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SP_UPDATE_DO_QUARTERLY', 'StageHook start for period ['|| IFNULL(TO_VARCHAR(:i_periodSeq),'') || ']'|| 'at ['|| IFNULL(TO_VARCHAR(sapdbmtk.sp_f_dbmtk_format_string_to_datetime(CURRENT_TIMESTAMP)),'') || ']' 
        /* ORIGSQL: to_timestamp(sysdate) */
    );  

    ---init global variable

    V_Rtn = DBMTK_USER_NAME.PK_STAGE_HOOK__comGetQuarterMonth(:i_periodSeq);  /* ORIGSQL: comGetQuarterMonth(i_periodSeq) */

    IF :V_Rtn < 1
    THEN 
        RETURN;
    END IF;

    ---clean up temp table

    /* ORIGSQL: comInitialPartition('DO', v_componentValue, i_periodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__ComInitialpartition('DO', :v_componentValue, :i_periodSeq);

    --Gv_Preperiodseq1:=2533274790395933;
    --Gv_Preperiodseq2:=2533274790395934;
    --I_Periodseq:=2533274790395935;

    /* ORIGSQL: execute immediate 'truncate table sh_sequence'; */
    /* ORIGSQL: truncate table sh_sequence ; */
    EXECUTE IMMEDIATE 'TRUNCATE TABLE sh_sequence';
    BEGIN 
        DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 1299 /*1299=ERR_SQLSCRIPT_NO_DATA_FOUND*/
            /* ORIGSQL: when no_data_found then */
            BEGIN
                v_threshold = 1250;
            END;



        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.SH_REFERENCE' not found */

        SELECT
            refIntValue
        INTO
            v_threshold
        FROM
            sh_reference
        WHERE
            refId = 'DO_QTR_THRESHOLD';

        /* ORIGSQL: exception when no_data_found then */
    END;

    V_Credittypeseq = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq('DO_QTR');  /* ORIGSQL: comgetcredittypeseq('DO_QTR') */

    --Maintenance.Enablepdml;

    /* ORIGSQL: comDebugger('SQL Performance', 'Stagehook[SP_UPDATE_DO_QUARTERLY]-SQL1 START:' || SYSDATE) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_UPDATE_DO_QUARTERLY]-SQL1 START:'|| CURRENT_TIMESTAMP 
    );  /* ORIGSQL: SYSDATE */

    /* ORIGSQL: Log('18') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('18');

    /* ORIGSQL: vParName := partname(' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '); */
    :vParName.DELETE();
    vParName.column_value[1] = ' ';    vParName.dbmtk_ix_col[1] = 1;
    vParName.column_value[2] = ' ';    vParName.dbmtk_ix_col[2] = 2;
    vParName.column_value[3] = ' ';    vParName.dbmtk_ix_col[3] = 3;
    vParName.column_value[4] = ' ';    vParName.dbmtk_ix_col[4] = 4;
    vParName.column_value[5] = ' ';    vParName.dbmtk_ix_col[5] = 5;
    vParName.column_value[6] = ' ';    vParName.dbmtk_ix_col[6] = 6;
    vParName.column_value[7] = ' ';    vParName.dbmtk_ix_col[7] = 7;
    vParName.column_value[8] = ' ';    vParName.dbmtk_ix_col[8] = 8;
    vParName.column_value[9] = ' ';    vParName.dbmtk_ix_col[9] = 9;
    vParName.column_value[10] = ' ';    vParName.dbmtk_ix_col[10] = 10;
    t_dbmtk_ix_col = UNNEST(ARRAY_AGG(:vParName.dbmtk_ix_col)) AS (dbmtk_ix_col); CALL sapdbmtk.sp_dbmtk_ctv_pushix('vParName',:DBMTK_CTV_PROCID,:t_dbmtk_ix_col);

    /* ORIGSQL: vParName(1) := DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME('CS_CREDIT', I_Periodseq, gv_ProcessingUnitSeq) ; GETSUBPARTITIONNAME('CS_CREDIT',I_Periodseq,gv_ProcessingUnitSeq) */
    vParName = SELECT * FROM DBMTK_USER_NAME.sp_f_dbmtk_ctv_assign_pk_stage_hook__sp_update_do_quarterly__partname('vParName',:vParName,:DBMTK_CTV_PROCID,1,'column_value',column_value => DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME('CS_CREDIT', :i_periodSeq, :Gv_Processingunitseq));  

    /* ORIGSQL: vParName(2) := DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME('CS_CREDIT', gv_prePeriodSeq2, gv_ProcessingUnitSeq) ; GETSUBPARTITIONNAME('CS_CREDIT',gv_prePeriodSeq2,gv_ProcessingUnitSeq) */
    vParName = SELECT * FROM DBMTK_USER_NAME.sp_f_dbmtk_ctv_assign_pk_stage_hook__sp_update_do_quarterly__partname('vParName',:vParName,:DBMTK_CTV_PROCID,2,'column_value',column_value => DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME('CS_CREDIT', :gv_prePeriodSeq2, :Gv_Processingunitseq));  

    /* ORIGSQL: vParName(3) := DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME('CS_CREDIT', Gv_Preperiodseq1, gv_ProcessingUnitSeq) ; GETSUBPARTITIONNAME('CS_CREDIT',Gv_Preperiodseq1,gv_ProcessingUnitSeq) */
    vParName = SELECT * FROM DBMTK_USER_NAME.sp_f_dbmtk_ctv_assign_pk_stage_hook__sp_update_do_quarterly__partname('vParName',:vParName,:DBMTK_CTV_PROCID,3,'column_value',column_value => DBMTK_USER_NAME.PK_STAGE_HOOK__GETSUBPARTITIONNAME('CS_CREDIT', :gv_prePeriodSeq1, :Gv_Processingunitseq));  

    ----aggregate the agcy credit
    -- credit type seq index

    FOR i IN 1 .. 3
    DO
        vSQL = 'Insert /*+ APPEND */  Into ';

        vSQL = IFNULL(:vSQL,'') ||
        'sh_query_result (component,objOutputName,payeeSeq,positionSeq,periodSeq,value, ';

        vSQL = IFNULL(:vSQL,'') ||
    'Genericnumber1,Genericsequence1,Genericsequence2,Genericsequence3,Genericsequence4,Genericboolean1,Genericnumber2,Genericattribute1) ';

        vSQL = IFNULL(:vSQL,'') ||
        'select /*+ parallel(8)  */ ''' ||
        IFNULL(:v_componentValue,'') ||
        ''' as component,''PM_DO_QTR_BN'' as pm_name, cc.payeeSeq,cc.positionSeq, ';

        vSQL = IFNULL(:vSQL,'') || ':i_periodSeq,sum(cc.value) as aggValue, ';

        vSQL = IFNULL(:vSQL,'') ||
        'count(cc.creditSeq) as numberOfCredit,cp.ruleElementOwnerSeq as agntPost, ';

        vSQL = IFNULL(:vSQL,'') ||
        'Cp.Payeeseq As Agntpayee , Cc.Periodseq ,Cc.Credittypeseq,0 As Validflag, :V_Threshold  As Threshold, Cc.Genericattribute12 As Agentcode ';

        vSQL = IFNULL(:vSQL,'') || 'From Cs_Credit '|| 'SUBPARTITION (' || IFNULL(:vParName.column_value[:i],'') || ') ' || ' Cc, Cs_Position Cp,';  /* ORIGSQL: vParName(i) */

        vSQL = IFNULL(:vSQL,'') || 'Cs_Position Leaderpos ';

        vSQL = IFNULL(:vSQL,'') || 'Where  cc.creditTypeSeq=:v_credittypeseq ';
        vSQL = IFNULL(:vSQL,'') || 'and cp.name=''BRT''||cc.genericAttribute12 ';

        vSQL = IFNULL(:vSQL,'') || 'and cp.removeDate=:cdt_EndOfTime ';

        vSQL = IFNULL(:vSQL,'') || 'and cc.compensationDate >= cp.effectiveStartDate ';

        vSQL = IFNULL(:vSQL,'') || 'And Cc.Compensationdate < Cp.Effectiveenddate ';

        vSQL = IFNULL(:vSQL,'') || 'and leaderpos.removeDate=:cdt_EndOfTime ';

        vSQL = IFNULL(:vSQL,'') ||
        'and cc.compensationDate >= leaderpos.effectiveStartDate ';

        vSQL = IFNULL(:vSQL,'') ||
        'And Cc.Compensationdate < Leaderpos.Effectiveenddate ';

        vSQL = IFNULL(:vSQL,'') || 'And Leaderpos.Name = ''BRT''||Cp.Genericattribute2 ';

        vSQL = IFNULL(:vSQL,'') ||
        'and cc.positionseq <> Leaderpos.ruleElementOwnerSeq ';

        vSQL = IFNULL(:vSQL,'') ||
        'group by cc.payeeseq,cc.positionseq,cp.ruleElementOwnerSeq,cp.payeeSeq,cc.periodSeq,cc.creditTypeSeq,cc.genericAttribute12 ';

        /* ORIGSQL: dbms_output.put_line('sql ' || i || ' IS ' || vSQL); */
        CALL sapdbmtk.sp_dbmtk_buffered_output_writeln('sql ' || IFNULL(TO_VARCHAR(:i),'') || ' IS ' || IFNULL(:vSQL,''));

        /* ORIGSQL: Log('sql ' || i || ' IS ' || vSQL) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('sql '|| IFNULL(TO_VARCHAR(:i),'') || ' IS '|| IFNULL(:vSQL,''));
        BEGIN 
            DECLARE EXIT HANDLER FOR SQLEXCEPTION
                /* ORIGSQL: when others then */
                BEGIN
                    /* ORIGSQL: Log('sql error ' || i || ' IS ' || sqlerrm) */
                    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('sql error '|| IFNULL(TO_VARCHAR(:i),'') || ' IS '|| ::SQL_ERROR_MESSAGE 
                    );  /* ORIGSQL: sqlerrm */
                END;



            /* RESOLVE: Dynamically generated SQL: Dynamically generated SQL, as executed by Execute-Immediate, convert manually */
            /* ORIGSQL: EXECUTE IMMEDIATE vSQL USING i_periodSeq, V_Threshold, v_credittypeseq, cdt_EndOfTime, cdt_EndOfTime; */
            CALL sapdbmtk.sp_dbmtk_prepare_execute_sql(:vSQL, :DBMTK_TMPVAR_STRING_1);
            EXECUTE IMMEDIATE :DBMTK_TMPVAR_STRING_1 USING :i_periodSeq, :v_threshold, :V_Credittypeseq, :cdt_EndOfTime, :cdt_EndOfTime;

            /* ORIGSQL: exception when others then */
        END;

        /* ORIGSQL: COMMIT; */
        COMMIT;

        /* ORIGSQL: Log('18') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('18');
    END FOR;  /* ORIGSQL: end loop; */

    SELECT
        COUNT(*)
    INTO
        v_rec 
    FROM
        (
            /* RESOLVE: Review semantics in source vs. target DBMS: LIMIT/OFFSET without ORDER BY: consistent results not guaranteed */
            SELECT   /* ORIGSQL: (select 1 from sh_query_result Where Component = V_Componentvalue and periodSeq = gv_periodseq LIMIT 1) rownum = 1 */
                1
            FROM
                sh_query_result
            WHERE
                Component = :v_componentValue
                AND periodSeq = :Gv_Periodseq
            LIMIT 1  /* ORIGSQL: rownum = 1 */
        ) AS dbmtk_corrname_2245;

    IF :v_rec <= 0
    THEN
        /* ORIGSQL: comDebugger('DO_QTR', 'No any query result') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('DO_QTR', 'No any query result'); 

        RETURN;
    END IF;

    /* ORIGSQL: Log('19') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('19');

    ----validate with PM_PID_PM
    /*parallel(r,8)*/ 
    /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
    /* ORIGSQL: merge into sh_query_result r using (SELECT cm.payeeSeq, cm.positionSeq, SUM(cm.value) AS aggValue FROM cs_measurement cm where cm.tenantid='AIAS' and Cm.Periodseq In (I_Periodseq, Gv_Preperiodseq1, Gv(...) */
    MERGE INTO sh_query_result AS r 
        USING
        (
            SELECT   /* ORIGSQL: (select cm.payeeSeq, cm.positionSeq, SUM(cm.value) as aggValue from cs_measurement cm where cm.tenantid='AIAS' and Cm.Periodseq In (I_Periodseq, Gv_Preperiodseq1, Gv_Preperiodseq2) AND CM.PROCESSINGUN(...) */
                cm.payeeSeq,
                cm.positionSeq,
                SUM(cm.value) AS aggValue
            FROM
                cs_measurement cm
            WHERE
                cm.tenantid = 'AIAS'
                AND Cm.Periodseq IN
                (:i_periodSeq, :gv_prePeriodSeq1, :gv_prePeriodSeq2)
                AND CM.PROCESSINGUNITSEQ = :Gv_Processingunitseq
                AND cm.name = 'PM_PIB_BN'
            GROUP BY
                cm.payeeSeq, cm.positionSeq
        ) AS m
        ON (r.genericSequence2 = m.payeeSeq
            AND r.genericSequence1 = m.positionSeq
            AND R.Component = :v_componentValue
        AND r.periodSeq = :Gv_Periodseq)

    WHEN MATCHED THEN
        UPDATE
            SET r.genericBoolean1 =
            CASE
                WHEN r.genericNumber2 <= m.aggValue
                THEN 1
                ELSE 0
            END,
            r.genericNumber3 = m.aggValue;

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('19') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('19');

    /* ORIGSQL: Log('20') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('20');

    /* ORIGSQL: Insert / *+ append * / */
    /* ORIGSQL: Insert Into Sh_Sequence select cc.creditSeq, 'CREDITSEQ' as seqType, cc.payeeSeq, cc.positionSeq, i_periodSeq from cs_credit cc, sh_query_result r Where r.Component = V_Componentvalue and r.periodseq (...) */
    INSERT INTO Sh_Sequence
        /* ORIGSQL: select / *+ leading(r,cc) index(cc,AIAS_CREDIT_SH) * / */
        SELECT   /* ORIGSQL: select cc.creditSeq, 'CREDITSEQ' as seqType, cc.payeeSeq, cc.positionSeq, i_periodSeq from cs_credit cc, sh_query_result r Where r.Component = V_Componentvalue and r.periodseq = gv_periodSeq and r.gen(...) */
            cc.creditSeq,
            'CREDITSEQ' AS seqType,
            cc.payeeSeq,
            cc.positionSeq,
            :i_periodSeq
        FROM
            cs_credit cc,
            sh_query_result r
        WHERE
            r.Component = :v_componentValue
            AND r.periodseq = :Gv_Periodseq
            AND r.genericBoolean1 = 1
            AND cc.creditTypeSeq = r.genericSequence4
            AND cc.payeeSeq = r.payeeSeq
            AND cc.positionSeq = r.positionSeq
            AND cc.periodSeq = r.genericSequence3
            AND cc.genericAttribute12 = r.genericAttribute1 -- check agentcode
            AND cc.processingUnitseq = :Gv_Processingunitseq
            AND cc.origintypeid IN ('calculated', 'imported');

    /* ORIGSQL: Log('20 '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('20 '||::ROWCOUNT);  

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('21') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('21');

    /* ORIGSQL: Update / *+index(t OD_CREDIT_CREDITSEQ)* / */
    /* ORIGSQL: Update Cs_Credit t SET Genericboolean3 = 1 Where Processingunitseq = Gv_Processingunitseq and t.Creditseq in (SELECT Sh.Businessseq FROM Sh_Sequence Sh Where Sh.Seqtype = 'CREDITSEQ') ; */
    UPDATE Cs_Credit t
        SET
        /* ORIGSQL: Genericboolean3 = */
        Genericboolean3 = 1
    WHERE
        Processingunitseq = :Gv_Processingunitseq
        AND t.Creditseq  
        IN
        (
            SELECT   /* ORIGSQL: (Select Sh.Businessseq From Sh_Sequence Sh Where Sh.Seqtype = 'CREDITSEQ') */
                Sh.Businessseq
            FROM
                Sh_Sequence Sh
            WHERE
                Sh.Seqtype = 'CREDITSEQ'
        );

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('21') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('21');

    /* ORIGSQL: Log('22') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('22');

    --identify pm seq
    /* ORIGSQL: insert / *+append parllel(sh_sequence)* / */
    /* ORIGSQL: insert into sh_sequence select distinct cm.measurementSeq, 'PMSEQ' as seqType, cm.payeeSeq, cm.positionSeq, cm.periodSeq from cs_measurement cm, sh_query_result r Where cm.tenantid='AIAS' and R.Compon(...) */
    INSERT INTO sh_sequence
        SELECT   /* ORIGSQL: select distinct cm.measurementSeq, 'PMSEQ' as seqType, cm.payeeSeq, cm.positionSeq, cm.periodSeq from cs_measurement cm, sh_query_result r Where cm.tenantid='AIAS' and R.Component = V_Componentvalue a(...) */
            DISTINCT
            cm.measurementSeq,
            'PMSEQ' AS seqType,
            cm.payeeSeq,
            cm.positionSeq,
            cm.periodSeq
        FROM
            cs_measurement cm,
            sh_query_result r
        WHERE
            cm.tenantid = 'AIAS'
            AND R.Component = :v_componentValue
            AND r.periodSeq = :Gv_Periodseq
            AND r.genericBoolean1 = 1
            AND r.objOutputName = cm.name
            AND r.payeeSeq = cm.payeeSeq
            AND r.positionSeq = cm.positionSeq
            AND r.periodSeq = cm.periodSeq
            AND cm.processingUnitseq = :Gv_Processingunitseq;

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('22') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('22');

    /* ORIGSQL: Log('23') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('23'); 

    /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
    /* ORIGSQL: merge into cs_measurement cm using (SELECT r.payeeSeq, r.positionSeq, r.periodSeq, SUM(r.value) AS aggValue, SUM(r.genericNumber1) AS numberOfCredits, s.businessSeq FROM sh_query_result r, sh_sequence(...) */
    MERGE INTO cs_measurement AS cm  
        USING
        (
            SELECT   /* ORIGSQL: (select r.payeeSeq, r.positionSeq, r.periodSeq, SUM(r.value) as aggValue, SUM(r.genericNumber1) as numberOfCredits, s.businessSeq from sh_query_result r, sh_sequence s Where R.Component = V_Componentv(...) */
                r.payeeSeq,
                r.positionSeq,
                r.periodSeq,
                SUM(r.value) AS aggValue,
                SUM(r.genericNumber1) AS numberOfCredits,
                s.businessSeq
            FROM
                sh_query_result r,
                sh_sequence s
            WHERE
                R.Component = :v_componentValue
                AND r.periodseq = :Gv_Periodseq
                AND r.genericBoolean1 = 1
                AND r.positionSeq = s.positionSeq
                AND r.payeeSeq = s.payeeSeq
                AND r.periodSeq = s.periodSeq
                AND s.seqType = 'PMSEQ'
            GROUP BY
                R.payeeSeq, R.positionSeq, R.periodSeq, S.businessSeq
        ) AS t
        ON (t.businessSeq = cm.measurementSeq)

    WHEN MATCHED THEN
        UPDATE
            SET cm.value = t.aggValue, cm.numberOfCredits = t.numberOfCredits;

    /* ORIGSQL: COMMIT; */
    COMMIT;

    /* ORIGSQL: Log('23') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('23');

    /* ORIGSQL: Log('24') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('24');

    /* ORIGSQL: comUpdPMCreditTrace('SP_UPDATE_DO_QUARTERLY') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comUpdPMCreditTrace('SP_UPDATE_DO_QUARTERLY');
    /* Get potentially modified package/session variable 'gv_error' */
    SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR') INTO gv_error FROM SYS.DUMMY ;

    /* ORIGSQL: Log('24') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('24');

    --comDebugger('SP_UPDATE_DO_QUARTERLY','StageHook completed for period ['||i_periodSeq||']'||'at ['||to_timestamp(sysdate)||']');

    /* ORIGSQL: exception when others then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__SP_UPDATE_DO_QUARTERLY') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_TXA_NADOR_EXCEPTION' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__SP_TXA_NADOR_EXCEPTION''...' );
go

/* ORIGSQL: procedure SP_TXA_NADOR_EXCEPTION(i_periodSeq in int) as v_periodStartDate date; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__SP_TXA_NADOR_EXCEPTION
(
    IN i_periodSeq BIGINT     /* ORIGSQL: i_periodSeq IN int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE gv_error VARCHAR(1000); /* package/session variable */
    DECLARE Gv_Setnumbernador BIGINT; /* package/session variable */
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE v_periodStartDate TIMESTAMP;  /* ORIGSQL: v_periodStartDate date; */
    DECLARE V_Periodenddate TIMESTAMP;  /* ORIGSQL: V_Periodenddate Date; */
    DECLARE V_Componentvalue VARCHAR(30) = 'NADOR_EXCEPTION';  /* ORIGSQL: V_Componentvalue Varchar2(30) := 'NADOR_EXCEPTION'; */
    DECLARE V_Fyceventtypeseq BIGINT;  /* ORIGSQL: V_Fyceventtypeseq Int; */
    DECLARE V_Sscpeventtypeseq BIGINT;  /* ORIGSQL: V_Sscpeventtypeseq Int; */
    DECLARE V_FYCTPGIEventtypeSeq BIGINT;  /* ORIGSQL: V_FYCTPGIEventtypeSeq Int; */

    -- version 24 add FY_TPGI for MAS86
    DECLARE vstartdate TIMESTAMP;  /* ORIGSQL: vstartdate date; */
    DECLARE venddate TIMESTAMP;  /* ORIGSQL: venddate date; */

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            gv_error = 'Error [SP_TXA_NADOR_EXCEPTION]: ' || ::SQL_ERROR_MESSAGE || ' - ' ||  /* ORIGSQL: sqlerrm */

            /* RESOLVE: Standard Package call(not converted): 'dbms_utility.format_error_backtrace' not supported, manual conversion required */
            dbms_utility.format_error_backtrace;
            /* Saving modified package/session variable 'gv_error': */ 
            SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR' = :gv_error;

            /* ORIGSQL: comDebugger('SP_TXA_NADOR_EXCEPTION DEBUGGER', 'ERROR' || gv_error) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SP_TXA_NADOR_EXCEPTION DEBUGGER', 'ERROR'|| IFNULL(:gv_error,''));

            /* ORIGSQL: rollback; */
            ROLLBACK;

            /* sapdbmtk: Closing RETURN in exception handler commented out, not supported in HANA */
            --RETURN;
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR') INTO gv_error FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERNADOR') AS BIGINT) INTO Gv_Setnumbernador FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
        /* end of package/session variables */

         

    SELECT
        startDate,
        endDate
    INTO
        v_periodStartDate,
        V_Periodenddate
    FROM
        cs_period
    WHERE
        periodSeq = :i_periodSeq;

    ---clean up temp table
    /*delete from sh_query_result
    where component='NADOR EXCEPTION';
    commit;*/

    /* ORIGSQL: comInitialPartition('NE', v_componentValue, i_periodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__ComInitialpartition('NE', :V_Componentvalue, :i_periodSeq);

    V_Fyceventtypeseq = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('FYC');  /* ORIGSQL: Comgeteventtypeseq('FYC') */

    V_Sscpeventtypeseq = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('SSCP');  /* ORIGSQL: Comgeteventtypeseq('SSCP') */

    -- version 24 add FY_TPGI for MAS86
    V_FYCTPGIEventtypeSeq = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('FYC_TPGI');  /* ORIGSQL: Comgeteventtypeseq('FYC_TPGI') */

    /* ORIGSQL: comDebugger('SQL Performance', 'Stagehook[SP_TXA_NADOR_EXCEPTION]-SQL1 START:' || SYSDATE) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_TXA_NADOR_EXCEPTION]-SQL1 START:'|| CURRENT_TIMESTAMP 
    );  /* ORIGSQL: SYSDATE */

    --identify the vaild data
    --DO NOT check the assignment position from nador exception table is new or old position in the query, because the assignment never reset
    /* ORIGSQL: Log('25') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('25');

    /* ORIGSQL: insert / *+APPEND* / */
    /* ORIGSQL: insert into sh_query_result (component, periodseq, genericSequence1, genericSequence2, genericNumber1, genericDate1, genericAttribute1, genericAttribute2, genericAttribute3) Select distinct V_Componen(...) */
    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.IN_NADOR_PAYEE_SETUP' not found */
    INSERT INTO sh_query_result
        (
            component,
            periodseq,
            genericSequence1,
            genericSequence2,
            genericNumber1,
            genericDate1,
            genericAttribute1,
            genericAttribute2,
            genericAttribute3
        )
        SELECT   /* ORIGSQL: Select distinct V_Componentvalue, i_periodSeq, cs.salestransactionSeq, Cs.Salesorderseq, Gv_Setnumbernador, cs.compensationDate, nd.txt_payee_agy, nd.txt_payee_agt, Cs.Businessunitmap from cs_salestra(...) */
            DISTINCT
            :V_Componentvalue,
            :i_periodSeq,
            cs.salestransactionSeq,
            Cs.Salesorderseq,
            :Gv_Setnumbernador  /* --hard code assignment set number as 3 */, cs.compensationDate,
            nd.txt_payee_agy,
            nd.txt_payee_agt,
            Cs.Businessunitmap
        FROM
            cs_salestransaction cs,
            in_nador_payee_setup nd
        WHERE
            cs.tenantid = 'AIAS'
            AND cs.processingunitseq = :Gv_Processingunitseq
            AND nd.dec_status = 1
            AND nd.txt_payor_agy IS NOT NULL
            AND nd.txt_payor_agt IS NOT NULL
            AND nd.txt_payee_agy IS NOT NULL
            AND nd.txt_payee_agt IS NOT NULL
            AND nd.txt_payor_agy = cs.genericAttribute13
            AND SUBSTRING(nd.txt_payor_agt,6) = cs.genericAttribute12  /* ORIGSQL: substr(nd.txt_payor_agt, 6) */
            AND nd.dte_cycle >= :v_periodStartDate
            AND nd.dte_cycle < :V_Periodenddate
            AND Cs.Compensationdate >= :v_periodStartDate
            AND Cs.Compensationdate < :V_Periodenddate
            AND Cs.Eventtypeseq IN (:V_Fyceventtypeseq, :V_Sscpeventtypeseq, :V_FYCTPGIEventtypeSeq);

    -- version 24
    --and cs.genericdate2 < to_date('12/1/2015', 'mm/dd/yyyy');

    /* ORIGSQL: Log('25 '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('25 '||::ROWCOUNT);  

    /* ORIGSQL: commit; */
    COMMIT;

    --delete the assignment ONLY has NADOR
    --txta deletion is happened in comCleanAssignment

    /*insert \*+APPEND*\
    into Sh_Query_Result
      (component,
           periodseq,
           genericSequence1,
           genericSequence2,
           genericNumber1,
           genericDate1,
           genericAttribute1,
           genericAttribute2,
           genericAttribute3,
           genericattribute11,
           genericattribute12,
           genericattribute13,
           genericattribute14,
           genericattribute15,
           genericattribute16,
           genericsequence4,
           genericnumber3,
           genericsequence5,
       genericnumber5)
      Select distinct V_Componentvalue,
                  i_periodSeq,
                  cs.salestransactionSeq,
                  Cs.Salesorderseq,
                  Gv_Setnumbernador, --hard code assignment set number as 5
                  cs.compensationDate,
                  nd.txt_payee_agy,
                  nd.txt_payee_agt,
                  Cs.Businessunitmap,
                  ts.genericattribute11,
                  ts.genericattribute12,
                  ts.genericattribute13,
                  substr(nd.txt_payee_agt, 6) as genericattribute14,
                  ts.genericattribute15,
                  ts.genericattribute16,
                  ts.unittypeforgenericnumber1 as genericsequence4,
                  ts.genericnumber2 as genericnumber3,
                  ts.unittypeforgenericnumber2 as genericsequence5,
                  ts.genericnumber1 as genericnumber5
    from
         cs_transactionassignment ts
    join in_nador_payee_setup nd
      on 'SGY' || nd.txt_payor_agy = ts.positionname
    join cs_salestransaction cs
      on ts.salestransactionseq = cs.salestransactionseq
     and cs.processingunitseq = gv_processingunitseq
     and nd.dec_status = 1
     and nd.txt_payor_agy IS NOT NULL
     and nd.txt_payor_agt IS NOT NULL
     and nd.txt_payee_agy IS NOT NULL
     and nd.txt_payee_agt IS NOT NULL
     and substr(nd.txt_payor_agt, 6) = ts.genericAttribute14
     and cs.genericdate2 >= to_date('12/1/2015', 'mm/dd/yyyy')
     and ((cs.productname In ('PA', 'HS', 'LF') and
                 ts.genericattribute13 In ('W', 'WC')) or
             (cs.productname In ('CS', 'CL') and
         ts.genericattribute13 = 'C'))
     and nd.dte_cycle >= v_periodStartDate
     and nd.dte_cycle < v_periodEndDate
     And Cs.Compensationdate >= V_Periodstartdate
     And Cs.Compensationdate < V_Periodenddate
     And Cs.Eventtypeseq in (V_Fyceventtypeseq, V_SSCPeventtypeseq)
     where ts.tenantid='AIAS'
     and cs.tenantid='AIAS'
     and ts.processingunitseq = gv_processingunitseq
     and cs.processingunitseq = gv_processingunitseq;
    
    
    
    Log('26 '||SQL%ROWCOUNT);
      commit;
    
    
    
    
    --for revamp begin
    update sh_query_result a
       set a.Genericnumber1 = Gv_Setnumbernador1
     where exists (select 1
              from (select genericSequence1,
                               genericSequence2,
                               genericAttribute1,
                               genericAttribute2
                          from (select t.genericSequence1,
                                           t.genericSequence2,
                                           t.Genericnumber1,
                                           t.genericAttribute1,
                                           t.genericAttribute2,
                                           row_number() over(partition by t.genericSequence1, t.genericSequence2, t.Genericnumber1 order by t.genericAttribute1, t.genericAttribute2) cnt
                                      from sh_query_result t
                                     Where t.Component = V_Componentvalue
             and t.periodSeq = i_periodSeq)
                     where cnt = 2) b
             where a.genericSequence1 = b.genericSequence1
         and a.genericSequence2 = b.genericSequence2
         and a.genericAttribute1 = b.genericAttribute1
     and a.genericAttribute2 = b.genericAttribute2)
     and a.Component = V_Componentvalue
     and a.periodSeq = i_periodSeq;
    Log('26a '||SQL%ROWCOUNT);
    commit;*/
    --for revamp end
    --reset assignment which contain NADOR and AOR asignment   
    /* ORIGSQL: Update Cs_Transactionassignment SET genericAttribute4 = substr(genericAttribute4, 7) where tenantid='AIAS' and processingUnitSeq=gv_processingunitseq and compensationdate>=vstartdate and compensationd(...) */
    UPDATE Cs_Transactionassignment
        SET
        /* ORIGSQL: genericAttribute4 = */
        genericAttribute4 = SUBSTRING(genericAttribute4,7)  /* ORIGSQL: substr(genericAttribute4, 7) */
    FROM
        Cs_Transactionassignment
    WHERE
        tenantid = 'AIAS'
        AND processingUnitSeq = :Gv_Processingunitseq
        AND compensationdate >= :vstartdate
        AND compensationdate <= :venddate
        AND (salestransactionSeq,salesorderSeq)  
        IN
        (
            SELECT   /* ORIGSQL: (select genericSequence1,genericSequence2 from sh_query_result where Component = v_componentValue and periodSeq = gv_periodseq) */
                genericSequence1,
                genericSequence2
            FROM
                sh_query_result
            WHERE
                Component = :V_Componentvalue
                AND periodSeq = :Gv_Periodseq
        )
        AND Genericattribute4 LIKE 'NADOR%';

    /* ORIGSQL: Log('26b '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('26b '||::ROWCOUNT);  

    /* ORIGSQL: commit; */
    COMMIT;

    --Added by Suresh 20180726

    /* ORIGSQL: execute immediate 'truncate table tmp_sh_query_result_1'; */
    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.TMP_SH_QUERY_RESULT_1' not found */

    /* ORIGSQL: truncate table tmp_sh_query_result_1 ; */
    EXECUTE IMMEDIATE 'TRUNCATE TABLE tmp_sh_query_result_1';

    /* ORIGSQL: insert into tmp_sh_query_result_1 Select T1.Genericsequence1 as Salestransactionseq, T1.genericSequence2 as salesorderSeq, T1.Genericnumber1 as Setnumber, T1.Genericdate1 as Compensationdate, 'SGY'|| (...) */
    INSERT INTO tmp_sh_query_result_1
        SELECT   /* ORIGSQL: Select T1.Genericsequence1 as Salestransactionseq, T1.genericSequence2 as salesorderSeq, T1.Genericnumber1 as Setnumber, T1.Genericdate1 as Compensationdate, 'SGY'|| T1.Genericattribute1 as Positionna(...) */
            T1.Genericsequence1 AS Salestransactionseq,
            T1.genericSequence2 AS salesorderSeq,
            T1.Genericnumber1 AS Setnumber,
            T1.Genericdate1 AS Compensationdate,
            'SGY'|| IFNULL(T1.Genericattribute1,'') AS Positionname,
            NULL AS payeeid,
            'NADOR' AS genericAttribute4,
            T1.Genericattribute3 AS Businessunitmap,
            T1.genericattribute11,
            T1.genericattribute12,
            T1.genericattribute13,
            T1.genericattribute14  /* ----agt */, T1.genericattribute15,
            T1.genericattribute16,
            T1.genericnumber5 AS genericnumber1,
            T1.genericsequence4 AS unittypeforgenericnumber1,
            T1.genericnumber3 AS genericnumber2,
            T1.genericsequence5 AS unittypeforgenericnumber2,
            ROW_NUMBER() OVER (PARTITION BY T1.Genericsequence1, 'SGY'|| T1.Genericattribute1 ORDER BY T1.Genericnumber1) AS cnt
        FROM
            Sh_Query_Result T1
        WHERE
            1 = 1
            AND T1.Component = :V_Componentvalue
            AND t1.periodseq = :Gv_Periodseq;

    /* ORIGSQL: commit; */
    COMMIT;

    --end Suresh 20180726

    /* ORIGSQL: Log('27') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('27');

    --for revamp begin
    /* ORIGSQL: Merge / *+ INDEX(Ta AIAS_TXNASSIGN_PNAME) * / */
    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_TRANSACTIONASSIGNMENT' not found */

    /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
    /* ORIGSQL: Merge Into Cs_Transactionassignment Ta Using (SELECT a.Salestransactionseq, a.salesorderSeq, A.SETNUMBER, a.Compensationdate, a.Positionname, a.payeeid, a.genericAttribute4, a.Businessunitmap, a.gener(...) */
    MERGE INTO Cs_Transactionassignment AS Ta
        USING
        (
            /*commented by Suresh 20180726
              with tmp_sh_query_result as
               (Select T1.Genericsequence1 as Salestransactionseq,
                       T1.genericSequence2 as salesorderSeq,
                       T1.Genericnumber1 as Setnumber,
                       T1.Genericdate1 as Compensationdate,
                       'SGY' || T1.Genericattribute1 as Positionname,
                       null as payeeid,
                       'NADOR' as genericAttribute4,
                       T1.Genericattribute3 as Businessunitmap,
                       T1.genericattribute11,
                       T1.genericattribute12,
                       T1.genericattribute13,
                       T1.genericattribute14, ----agt
                       T1.genericattribute15,
                       T1.genericattribute16,
                       T1.genericnumber5 as genericnumber1,
                       T1.genericsequence4 as unittypeforgenericnumber1,
                       T1.genericnumber3 as genericnumber2,
                       T1.genericsequence5 as unittypeforgenericnumber2,
                       row_number() over(partition by T1.Genericsequence1, 'SGY' || T1.Genericattribute1 order by T1.Genericnumber1) cnt
                  From Sh_Query_Result T1
                 Where 1 = 1
                 And T1.Component = V_Componentvalue
             And t1.periodseq = gv_periodSeq) ----tmp_sh_query_result
               */

            SELECT   /* ORIGSQL: (select a.Salestransactionseq, a.salesorderSeq, A.SETNUMBER, a.Compensationdate, a.Positionname, a.payeeid, a.genericAttribute4, a.Businessunitmap, a.genericattribute11, a.genericattribute12, a.generi(...) */
                a.Salestransactionseq,
                a.salesorderSeq,
                A.SETNUMBER,
                a.Compensationdate,
                a.Positionname,
                a.payeeid,
                a.genericAttribute4,
                a.Businessunitmap,
                a.genericattribute11,
                a.genericattribute12,
                a.genericattribute13,
                a.genericattribute14  /* ----agt */, IFNULL(b.genericattribute11, a.genericattribute15) AS genericattribute15,  /* ORIGSQL: nvl(b.genericattribute11, a.genericattribute15) */
                IFNULL(b.genericattribute14, a.genericattribute16) AS genericattribute16,  /* ORIGSQL: nvl(b.genericattribute14, a.genericattribute16) */
                a.genericnumber1,
                a.unittypeforgenericnumber1,
                IFNULL(b.genericnumber1, a.genericnumber2) AS genericnumber2,  /* ORIGSQL: nvl(b.genericnumber1, a.genericnumber2) */
                IFNULL(b.unittypeforgenericnumber1, a.unittypeforgenericnumber2) AS unittypeforgenericnumber2  /* ORIGSQL: nvl(b.unittypeforgenericnumber1, a.unittypeforgenericnumber2) */
                /*commented by Suresh 20180726
                from (select * from tmp_sh_query_result where cnt = 1) a
                left join (select * from tmp_sh_query_result where cnt = 2) b*/ 
            FROM
                (
                    SELECT   /* ORIGSQL: (select * from tmp_sh_query_result_1 where cnt = 1) */
                        *
                    FROM
                        tmp_sh_query_result_1
                    WHERE
                        cnt = 1
                ) AS a 
            LEFT OUTER JOIN
                (
                    SELECT   /* ORIGSQL: (select * from tmp_sh_query_result_1 where cnt = 2) */
                        *
                    FROM
                        tmp_sh_query_result_1
                    WHERE
                        cnt = 2
                ) AS b
                ON a.salestransactionseq = b.salestransactionseq
        ) AS R
        ON (Ta.Salestransactionseq = R.Salestransactionseq
        AND ta.positionName = r.Positionname)   /* RESOLVE: Manual edits required: MERGE statement: WHEN NOT MATCHED cannot precede WHEN MATCHED: swap manually */
    WHEN NOT MATCHED THEN
        INSERT
            (ta.tenantid, Ta.Salestransactionseq,
                Ta.Salesorderseq,
                Ta.Setnumber,
                Ta.Compensationdate,
                Ta.Positionname,
                Ta.Payeeid,
                Ta.Genericattribute4,
                Ta.genericattribute11,
                Ta.genericattribute12,
                Ta.genericattribute13,
                Ta.genericattribute14,
                Ta.genericattribute15,
                Ta.genericattribute16,
                Ta.genericnumber1,
                Ta.unittypeforgenericnumber1,
                Ta.genericnumber2,
                Ta.unittypeforgenericnumber2,
            TA.processingUnitSeq)
        VALUES
            ('AIAS', R.Salestransactionseq,
                R.Salesorderseq,
                R.SETNUMBER,
                R.Compensationdate,
                R.Positionname,
                R.Payeeid,
                R.Genericattribute4,
                R.genericattribute11,
                R.genericattribute12,
                R.genericattribute13,
                R.genericattribute14,
                R.genericattribute15,
                R.genericattribute16,
                R.genericnumber1,
                R.unittypeforgenericnumber1,
                R.genericnumber2,
                R.unittypeforgenericnumber2,
            :Gv_Processingunitseq)
    WHEN MATCHED THEN
        --why need to merge ta.ga4 with r.ga4, beacasue need to accommodate with piaor stagehook
        UPDATE SET Ta.Genericattribute4 = IFNULL(r.Genericattribute4,'') ||
            MAP(Ta.Genericattribute4, NULL, '', '_') ||  /* ORIGSQL: Decode(Ta.Genericattribute4, Null, '', '_') */
            IFNULL(Ta.Genericattribute4, '');,  /* ORIGSQL: Nvl(Ta.Genericattribute4, '') */
    Ta.Compensationdate,
    Ta.Positionname,
    Ta.Payeeid,
    Ta.Genericattribute4,
    Ta.genericattribute11,
    Ta.genericattribute12,
    Ta.genericattribute13,
    Ta.genericattribute14,
    Ta.genericattribute15,
    Ta.genericattribute16,
    Ta.genericnumber1,
    Ta.unittypeforgenericnumber1,
    Ta.genericnumber2,
    Ta.unittypeforgenericnumber2,
TA.processingUnitSeq)
VALUES
('AIAS', R.Salestransactionseq,
    R.Salesorderseq,
    R.SETNUMBER,
    R.Compensationdate,
    R.Positionname,
    R.Payeeid,
    R.Genericattribute4,
    R.genericattribute11,
    R.genericattribute12,
    R.genericattribute13,
    R.genericattribute14,
    R.genericattribute15,
    R.genericattribute16,
    R.genericnumber1,
    R.unittypeforgenericnumber1,
    R.genericnumber2,
    R.unittypeforgenericnumber2,
:Gv_Processingunitseq)
    WHEN MATCHED THEN
        --why need to merge ta.ga4 with r.ga4, beacasue need to accommodate with piaor stagehook
        /* RESOLVE: Syntax not supported in target DBMS: UPDATE on derived table not supported in HANA; rewrite statement */
        UPDATE
            SET
            Ta.Genericattribute4 = IFNULL(r.Genericattribute4,'') ||
            MAP(Ta.Genericattribute4, NULL, '', '_') ||  /* ORIGSQL: Decode(Ta.Genericattribute4, Null, '', '_') */
            IFNULL(Ta.Genericattribute4, '');  /* ORIGSQL: Nvl(Ta.Genericattribute4, '') */

    /* ORIGSQL: Log('27 '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('27 '||::ROWCOUNT);  

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Comdebugger('SQL Performance', 'Stagehook[SP_TXA_NADOR_EXCEPTION]-SQL5 START:' || Sysdate) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_TXA_NADOR_EXCEPTION]-SQL5 START:'|| CURRENT_TIMESTAMP 
    );  /* ORIGSQL: Sysdate */

    --update txn EB2   

    /* ORIGSQL: update cs_gaSalestransaction SET genericBoolean2 = 1 where salestransactionSeq in (SELECT genericSequence1 FROM sh_query_result Where Component = V_Componentvalue and periodSeq = gv_periodseq) AND PAG(...) */
    UPDATE cs_gaSalestransaction
        SET
        /* ORIGSQL: genericBoolean2 = */
        genericBoolean2 = 1
    FROM
        cs_gaSalestransaction
    WHERE
        salestransactionSeq  
        IN
        (
            SELECT   /* ORIGSQL: (select genericSequence1 from sh_query_result Where Component = V_Componentvalue and periodSeq = gv_periodseq) */
                genericSequence1
            FROM
                sh_query_result
            WHERE
                Component = :V_Componentvalue
                AND periodSeq = :Gv_Periodseq
        )
        AND PAGENUMBER = 0;

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('28') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('28');

    /* ORIGSQL: exception when others then */
END;

/**
1.Modeified at 2014/04/22
Desc: Change the logic align with PI fsd v0.89
2.Modified at 2014/7/19
Desc: Remove the classcode checking, once the crossover win, then it must be crossover
3.Moditied at 2014/8/1
Desc: Include orphan policy case
4.Modified at  2014/8/15
Desc: Included ORYC transaction requirement
5.Modified at 2014/11/13
Desc: include spin off start date chk
6.Modified at 2016/01/13
Desc: include AOR demote case and setup table handling
*/
/*  procedure SP_TXA_PIAOR (i_periodSeq in int) as
     v_periodStartDate date;
     v_periodEndDate date;
     v_cutOverDate date;
     v_positionName varchar2(100);
     V_Crossoverflag Int:=0;
     v_ConstantCrossoverDate date;
     v_AgyDistTrxn R_AgyDistTrxn;
     v_ga13 varchar2(30);
     V_Componentvalue_Pi Varchar2(10):='PI';
     v_componentValue_aor varchar2(10):='AOR';
     V_HRYCSEQ int;
     vSQL varchar2(4000);
  begin

    ---clean up temp table
    \*delete from sh_query_result
    where component in ( 'PI' , 'AOR');
    commit;*\


Log('30 Pre Call init partition PI');
    comInitialPartition('PI',v_componentValue_pi,i_periodSeq);
Log('30 Pre Call init partition AOR');
    comInitialPartition('AOR',v_componentValue_aor,i_periodSeq);
commit;

\*Arjun adding this below*\

Log('30 Pre Build index Start');
    execute immediate ('alter index SH_QUERY_RESULT_IDX2 rebuild parallel nologging');
Log('30 Pre Build index Done');
    --cut over date to determine what position table need to be used
    --before cutoverdate, use AIA tbl_agent_move
    --after/on cutoverdate, use cs_position
    begin
      select NVL(refDateValue,to_date('1/1/2000','mm/dd/yyyy'))
      into v_cutOverDate
      From Sh_Reference
      Where Refid='CUTOVERDATE';
    Exception WHEN NO_DATA_FOUND Then
      v_cutOverDate:=to_date('11/30/2013','mm/dd/yyyy');
    end;

    begin
      select NVL(refDateValue,to_date('1/1/2000','mm/dd/yyyy'))
      into v_ConstantCrossoverDate
      From Sh_Reference
      Where Refid='CUTOVERISSUEDATE';
    Exception WHEN NO_DATA_FOUND Then
      v_ConstantCrossoverDate:=to_date('1/1/2005','mm/dd/yyyy');
    end;


    --get period startDate, endDate

    dbms_output.put_line('PSEQ is ' || i_periodSeq);
    select startDate,endDate
    into v_periodStartDate,v_periodEndDate
    from cs_period
    where periodSeq=i_periodSeq
 and removedate=cdt_EndofTime;



    ----DBMS_OUTPUT.put_line('start pi/aor'||v_periodStartDate||'--'||v_periodEndDate||'---eventtypeid'||v_eventTypeSeq);

    \*
    the piaor store proc is seperated into 2 portion,
    1st for policy issue before cutover date, need to look into aia custom table
    2nd for policy issue on/after cutover date, need look into ODS position tables
    *\
Log('30 Pre Call comConvertAgentRole');

    --look into aia customer table begin
   -- comConvertAgentRole(i_periodSeq);

    comDebugger('SQL Performance','Stagehook[SP_TXA_PIAOR]-SQL1 START:'||SYSDATE);

--step1, look into aia custom table with txn.GA12+13+issuedate



\*
 for c_txn in (select x.subpartition_name
    
           from ALL_SUBPART_COL_STATISTICS x
    
    join (Select * from all_tab_subpartitions) z
    on z.table_name=x.table_name and z.subpartition_name=x.subpartition_name
    where x.table_name='SH_QUERY_RESULT' and x.column_name='PERIODSEQ'
     and utl_Raw.cast_to_number(x.high_Value) = gv_periodseq)
    
     loop
    
      DBMS_STATS.GATHER_TABLE_STATS (
          ownname => 'AIASEXT',
          tabname => 'SH_QUERY_RESULT'
          ,partname => c_txn.subpartition_name
      , estimate_percent => dbms_stats.AUTO_SAMPLE_SIZE );
    
    
     Log('Gather Stats before 30 loop ');
    
     end loop;
    *\
        Log('30');
    
    \**
        create table aia_x tablespace tallydata
        as select st.*,et.eventtypeid,
            'SGY'||agy.agencyCode wAgency,
            'SGY'||ldr.agencyCode wAgencyLeader,
            ldr.agentRole wAgyLdrTitle,
            Ldr.District As Wagyldrdistrict,
            agy.Classcode As Wagtclass, --add by nelson
            'SGT'||ldr.AGENTCODE wAgyLdrCde
          from cs_salestransaction st,
               cs_eventtype et,
               sh_agent_role agy,
               Sh_Agent_Role Ldr
         where et.tenantid='AIAS' and ST.PROCESSINGUNITSEQ=1
     AND st.compensationDate>=sysdtae
     AND st.COMPENSATIONDATE < sysdtae
     AND st.tenantid='AIAS'
     and st.businessunitmap in (1,16) --add by nelson
     and et.datatypeSeq=st.eventTypeSeq
     And Et.Removedate= Cdt_Endoftime
     and et.eventTypeId in ('RYC','API','IFYC','FYC', 'SSCP')
     and st.genericattribute12=agy.agentCode
     and agy.effectiveStartDate<=st.genericdate2
     and agy.effectiveEndDate>st.genericdate2
     and agy.agencyLeader=ldr.AGENTCODE
     and ldr.effectiveStartDate<=st.genericdate2
     and ldr.effectiveEndDate>st.genericdate2
     and st.genericAttribute17 ='O'  -- non reassignment transaction
     And St.Genericdate2<=sysdate and 1=0
       **\
    
        execute immediate 'truncate table aia_x';
        insert \*+ APPEND *\
        into aia_x
            select \*+ parallel(8)  *\ st.*,et.eventtypeid,
                'SGY'||agy.agencyCode wAgency,
                'SGY'||ldr.agencyCode wAgencyLeader,
                ldr.agentRole wAgyLdrTitle,
                Ldr.District As Wagyldrdistrict,
                agy.Classcode As Wagtclass, --add by nelson
                'SGT'||ldr.AGENTCODE wAgyLdrCde
              from cs_salestransaction st,
                   cs_eventtype et,
                   sh_agent_role agy,
                   Sh_Agent_Role Ldr
             where et.tenantid='AIAS' and ST.PROCESSINGUNITSEQ=GV_PROCESSINGUNITSEQ
     AND st.compensationDate>=v_periodStartDate
     AND st.COMPENSATIONDATE < v_periodEndDate
     AND st.tenantid='AIAS'
     and st.businessunitmap in (1,16) --add by nelson
     and et.datatypeSeq=st.eventTypeSeq
     And Et.Removedate= Cdt_Endoftime
     and et.eventTypeId in ('RYC','API','IFYC','FYC', 'SSCP')
     and st.genericattribute12=agy.agentCode
     and agy.effectiveStartDate<=st.genericdate2
     and agy.effectiveEndDate>st.genericdate2
     and agy.agencyLeader=ldr.AGENTCODE
     and ldr.effectiveStartDate<=st.genericdate2
     and ldr.effectiveEndDate>st.genericdate2
     and st.genericAttribute17 ='O'  -- non reassignment transaction
     And St.Genericdate2<=V_Cutoverdate;
        commit;
    
        For C_Txn In (
                select \*+ parallel(8) leading(x) *\
                x.genericAttribute2,  --add by nelson txn code
                x.genericAttribute14,
                x.Genericattribute17,
                x.Businessunitmap,
                x.Productname,
                x.Genericattribute13,
                x.Compensationdate,
                x.SALESORDERSEQ,
                x.Salestransactionseq,
                x.genericDate2,
                x.eventtypeid,
                x.wAgency,
                x.wAgencyLeader,
                x.wAgyLdrTitle,
                'SGY'||x.Wagyldrdistrict As Wagyldrdistrict,
                x.Wagtclass,
                'SGY'||curDis.Genericattribute3 as CurDistrict,
                tt.name as LdrCurRole,
                x.wAgyLdrCde ,
                 nvl((select stp.txtagt from  In_Pi_Aor_Setup stp
                         where 'SGT'||to_number(stp.txtagt) =  x.wAgyLdrCde
                 and stp.dtecycle = v_periodEndDate-1
                 and stp.txttype in ('C','D')
         and rownum =1),'X') as setup
                from  aia_x  x,
                ---version 5 fix incorrect DMcode
                        cs_position agt,
                        cs_position curDis,
                        cs_position LdrCurRole ,
                        cs_title tt
                where curDis.tenantid='AIAS'
         and LdrCurRole.tenantid='AIAS'
         and tt.tenantid='AIAS'
         and 'SGT'||x.genericattribute12=agt.name
         and agt.removeDate=cdt_EndofTime
         AND agt.effectiveStartDate<=v_periodEndDate -1
         AND agt.effectiveEndDate > v_periodEndDate-1
         and 'SGY'||agt.genericattribute1 = curDis.Name
         and curDis.removeDate=cdt_EndofTime
         AND curDis.effectiveStartDate<=v_periodEndDate -1
         AND curDis.effectiveEndDate > v_periodEndDate-1
         and x.wAgyLdrCde = LdrCurRole.name
         and LdrCurRole.removeDate=cdt_EndofTime
         AND LdrCurRole.effectiveStartDate<=v_periodEndDate -1
         AND LdrCurRole.effectiveEndDate > v_periodEndDate-1
         and LdrCurRole.titleseq = tt.ruleelementownerseq
         and tt.removedate = cdt_EndofTime
         and tt.effectiveenddate  = cdt_EndofTime
        
                --add by nelson end
        )
        loop
          V_Agydisttrxn.Wagency:=C_Txn.wAgency;
          V_Agydisttrxn.Wagencyleader:=C_Txn.wAgencyLeader;
          V_Agydisttrxn.wAgyLdrTitle:=c_txn.wAgyLdrTitle;
          V_Agydisttrxn.Wagyldrdistrict:=C_Txn.Wagyldrdistrict;
          V_Agydisttrxn.Wagtclass:=C_Txn.Wagtclass;
          V_Agydisttrxn.CurDistrict:=c_txn.CurDistrict;  -- add by Nelson
          V_Agydisttrxn.LdrCurRole:=c_txn.LdrCurRole;  -- add by Nelson
          V_Agydisttrxn.wAgyLdrCde:=c_txn.wAgyLdrCde;  -- add by Nelson
          V_Agydisttrxn.setup:=c_txn.setup;  -- add by Nelson
          V_Agydisttrxn.txnCode:=c_txn.genericAttribute2; -- add by Nelson
          V_Agydisttrxn.policyIssueDate:=c_txn.genericDate2;
    
          V_Agydisttrxn.Salestransactionseq:=C_Txn.Salestransactionseq;
          V_Agydisttrxn.SALESORDERSEQ:=C_Txn.SALESORDERSEQ;
          V_Agydisttrxn.Compensationdate:=C_Txn.Compensationdate;
          V_Agydisttrxn.Commissionagy:='SGY'||C_Txn.Genericattribute13;
          V_Agydisttrxn.Runningtype:='Before Cutover - GA17=O';
          V_Agydisttrxn.eventtypeid:=C_Txn.eventtypeid;
          V_Agydisttrxn.Productname:=C_Txn.Productname;
          V_Agydisttrxn.Businessunitmap:=C_Txn.Businessunitmap;
          V_Agydisttrxn.Orphanpolicy:=C_Txn.Genericattribute17;
          V_Agydisttrxn.Periodseq:=I_Periodseq;
          V_Agydisttrxn.TxnClassCode:=c_txn.genericAttribute14;
              ----DBMS_OUTPUT.put_line('start loop'||v_maxSetNumber);
    
    
          if C_Txn.Salestransactionseq=14636699070356340  then
          Comtransferpiaor_debug(V_Agydisttrxn);
          else
          comTransferPIAOR(V_Agydisttrxn) ;
          end if;
    
    
    
        end loop; -- end c_txn
    
        Log('30');
    
        commit;
    
    
    
    \*
     create table aia_X1 tablespace tallydata as
        select *+ parallel(8)  * st.*,et.eventtypeid,
            'SGY'||agy.agencyCode wAgency,
            'SGY'||ldr.agencyCode wAgencyLeader,
            ldr.agentRole wAgyLdrTitle,
            Ldr.District As Wagyldrdistrict,
            agy.Classcode As Wagtclass,--  add by Nelson
            'SGT'||ldr.Agentcode wAgyLdrCde  -- add by Nelson
          from cs_salestransaction st,
               cs_eventtype et,
               Sh_Agent_Role Agy,
               Sh_Agent_Role Ldr
         where 1=0 and ST.PROCESSINGUNITSEQ=1
     AND st.compensationDate>=sysdate
     AND st.COMPENSATIONDATE < sysdate
     and st.businessunitmap in (1,16) --add by nelson
     and et.datatypeSeq=st.eventTypeSeq
     And Et.Removedate= sysdate
     and et.eventTypeId in ('RYC','API','IFYC','FYC', 'SSCP')
     and st.genericattribute12=agy.agentCode
     and agy.effectiveStartDate<=st.genericdate2
     and agy.effectiveEndDate>st.genericdate2
     And Agy.Agencyleader=Ldr.Agentcode
     and agy.agencycode=ldr.agencycode
     And Ldr.Effectiveenddate<=St.Genericdate2 -- need to consider the version end date is same as issue date
     And Ldr.EffectiveStartdate = (Select Max(Effectivestartdate)
                From Sh_Agent_Role T Where Ldr.Agentcode=T.Agentcode And Ldr.Agencycode=T.Agencycode
         And T.Effectiveenddate<=St.Genericdate2
            )
     and st.genericAttribute17 ='O'  -- non reassignment transaction
     And St.Genericdate2<=V_Cutoverdate
     And Not Exists (Select 1 From Sh_Query_Result R
                                 Where Component In ('PI','AOR') And Periodseq=Gv_Periodseq And St.Salestransactionseq=R.Genericsequence1)
    *\
      execute immediate 'truncate table aia_x1';
      insert \*+ append *\ into aia_x1
          select \*+ parallel(8) materialize *\ st.*,et.eventtypeid,
              'SGY'||agy.agencyCode wAgency,
              'SGY'||ldr.agencyCode wAgencyLeader,
              ldr.agentRole wAgyLdrTitle,
              Ldr.District As Wagyldrdistrict,
              agy.Classcode As Wagtclass,--  add by Nelson
              'SGT'||ldr.Agentcode wAgyLdrCde  -- add by Nelson
            from cs_salestransaction st,
                 cs_eventtype et,
                 Sh_Agent_Role Agy,
                 Sh_Agent_Role Ldr
           where ST.PROCESSINGUNITSEQ=GV_PROCESSINGUNITSEQ and st.tenantid='AIAS'
     AND st.compensationDate>=v_periodStartDate
     AND st.COMPENSATIONDATE < v_periodEndDate
     and st.businessunitmap in (1,16) --add by nelson
     and et.datatypeSeq=st.eventTypeSeq
     And Et.Removedate= Cdt_Endoftime
     and et.eventTypeId in ('RYC','API','IFYC','FYC', 'SSCP')
     and st.genericattribute12=agy.agentCode
     and agy.effectiveStartDate<=st.genericdate2
     and agy.effectiveEndDate>st.genericdate2
     And Agy.Agencyleader=Ldr.Agentcode
     and agy.agencycode=ldr.agencycode
     And Ldr.Effectiveenddate<=St.Genericdate2 -- need to consider the version end date is same as issue date
     And Ldr.EffectiveStartdate = (Select Max(Effectivestartdate)
                  From Sh_Agent_Role T Where Ldr.Agentcode=T.Agentcode And Ldr.Agencycode=T.Agencycode
         And T.Effectiveenddate<=St.Genericdate2
              )
     and st.genericAttribute17 ='O'  -- non reassignment transaction
     And St.Genericdate2<=V_Cutoverdate
     And Not Exists (Select 1 From Sh_Query_Result R
                                   Where Component In ('PI','AOR') And Periodseq=Gv_Periodseq And St.Salestransactionseq=R.Genericsequence1);
    
    
    
      Log('31');
    commit;
      For C_Txn In (
           select \*+ parallel(8) leading(x1) *\
                x.genericAttribute2,  --add by nelson txn code
                x.genericAttribute14,
                x.Genericattribute17,
                x.Businessunitmap,
                x.Productname,
                x.Genericattribute13,
                x.Compensationdate,
                x.SALESORDERSEQ,
                x.Salestransactionseq,
                x.genericDate2,
                x.eventtypeid,
                x.wAgency,
                x.wAgencyLeader,
                x.wAgyLdrTitle,
                'SGY'||x.Wagyldrdistrict As Wagyldrdistrict,
                x.Wagtclass,
                'SGY'||curDis.Genericattribute3 as CurDistrict,
                tt.name as LdrCurRole,
                x.wAgyLdrCde ,
                 nvl((select stp.txtagt from  In_Pi_Aor_Setup stp
                         where 'SGT'||to_number(stp.txtagt) =  x.wAgyLdrCde
                 and stp.dtecycle = v_periodEndDate-1
                 and stp.txttype in ('C','D')
         and rownum =1),'X') as setup
             from aia_x1 x,
             ---version 5 fix incorrect DMcode
             cs_position agt,
             cs_position curDis,
             cs_position LdrCurRole ,
             cs_title tt
             where  'SGT'||x.genericattribute12=agt.name
         and agt.removeDate=cdt_EndofTime
         AND agt.effectiveStartDate<=v_periodEndDate -1
         AND agt.effectiveEndDate > v_periodEndDate-1
         and 'SGY'||agt.genericattribute1 = curDis.Name
         and curDis.removeDate=cdt_EndofTime
         AND curDis.effectiveStartDate<= v_periodEndDate-1
         AND curDis.effectiveEndDate> v_periodEndDate-1
         and x.wAgyLdrCde = LdrCurRole.name
         and LdrCurRole.removeDate=cdt_EndofTime
         AND LdrCurRole.effectiveStartDate<=v_periodEndDate -1
         AND LdrCurRole.effectiveEndDate > v_periodEndDate-1
         and LdrCurRole.titleseq = tt.ruleelementownerseq
         and tt.removedate = cdt_EndofTime
         and tt.effectiveenddate  = cdt_EndofTime
        
             --add by nelson end
        )
    
        loop
    
          V_Agydisttrxn.Wagency:=C_Txn.wAgency;
          V_Agydisttrxn.Wagencyleader:=C_Txn.wAgencyLeader;
          V_Agydisttrxn.wAgyLdrTitle:=c_txn.wAgyLdrTitle;
          V_Agydisttrxn.Wagyldrdistrict:=C_Txn.Wagyldrdistrict;
          V_Agydisttrxn.Wagtclass:=C_Txn.Wagtclass;
          V_Agydisttrxn.policyIssueDate:=c_txn.genericDate2;
          V_Agydisttrxn.CurDistrict:=c_txn.CurDistrict;  -- add by Nelson
          V_Agydisttrxn.LdrCurRole:=c_txn.LdrCurRole;  -- add by Nelson
          V_Agydisttrxn.wAgyLdrCde:=c_txn.wAgyLdrCde;  -- add by Nelson
          V_Agydisttrxn.setup:=c_txn.setup;  -- add by Nelson
          V_Agydisttrxn.txnCode:=c_txn.genericAttribute2; -- add by Nelson
    
          V_Agydisttrxn.Salestransactionseq:=C_Txn.Salestransactionseq;
          V_Agydisttrxn.SALESORDERSEQ:=C_Txn.SALESORDERSEQ;
          V_Agydisttrxn.Compensationdate:=C_Txn.Compensationdate;
          V_Agydisttrxn.Commissionagy:='SGY'||C_Txn.Genericattribute13;
          V_Agydisttrxn.Runningtype:='Before Cutover - GA17=O - Ealier district';
          V_Agydisttrxn.eventtypeid:=C_Txn.eventtypeid;
          V_Agydisttrxn.Productname:=C_Txn.Productname;
          V_Agydisttrxn.Businessunitmap:=C_Txn.Businessunitmap;
          V_Agydisttrxn.Orphanpolicy:=C_Txn.Genericattribute17;
          V_Agydisttrxn.Periodseq:=I_Periodseq;
          V_Agydisttrxn.TxnClassCode:=c_txn.genericAttribute14;
    
    
          ----DBMS_OUTPUT.put_line('start loop'||v_maxSetNumber);
    
          if C_Txn.Salestransactionseq=14636699070356340  then
          Comtransferpiaor_debug(V_Agydisttrxn);
          else
          comTransferPIAOR(V_Agydisttrxn) ;
          end if;
    
    
        end loop; -- end c_txn
    
        commit;
    
    
    
        Log('31');
    
      --look into aia customer table ga12+13+ lastest version end
    
        Log('32');
    
      --            vParName := segmentationutils.segmentname('CS_SalesTransaction', pProcessingUnitSeq, v_periodEndDate);
    
      --look into ods table start
       for c_txn in (
           with x as (
                select \*+ parallel(8) materialize *\ st.*,et.eventtypeid,
                  'SGY'||Agy.Genericattribute1 Wagency, -- add by nelson
                  'SGY'||Ldr.Genericattribute1 Wagencyleader, --add by nelson
                  Ldr.genericAttribute11 wAgyLdrTitle, --add by nelson
                  Ldr.Genericattribute3 As Wagyldrdistrict, --add by nelson
                  Agy.Genericattribute4 As Wagtclass, --add by nelson
                  Ldr.Genericdate5 As Spinstartdate, --add by nelson
                  Ldr.genericDate6 as spinEndDate, --add by nelson
                  Ldr.name wAgyLdrCde -- add by Nelson
                  from cs_salestransaction st,
                       cs_eventtype et,
                       Cs_Position Agy,
                       Cs_Position Ldr -- add by Nelson
                 Where ST.tenantid='AIAS'
             and et.tenantid='AIAS'
             and Agy.tenantid='AIAS'
             and Ldr.tenantid='AIAS'
             and ST.PROCESSINGUNITSEQ=GV_PROCESSINGUNITSEQ
             AND st.compensationDate>=v_periodStartDate
             AND st.COMPENSATIONDATE < v_periodEndDate
             and st.businessunitmap in (1,16) --add by nelson
             and et.datatypeSeq=st.eventTypeSeq
             And Et.Removedate= Cdt_Endoftime
             and et.eventTypeId in ('RYC','API','IFYC','FYC', 'SSCP')
             and 'SGT'||st.genericattribute12=agy.name -- add by Nelson
             and agy.removeDate=cdt_EndofTime
             and agy.effectiveStartDate<=st.genericDate2
             and agy.effectiveEndDate>st.genericDate2
             And Ldr.Genericattribute11 In ('FSD','FSAD','AM','FSM') -- add by nelson
             and 'SGT'||Agy.Genericattribute2 = Ldr.name  --add by nelson
             and Ldr.removeDate=cdt_EndofTime --add by nelson
             and Ldr.effectiveStartDate<=st.genericDate2 --add by nelson
             and Ldr.effectiveEndDate>st.genericDate2 --add by nelson
             And (St.Genericattribute17='O'
                 or (st.genericAttribute17<>'O' and ST.Genericattribute14 in ('10','48'))
                    )
             And St.Genericdate2>V_Cutoverdate
             and st.genericdate2 <  to_date('12/01/2015', 'mm/dd/yyyy')
             )
             --add by nelson start
             select \*+ parallel(8) *\
             x.genericAttribute2,  --add by nelson txn code
             x.genericAttribute14,
             x.Genericattribute17,
             x.Businessunitmap,
             x.Productname,
             x.Genericattribute13,
             x.Compensationdate,
             x.SALESORDERSEQ,
             x.Salestransactionseq,
             x.genericDate2,
             x.eventtypeid,
             x.wAgency ,
             x.wAgencyLeader,
             x.wAgyLdrTitle ,
             'SGY'||x.Wagyldrdistrict as Wagyldrdistrict,
             x.Wagtclass ,
             x.wAgyLdrCde ,
             x.Spinstartdate,
             x.spinEndDate,
             'SGY'||curDis.Genericattribute3 as CurDistrict,
             tt.name as LdrCurRole,
                 nvl((select stp.txtagt from  In_Pi_Aor_Setup stp
                         where 'SGT'||to_number(stp.txtagt) =  x.wAgyLdrCde
                 and stp.dtecycle = v_periodEndDate-1
                 and stp.txttype in ('C','D')
         and rownum =1),'X') as setup
             from x,
             ---version 5 fix incorrect DMcode
             cs_position agt,
             cs_position curDis,
             cs_position LdrCurRole ,
             cs_title tt
             where  'SGT'||x.genericattribute12=agt.name
         and agt.removeDate=cdt_EndofTime
         AND agt.effectiveStartDate<=v_periodEndDate -1
         AND agt.effectiveEndDate > v_periodEndDate-1
         and 'SGY'||agt.genericattribute1 = curDis.Name
         and curDis.removeDate=cdt_EndofTime
         AND curDis.effectiveStartDate<=v_periodEndDate -1
         AND curDis.effectiveEndDate > v_periodEndDate-1
         and x.wAgyLdrCde = LdrCurRole.name
         and LdrCurRole.removeDate=cdt_EndofTime
         AND LdrCurRole.effectiveStartDate<=v_periodEndDate -1
         AND LdrCurRole.effectiveEndDate > v_periodEndDate-1
         and LdrCurRole.titleseq = tt.ruleelementownerseq
         and tt.removedate = cdt_EndofTime
         and tt.effectiveenddate  = cdt_EndofTime
         and curDis.tenantid='AIAS'
         and LdrCurRole.tenantid='AIAS'
         and tt.tenantid='AIAS'
        
             --add by nelson end
        )
    
        loop
    
    
        ----DBMS_OUTPUT.put_line('start loop'||v_maxSetNumber);
    
          V_Agydisttrxn.Wagency:=C_Txn.wAgency;
          V_Agydisttrxn.Wagencyleader:=C_Txn.wAgencyLeader;
          V_Agydisttrxn.wAgyLdrTitle:=c_txn.wAgyLdrTitle;
          V_Agydisttrxn.Wagyldrdistrict:=C_Txn.Wagyldrdistrict;
          V_Agydisttrxn.Wagtclass:=C_Txn.Wagtclass;
          V_Agydisttrxn.policyIssueDate:=c_txn.genericDate2;
          V_Agydisttrxn.CurDistrict:=c_txn.CurDistrict;  -- add by Nelson
          V_Agydisttrxn.LdrCurRole:=c_txn.LdrCurRole;  -- add by Nelson
          V_Agydisttrxn.wAgyLdrCde:=c_txn.wAgyLdrCde;  -- add by Nelson
          V_Agydisttrxn.setup:=c_txn.setup;  -- add by Nelson
          V_Agydisttrxn.txnCode:=c_txn.genericAttribute2; -- add by Nelson
    
          V_Agydisttrxn.Salestransactionseq:=C_Txn.Salestransactionseq;
          V_Agydisttrxn.SALESORDERSEQ:=C_Txn.SALESORDERSEQ;
          V_Agydisttrxn.Compensationdate:=C_Txn.Compensationdate;
          V_Agydisttrxn.Commissionagy:='SGY'||C_Txn.Genericattribute13;
          V_Agydisttrxn.Runningtype:='After Cutover - GA17='||c_txn.genericattribute17;
          V_Agydisttrxn.eventtypeid:=C_Txn.eventtypeid;
          V_Agydisttrxn.Productname:=C_Txn.Productname;
          V_Agydisttrxn.Businessunitmap:=C_Txn.Businessunitmap;
          V_Agydisttrxn.Orphanpolicy:='O';
          V_Agydisttrxn.ActualOrphanPolicy:=c_txn.genericAttribute17;
          V_Agydisttrxn.Periodseq:=I_Periodseq;
          V_Agydisttrxn.Spinstartdate:=C_Txn.Spinstartdate;
          V_Agydisttrxn.SpinEnddate:=C_Txn.SpinEnddate;
          V_Agydisttrxn.Spindaterange:=Ceil(Months_Between(c_txn.genericDate2,C_Txn.Spinstartdate)/12);
          V_Agydisttrxn.Txnclasscode:=C_Txn.Genericattribute14;
    
          if C_Txn.Salestransactionseq=14636699070356340  then
          Comtransferpiaor_debug(V_Agydisttrxn);
          else
          comTransferPIAOR(V_Agydisttrxn) ;
          end if;
    
    
        end loop; -- end c_txn
    
    
    
      commit;
      Log('32');
    
      --look into ods table end
    
        comDebugger('SQL Performance','Stagehook[SP_TXA_PIAOR]-SQL4 START:'||SYSDATE);
    
     commit;
    
    
    
      Log('33');
    
      Log('33 New');
    
    
      execute immediate 'truncate table tmp_x_St';
    
      Log('33 Truncate done');
    
     insert \*+ APPEND *\ into tmp_x_St
     select st.*, 'SGT'||st.genericattribute12
     ,null,null,null,null,null,null,null,null ,null, et.eventtypeid, null
     from cs_Salestransaction  st
     join cs_eventtype et
     on et.datatypeseq=st.eventtypeseq and et.removedate=cdt_EndofTime
     where st.tenantid = 'AIAS' and et.tenantid = 'AIAS'
     and ST.PROCESSINGUNITSEQ = GV_PROCESSINGUNITSEQ
     AND st.compensationDate >= v_periodstartdate
     AND st.COMPENSATIONDATE < v_periodenddate
     and st.businessunitmap in (1,16)
     and eventtypeid in   ('RYC',
                          'API',
                          'IFYC',
                          'FYC',
                          'SSCP',
                      'ORYC')
     And not Exists (Select 1
                                        From Sh_Query_Result R
                                       Where Component In ('PI',
                                             'AOR')
         And Periodseq = I_Periodseq
     And St.Salestransactionseq = R.Genericsequence1)
     and st.genericdate2 < to_date('12/01/2015',
                      'mm/dd/yyyy');
    
    
    Log('33 Insert Done');
    
    
                DBMS_STATS.GATHER_TABLE_STATS (
                    ownname          => 'AIASEXT',
                    tabname          => 'TMP_X_ST',
                    method_opt       => 'FOR ALL INDEXED COLUMNS SIZE AUTO',
                    estimate_percent => dbms_stats.auto_sample_size,
                    degree           => dbms_stats.default_degree,
                    cascade          => true
              );
    
    
    Log('33 Stats Done');
    
    merge into tmp_x_St tgt
    using(
          select *
            from cs_position
           where tenantid='AIAS'
         and removedate=cdt_EndofTime
    ) src
    on (src.name = tgt.sgtga12 and
            tgt.compensationdate between src.effectivestartdate and src.effectiveenddate-1 and
        src.tenantid=tgt.tenantid)
    when matched then update
    set tgt.wagency='SGY' || src.Genericattribute1
        ,tgt.wagtclass=src.Genericattribute4
        , tgt.sgtga2='SGT'||src.genericattribute2;
    
      Log('33 Merge 1 Done');
    
    
    
    merge into   tmp_x_St tgt
    using(
           select   *
             from cs_position p
            where tenantid='AIAS' and  removedate=cdt_EndofTime
         and Genericattribute11 In ('FSD',
                              'FSAD',
                              'AM',
                          'FSM')
          ) src
         on (src.name = tgt.sgtga2
     and tgt.compensationdate between src.effectivestartdate and src.effectiveenddate-1 )
    when matched then update
       set tgt.wagencyleader='SGY' || src.Genericattribute1
           ,tgt.wAgyLdrTitle=src.genericAttribute11
           ,tgt.Wagyldrdistrict=src.Genericattribute3
           ,tgt.Spinstartdate=src.genericdate5
           ,tgt.SpinEnddate=src.genericdate6
           ,tgt.wAgyLdrCode = src.name;
    
      Log('33 Merge 2 Done');
    
    
    
    update tmp_x_St x
    set  setup = nvl((select stp.txtagt
                           from In_Pi_Aor_Setup stp
                          where 'SGT' || to_number(stp.txtagt) = x.wAgyLdrCode
             and stp.dtecycle = v_periodenddate-1
             and stp.txttype in('C', 'D')
         and rownum = 1),
           'X') ;
    
     Log('33 Update Done');
    
    
    
      for c_txn in (
        --with x as (select  * from tmp_x_St)
            select \*+ parallel(8)  leading(curdis,x,ldr,LDRCURROLE,tt)  index(curdis CS_POSITION_AK1) index(ldrcurrole CS_POSITION_AK1) *\
                   x.genericAttribute2,
                   x.genericAttribute14,
                   x.Genericattribute17,
                   x.Businessunitmap,
                   x.Productname,
                   x.Genericattribute13,
                   x.Compensationdate,
                   x.SALESORDERSEQ,
                   x.Salestransactionseq,
                   x.genericDate2,
                   x.eventtypeid,
                   x.wAgency,
                   x.wAgencyLeader,
                   x.wAgyLdrTitle,
                   'SGY' || x.Wagyldrdistrict as Wagyldrdistrict,
                   x.Wagtclass,
                   x.wAgyLdrCode as wAgyLdrCde ,
                   x.Spinstartdate,
                   x.spinEndDate,
                   'SGY' || curDis.Genericattribute3 as CurDistrict,
                   tt.name as LdrCurRole
                   ,x.setup
              from tmp_x_St x,
             ---version 5 fix incorrect DMcode
                   cs_position agt,
                   cs_position curDis,
                   cs_position LdrCurRole,
                   cs_title tt
             where x.sgtga12 = agt.name
         and agt.removeDate=cdt_EndofTime
         AND agt.effectiveStartDate<=v_periodEndDate -1
         AND agt.effectiveEndDate > v_periodEndDate-1
         and 'SGY'||agt.genericattribute1 = curDis.Name
         and curDis.tenantid = 'AIAS'
         and curDis.removeDate = cdt_EndofTime
         AND curDis.effectiveStartDate <= v_periodenddate-1
         AND curDis.effectiveEndDate > v_periodenddate-1
         and x.wAgyLdrCode = LdrCurRole.name
         and LdrCurRole.tenantid = 'AIAS'
         and LdrCurRole.removeDate = cdt_EndofTime
         AND LdrCurRole.effectiveStartDate <= v_periodenddate-1
         AND LdrCurRole.effectiveEndDate > v_periodenddate-1
         and LdrCurRole.titleseq = tt.ruleelementownerseq
         and tt.removedate = cdt_EndofTime
         and tt.effectiveenddate = cdt_EndofTime
     and tt.tenantid='AIAS')
        loop
    
          V_Agydisttrxn.Wagency:=C_Txn.wAgency;
          V_Agydisttrxn.Wagencyleader:=C_Txn.wAgencyLeader;
          V_Agydisttrxn.wAgyLdrTitle:=c_txn.wAgyLdrTitle;
          V_Agydisttrxn.Wagyldrdistrict:=C_Txn.Wagyldrdistrict;
          V_Agydisttrxn.Wagtclass:=C_Txn.Wagtclass;
          V_Agydisttrxn.policyIssueDate:=c_txn.genericDate2;
          V_Agydisttrxn.CurDistrict:=c_txn.CurDistrict;  -- add by Nelson
          V_Agydisttrxn.LdrCurRole:=c_txn.LdrCurRole;  -- add by Nelson
          V_Agydisttrxn.wAgyLdrCde:=c_txn.wAgyLdrCde;  -- add by Nelson
          V_Agydisttrxn.setup:=c_txn.setup;  -- add by Nelson
          V_Agydisttrxn.txnCode:=c_txn.genericAttribute2; -- add by Nelson
    
          V_Agydisttrxn.Salestransactionseq:=C_Txn.Salestransactionseq;
          V_Agydisttrxn.SALESORDERSEQ:=C_Txn.SALESORDERSEQ;
          V_Agydisttrxn.Compensationdate:=C_Txn.Compensationdate;
          V_Agydisttrxn.Commissionagy:='SGY'||C_Txn.Genericattribute13;
          V_Agydisttrxn.Runningtype:='After Cutover - GA17<>O';
          V_Agydisttrxn.eventtypeid:=C_Txn.eventtypeid;
          V_Agydisttrxn.Productname:=C_Txn.Productname;
          V_Agydisttrxn.Businessunitmap:=C_Txn.Businessunitmap;
          V_Agydisttrxn.Orphanpolicy:= 'X'|| C_Txn.Genericattribute17 ;
          ---those ga17=o, but not able get version by policy issue date, will trade as ga17<>O
          V_Agydisttrxn.ActualOrphanPolicy:=c_txn.genericAttribute17;
          V_Agydisttrxn.Periodseq:=I_Periodseq;
          V_Agydisttrxn.Spinstartdate:=C_Txn.Spinstartdate;
          V_Agydisttrxn.SpinEnddate:=C_Txn.SpinEnddate;
          V_Agydisttrxn.Spindaterange:=Ceil(Months_Between(c_txn.genericDate2,C_Txn.Spinstartdate)/12);
          V_Agydisttrxn.Txnclasscode:=C_Txn.Genericattribute14;
    
          --comTransferPIAOR(V_Agydisttrxn) ;
          if C_Txn.Salestransactionseq=14636699070356340  then
          Comtransferpiaor_debug(V_Agydisttrxn);
          else
          comTransferPIAOR(V_Agydisttrxn) ;
          end if;
        end loop; -- end c_txn
    
        commit;
        Log('33');
    
    
    
      comDebugger('SQL Performance','Stagehook[SP_TXA_PIAOR]-SQL5 START:'||SYSDATE);
    
    
    
    
        Log('34');
      --REMOVE NA district result
      Delete \*+ parallel(8) *\ From Sh_Query_Result
      where component in (V_Componentvalue_Pi,V_Componentvalue_Aor)
     And Periodseq=I_Periodseq
     and genericAttribute4='NA';
    
      commit;
      Log('34');
    
    
      Log('35');
    
    --comDebugger('piaor','merge1 start piaor'||i_periodSeq);
    
    \*commented by Suresh 20180129
        merge into sh_query_result m
        Using (Select \*+ index(R SH_QUERY_RESULT_IDX) index(CP CS_POSITION_AK1) index(CGP CS_GAPOSITION_PK)*\ \*R.Component,r.periodseq,R.Genericsequence1,
                  \* Cgp.Genericdate13 As Crossoverstartdate,
                   Cgp.Genericdate14 As Crossoverenddate,
                   Cgp.Genericdate15 As Demotionstartdate,
                   Cgp.Genericdate16 As DemotionEndDate,
                    Case
                      ----crossover date chking
                      --case#1
                        When Cgp.Genericdate13 IS NOT NULL
         And Cgp.Genericdate14 IS NULL
         And Cgp.Genericdate15 IS NULL
         And Cgp.Genericdate16 IS NULL Then
                          Case When R.Genericdate1<Cgp.Genericdate13 And R.genericDate2>=Cgp.Genericdate13
                             Then Replace(R.Genericattribute5,'Direct Team','Crossover')
                          Else R.Genericattribute5
                          End
                        --case#2
                        When Cgp.Genericdate13 IS NOT NULL
         And Cgp.Genericdate14 IS NOT NULL
         And Cgp.Genericdate15 IS NULL
         And Cgp.Genericdate16 IS NULL Then
                         Case When R.Genericdate1<Cgp.Genericdate13
         and R.genericDate2 >=Cgp.Genericdate13
         And R.Genericdate2 <Cgp.Genericdate14
                                 Then Replace(R.Genericattribute5,'Direct Team','Crossover')
                             Else R.Genericattribute5
                             End
                        --demotion date chking
                        --case#3
                        When Cgp.Genericdate13 IS NULL
         And Cgp.Genericdate14 IS NULL
         And Cgp.Genericdate15 IS NOT NULL
         And Cgp.Genericdate16 IS NULL Then
                         Case When R.Genericdate1<Cgp.Genericdate15
         And R.Genericdate2>=Cgp.Genericdate15
                             Then Replace(R.Genericattribute5,'AOR - Direct Team','AOR - Crossover')
                           else R.Genericattribute5
                           End
                        --case#4
                        When Cgp.Genericdate13 IS NULL
         And Cgp.Genericdate14 IS NULL
         And Cgp.Genericdate15 IS NOT NULL
         And Cgp.Genericdate16 IS NOT NULL Then
                         Case When R.Genericdate1<Cgp.Genericdate15
         And R.Genericdate2>=Cgp.Genericdate15
         And R.Genericdate2<Cgp.Genericdate16
                             Then Replace(R.Genericattribute5,'AOR - Direct Team','AOR - Crossover')
                           else R.Genericattribute5
                           End
                        --case#5
                        When Cgp.Genericdate13 IS NOT NULL
         And Cgp.Genericdate14 IS NULL
         And Cgp.Genericdate15 IS NOT NULL
         And Cgp.Genericdate16 IS NULL
         and Cgp.Genericdate13<Cgp.Genericdate15
                        Then
                         Case When R.Genericdate1<Cgp.Genericdate13
         And R.Genericdate2>=Cgp.Genericdate15
                               Then Replace(R.Genericattribute5,'Direct Team','Crossover')
                           When R.Genericdate1>=Cgp.Genericdate13 And R.Genericdate1<Cgp.Genericdate15
         And R.Genericdate2>=Cgp.Genericdate15
                               then Replace(R.Genericattribute5,'AOR - Direct Team','AOR - Crossover')
                           else R.Genericattribute5
                           End
                        --case#6
                        When Cgp.Genericdate13 IS NOT NULL
         And Cgp.Genericdate14 IS NULL
         And Cgp.Genericdate15 IS NOT NULL
         And Cgp.Genericdate16 IS NULL
         and Cgp.Genericdate13>Cgp.Genericdate15
                        Then
                         Case When R.Genericdate1<Cgp.Genericdate15
         And R.Genericdate2>=Cgp.Genericdate15 and  R.Genericdate2<Cgp.Genericdate13
                               Then Replace(R.Genericattribute5,'AOR - Direct Team','AOR - Crossover')
                           When R.Genericdate1<Cgp.Genericdate15
         And R.Genericdate2>=Cgp.Genericdate13
                               Then Replace(R.Genericattribute5,'Direct Team','Crossover')
                           When R.Genericdate1>=Cgp.Genericdate15 And R.Genericdate1<Cgp.Genericdate13
         And R.Genericdate2>=Cgp.Genericdate13
                               Then Replace(R.Genericattribute5,'Direct Team','Crossover')
                           Else R.Genericattribute5 End
                          --case#7
                          When Cgp.Genericdate13 IS NOT NULL
         And Cgp.Genericdate14 IS NULL
         And Cgp.Genericdate15 IS NOT NULL
         And Cgp.Genericdate16 IS NULL
         and Cgp.Genericdate13=Cgp.Genericdate15
                            Then
                           Replace(R.Genericattribute5,'Direct Team','Crossover')
                    else R.Genericattribute5
                    end as rule
            From Sh_Query_Result R, cs_position cp, cs_gaposition cgp
            Where cp.tenantid='AIAS' and cgp.tenantid='AIAS' and R.Component In ('PI','AOR')
         and r.periodseq=gv_periodseq
         and r.genericAttribute5 in ('PI - Direct Team', 'AOR - Direct Team')
         And R.Genericattribute1=Cp.Name
         And Cp.Removedate=Cdt_Endoftime
         And Cp.Effectivestartdate<=R.Genericdate2
         And Cp.Effectiveenddate>R.Genericdate2
         And Cp.Ruleelementownerseq=Cgp.Ruleelementownerseq
         And Cgp.Removedate=Cdt_Endoftime
         And Cgp.Effectivestartdate<=R.Genericdate2
         And Cgp.Effectiveenddate>R.Genericdate2
         And Cgp.Pagenumber=0
         And (Cgp.Genericdate13 IS NOT NULL Or Cgp.Genericdate14 IS NOT NULL
         Or Cgp.Genericdate15 IS NOT NULL Or Cgp.Genericdate16 IS NOT NULL)
         AND r.genericAttribute11 <>'XO' --if xo, means the GA17=0 trxn cant find a matched dirstrict by policy issue date in both aia and tc table
        ) T
        On (T.Genericsequence1=M.Genericsequence1
         And T.Component=M.Component
         and t.periodseq=m.periodseq
        )
        When Matched Then Update
        Set M.Genericattribute5=T.Rule,
            M.Genericdate3=T.Crossoverstartdate,
            M.Genericdate4=T.Crossoverenddate,
            M.Genericdate5=T.Demotionstartdate,
            m.Genericdate6=T.DemotionEnddate
            ;
    *\
    
    
    --Added by Suresh 20180129
      Log('35a');
    EXECUTE IMMEDIATE 'truncate table SH_QUERY_RESULT_TMP35';
    Insert \*+ APPEND *\ into SH_QUERY_RESULT_TMP35
        Select \*+ index(R SH_QUERY_RESULT_IDX) index(CP CS_POSITION_AK1) index(CGP CS_GAPOSITION_PK)*\ R.Component,r.periodseq,R.Genericsequence1,
               Cgp.Genericdate13 As Crossoverstartdate,
               Cgp.Genericdate14 As Crossoverenddate,
               Cgp.Genericdate15 As Demotionstartdate,
               Cgp.Genericdate16 As DemotionEndDate,
                Case
                  ----crossover date chking
                  --case#1
                    When Cgp.Genericdate13 IS NOT NULL
     And Cgp.Genericdate14 IS NULL
     And Cgp.Genericdate15 IS NULL
     And Cgp.Genericdate16 IS NULL Then
                      Case When R.Genericdate1<Cgp.Genericdate13 And R.genericDate2>=Cgp.Genericdate13
                         Then Replace(R.Genericattribute5,'Direct Team','Crossover')
                      Else R.Genericattribute5
                      End
                    --case#2
                    When Cgp.Genericdate13 IS NOT NULL
     And Cgp.Genericdate14 IS NOT NULL
     And Cgp.Genericdate15 IS NULL
     And Cgp.Genericdate16 IS NULL Then
                     Case When R.Genericdate1<Cgp.Genericdate13
     and R.genericDate2 >=Cgp.Genericdate13
     And R.Genericdate2 <Cgp.Genericdate14
                             Then Replace(R.Genericattribute5,'Direct Team','Crossover')
                         Else R.Genericattribute5
                         End
                    --demotion date chking
                    --case#3
                    When Cgp.Genericdate13 IS NULL
     And Cgp.Genericdate14 IS NULL
     And Cgp.Genericdate15 IS NOT NULL
     And Cgp.Genericdate16 IS NULL Then
                     Case When R.Genericdate1<Cgp.Genericdate15
     And R.Genericdate2>=Cgp.Genericdate15
                         Then Replace(R.Genericattribute5,'AOR - Direct Team','AOR - Crossover')
                       else R.Genericattribute5
                       End
                    --case#4
                    When Cgp.Genericdate13 IS NULL
     And Cgp.Genericdate14 IS NULL
     And Cgp.Genericdate15 IS NOT NULL
     And Cgp.Genericdate16 IS NOT NULL Then
                     Case When R.Genericdate1<Cgp.Genericdate15
     And R.Genericdate2>=Cgp.Genericdate15
     And R.Genericdate2<Cgp.Genericdate16
                         Then Replace(R.Genericattribute5,'AOR - Direct Team','AOR - Crossover')
                       else R.Genericattribute5
                       End
                    --case#5
                    When Cgp.Genericdate13 IS NOT NULL
     And Cgp.Genericdate14 IS NULL
     And Cgp.Genericdate15 IS NOT NULL
     And Cgp.Genericdate16 IS NULL
     and Cgp.Genericdate13<Cgp.Genericdate15
                    Then
                     Case When R.Genericdate1<Cgp.Genericdate13
     And R.Genericdate2>=Cgp.Genericdate15
                           Then Replace(R.Genericattribute5,'Direct Team','Crossover')
                       When R.Genericdate1>=Cgp.Genericdate13 And R.Genericdate1<Cgp.Genericdate15
     And R.Genericdate2>=Cgp.Genericdate15
                           then Replace(R.Genericattribute5,'AOR - Direct Team','AOR - Crossover')
                       else R.Genericattribute5
                       End
                    --case#6
                    When Cgp.Genericdate13 IS NOT NULL
     And Cgp.Genericdate14 IS NULL
     And Cgp.Genericdate15 IS NOT NULL
     And Cgp.Genericdate16 IS NULL
     and Cgp.Genericdate13>Cgp.Genericdate15
                    Then
                     Case When R.Genericdate1<Cgp.Genericdate15
     And R.Genericdate2>=Cgp.Genericdate15 and  R.Genericdate2<Cgp.Genericdate13
                           Then Replace(R.Genericattribute5,'AOR - Direct Team','AOR - Crossover')
                       When R.Genericdate1<Cgp.Genericdate15
     And R.Genericdate2>=Cgp.Genericdate13
                           Then Replace(R.Genericattribute5,'Direct Team','Crossover')
                       When R.Genericdate1>=Cgp.Genericdate15 And R.Genericdate1<Cgp.Genericdate13
     And R.Genericdate2>=Cgp.Genericdate13
                           Then Replace(R.Genericattribute5,'Direct Team','Crossover')
                       Else R.Genericattribute5 End
                      --case#7
                      When Cgp.Genericdate13 IS NOT NULL
     And Cgp.Genericdate14 IS NULL
     And Cgp.Genericdate15 IS NOT NULL
     And Cgp.Genericdate16 IS NULL
     and Cgp.Genericdate13=Cgp.Genericdate15
                        Then
                       Replace(R.Genericattribute5,'Direct Team','Crossover')
                else R.Genericattribute5
                end as rule
        From Sh_Query_Result R, cs_position cp, cs_gaposition cgp
        Where cp.tenantid='AIAS' and cgp.tenantid='AIAS' and R.Component In ('PI','AOR')
     and r.periodseq=gv_periodseq
     and r.genericAttribute5 in ('PI - Direct Team', 'AOR - Direct Team')
     And R.Genericattribute1=Cp.Name
     And Cp.Removedate=Cdt_Endoftime
     And Cp.Effectivestartdate<=R.Genericdate2
     And Cp.Effectiveenddate>R.Genericdate2
     And Cp.Ruleelementownerseq=Cgp.Ruleelementownerseq
     And Cgp.Removedate=Cdt_Endoftime
     And Cgp.Effectivestartdate<=R.Genericdate2
     And Cgp.Effectiveenddate>R.Genericdate2
     And Cgp.Pagenumber=0
     And (Cgp.Genericdate13 IS NOT NULL Or Cgp.Genericdate14 IS NOT NULL
     Or Cgp.Genericdate15 IS NOT NULL Or Cgp.Genericdate16 IS NOT NULL)
     AND r.genericAttribute11 <>'XO' --if xo, means the GA17=0 trxn cant find a matched dirstrict by policy issue date in both aia and tc table
      ;
      COMMIT;
      Log('35a');
    
    
        merge into sh_query_result m
        Using (select \*+ PARALLEL(10) *\ * from SH_QUERY_RESULT_TMP35
        ) T
        On (T.Genericsequence1=M.Genericsequence1
         And T.Component=M.Component
         and t.periodseq=m.periodseq
        )
        When Matched Then Update
        Set M.Genericattribute5=T.Rule,
            M.Genericdate3=T.Crossoverstartdate,
            M.Genericdate4=T.Crossoverenddate,
            M.Genericdate5=T.Demotionstartdate,
            m.Genericdate6=T.DemotionEnddate
            ;
    --end by Suresh 20180129
        commit;
        Log('35');
    
       -- comDebugger('piaor','merge1 done!!'||i_periodSeq);
    
    
      --when completed data gathering from kinds of scenario, then insert the assignment data to cs_txnassignment
      --delete pi/aor assignment data which not same as standard agency
     \*** the deletion is deined here, because assignment will be clean up by comCleanAssignment()
       delete /-+parallel(Ta,8)-/ from
        cs_transactionAssignment ta
        where 1=1
     And (Ta.Genericattribute4 Like '%PI%' Or Ta.Genericattribute4 Like '%AOR%')
     And Ta.Genericattribute4 Not Like 'NADOR%'
     and ta.setnumber>2
     AND ta.genericAttribute9 IS NULL
     and ta.compensationDate>=v_periodStartDate
     And Ta.Compensationdate<V_Periodenddate
        --ensure only delete those trxn is in current pu
     And Exists (
            Select 1 From Cs_Salestransaction
            Where Salestransactionseq=Ta.Salestransactionseq
         and processingUnitSeq=gv_processingUnitSeq
        )
     And Not Exists (Select 1 From Cs_Salestransaction
            Where Salestransactionseq=Ta.Salestransactionseq
         and processingUnitSeq=gv_processingUnitSeq
         AND EVENTTYPESEQ=GV_HRYC
        );
    
        *\
    
        commit;
    
        --reset ga4 of standard agency assignment which is shared for pi or aor
    
        Log('36');
        Update \* parallel(Ta,8)*\Cs_Transactionassignment Ta
        set ta.genericattribute4=decode(substrc(ta.genericattribute4,1,5),'NADOR','NADOR',''),
        ta.genericAttribute5=null,
        ta.genericAttribute6=null,
        ta.genericAttribute7=null,
        ta.genericAttribute8=null,
        ta.genericAttribute10=null
        Where  (Ta.Genericattribute4 Like '%PI%' Or Ta.Genericattribute4 Like '%AOR%')
     and ta.positionname like 'SGY%'
     and ta.genericAttribute9 IS NULL
     and ta.compensationDate>=v_periodStartDate
     and ta.compensationDate<v_periodEndDate
     And Exists (
            Select 1 From Cs_Salestransaction
            Where Salestransactionseq=Ta.Salestransactionseq
         And Processingunitseq=Gv_Processingunitseq
        )
     And Not Exists (Select 1 From Cs_Salestransaction
            Where Salestransactionseq=Ta.Salestransactionseq
         And Eventtypeseq=GV_HRYC
        );
    
    
        commit;
        Log('36');
    
    
        Log('37');
        --delete from sh_sequence where seqtype in ('AOR_TRXNSEQ', 'PI_TRXNSEQ');
        execute immediate 'truncate table sh_sequence';  --add by nelson for performance tune
    
        COMMIT;
        Log('37');
    
      --different PI agency
    
        Log('38');
    
      insert ALL
      WHEN standardAgency<>positionName THEN
      INTO cs_transactionAssignment
        (Tenantid,salesTransactionSeq,salesOrderSeq,setNumber,compensationDate,positionName,payeeId,genericAttribute4,genericAttribute5,genericAttribute6,
        genericAttribute7,genericAttribute8,processingunitseq)
        VALUES ('AIAS',salesTransactionSeq, salesOrderSeq, setNumber,compensationDate, positionName,null,assignmentType,ruleIndicator,
        wAgency,wAgyLdrTitle,wAgyLdrDistrict,processingunitseq)
        WHEN standardAgency=positionName THEN
        INTO sh_sequence (businessSeq,seqType) values (salesTransactionSeq,'PI_TRXNSEQ')
        select \*+ INDEX(ta.AIAS_TXNASSIGN_PNAME) parallel(8) *\ r.genericSequence1 as salesTransactionSeq,r.genericSequence2 as salesOrderSeq,r.genericNumber1 as setNumber,
               r.genericDate1 as policyIssuedDate,r.genericDate2 as compensationDate,
               r.genericAttribute1 as positionName ,r.genericAttribute2 as wAgyLdrTitle,
               r.genericAttribute3 as wAgency, r.genericAttribute4 as wAgyLdrDistrict,
               r.genericAttribute5 as ruleIndicator, r.genericAttribute6 as businessUnitMap,
               r.component as assignmentType,nvl(ta.positionName,'#') standardAgency,ta.processingunitseq as processingunitseq
          from sh_query_result r,cs_transactionassignment ta
         Where ta.tenantid='AIAS' and R.Component ='PI'
     and r.periodseq=gv_periodseq
     and ta.salestransactionseq=r.genericSequence1
     and Ta.Setnumber=1
     aND r.genericAttribute11 <>'XO';
       -- and ta.positionName <> r.genericAttribute1
    
        commit;
        Log('38');
    
            DBMS_STATS.GATHER_TABLE_STATS (
                    ownname          => 'AIASEXT',
                    tabname          => 'SH_SEQUENCE',
                    method_opt       => 'FOR ALL INDEXED COLUMNS SIZE AUTO',
                    estimate_percent => dbms_stats.auto_sample_size,
                    degree           => dbms_stats.default_degree,
                    cascade          => true
              );
    
        Log('39');
    
        Merge \*+ INDEX(ta AIAS_TXNASSIGN_PNAME) *\ Into Cs_Transactionassignment Ta
        Using
        (Select Salestransactionseq, Salesorderseq, Setnumber,Policyissueddate,
            Compensationdate,Positionname,Wagyldrtitle,Wagency,Wagyldrdistrict,Ruleindicator,Businessunitmap
            from (SELECT \*+ LEADING(r,s) index(R SH_QUERY_RESULT_IDX2) *\s.businessSeq businessSeq,
                             r.genericSequence1 as salesTransactionSeq,r.genericSequence2 as salesOrderSeq,
                             r.genericNumber1 as setNumber,
                             r.genericDate1 as policyIssuedDate,r.genericDate2 as compensationDate,
                             r.genericAttribute1 as positionName ,r.genericAttribute2 as wAgyLdrTitle,
                             r.genericAttribute3 as wAgency, r.genericAttribute4 as wAgyLdrDistrict,
                             R.Genericattribute5 As Ruleindicator, R.Genericattribute6 As Businessunitmap
                      from sh_query_result r left join sh_sequence s
                        on s.businessSeq=r.genericSequence1
             and s.Seqtype='PI_TRXNSEQ'
                     Where R.Component ='PI'
             And R.Periodseq=Gv_Periodseq
             And R.Genericattribute11 <>'XO'
                 )R
                 where r.businessSeq IS NOT NULL
        ) t
        on
        ( t.salestransactionSeq=ta.salestransactionseq
         and t.positionName=ta.positionName
         and ta.setnumber=1
        )
        When Matched Then Update Set
        ta.genericAttribute4=decode( nvl(ta.genericAttribute4,'Standard'),'Standard', 'Standard_PI', ta.genericAttribute4||'_PI'),
        ta.genericAttribute5=t.ruleIndicator,
        ta.genericAttribute6=t.wAgency,
        ta.genericAttribute7=t.wAgyLdrTitle,
        ta.genericAttribute8=t.wAgyLdrDistrict
        ;
    
    
        commit;
    
        Log('39');
    
    
        Log('40');
    
      insert \*+ append *\ ALL
      WHEN standardAgency<>positionName and PIPositionName<>positionName THEN
      INTO cs_transactionAssignment
        (tenantid,salesTransactionSeq,salesOrderSeq,setNumber,compensationDate,positionName,payeeId,genericAttribute4,genericAttribute10,genericAttribute6,
        genericAttribute7,genericAttribute8,PROCESSINGUNITSEQ)
        VALUES ('AIAS',salesTransactionSeq, salesOrderSeq, setNumber,compensationDate, positionName,null,assignmentType,ruleIndicator,
        wAgency,wAgyLdrTitle,wAgyLdrDistrict,PROCESSINGUNITSEQ)
        WHEN standardAgency=positionName or PIPositionName=positionName THEN
        INTO sh_sequence (businessSeq,seqType) values (salesTransactionSeq,'AOR_TRXNSEQ')
        Select \*+  INDEX(ta AIAS_TXNASSIGN_PNAME)  PARALLEL(r,8) *\
        R.Genericsequence1 As Salestransactionseq,R.Genericsequence2 As Salesorderseq,
         r.genericnumber1 as setNumber,
        r.genericDate1 as policyIssuedDate,r.genericDate2 as compensationDate,
       r.genericAttribute1 as positionName ,r.genericAttribute2 as wAgyLdrTitle,
       r.genericAttribute3 as wAgency, r.genericAttribute4 as wAgyLdrDistrict,
       r.genericAttribute5 as ruleIndicator, r.genericAttribute6 as businessUnitMap,
       r.component as assignmentType,nvl(ta.positionName,'#') standardAgency, nvl(rpi.genericattribute1,'#') as PIPositionName,TA.PROCESSINGUNITSEQ as PROCESSINGUNITSEQ
        from sh_query_result r,cs_transactionassignment ta, sh_query_result rpi
        Where ta.tenantid='AIAS' and ta.PROCESSINGUNITSEQ=GV_PROCESSINGUNITSEQ and R.Component ='AOR'
     And R.Periodseq=Gv_Periodseq
     AND r.genericAttribute11 <>'XO'
     and ta.salestransactionseq=r.genericSequence1
     and ta.setnumber=1
     and rpi.component(+)='PI'
     And R.Genericsequence1=Rpi.Genericsequence1(+)
     and rpi.periodseq(+)=gv_periodseq ;
    
    
    
        commit;
        Log('40');
    
         begin
            DBMS_STATS.GATHER_TABLE_STATS (
                    ownname          => 'AIASEXT',
                    tabname          => 'SH_SEQUENCE',
                    method_opt       => 'FOR ALL INDEXED COLUMNS SIZE AUTO',
                    estimate_percent => dbms_stats.auto_sample_size,
                    degree           => dbms_stats.default_degree,
                    cascade          => true
              );
    
        end;
    
    --comDebugger('piaor','merge2 start piaor'||i_periodSeq);
         --update standard_pi_aor
        Log('41');
        merge \*+ INDEX(ta AIAS_TXNASSIGN_PNAME) *\ into cs_transactionAssignment ta
        using
        (Select Salestransactionseq, Salesorderseq, Setnumber,Policyissueddate,
                    Compensationdate,Positionname,Wagyldrtitle,Wagency,Wagyldrdistrict,Ruleindicator,Businessunitmap
               from (SELECT \*+ LEADING(r,s) index(R SH_QUERY_RESULT_IDX2) *\s.businessSeq businessSeq,
                              r.genericSequence1 as salesTransactionSeq,r.genericSequence2 as salesOrderSeq,
                              r.genericNumber1 as setNumber,
                              r.genericDate1 as policyIssuedDate,r.genericDate2 as compensationDate,
                              r.genericAttribute1 as positionName ,r.genericAttribute2 as wAgyLdrTitle,
                              r.genericAttribute3 as wAgency, r.genericAttribute4 as wAgyLdrDistrict,
                              R.Genericattribute5 As Ruleindicator, R.Genericattribute6 As Businessunitmap
                           from sh_query_result r left join sh_sequence s
                             on s.businessSeq=r.genericSequence1
             and S.Seqtype='AOR_TRXNSEQ'
                          Where R.Component ='AOR'
             And R.Periodseq=Gv_Periodseq
             And r.Genericattribute11 <>'XO'
                    ) R
                    where r.businessSeq IS NOT NULL
        ) t
        on
        ( t.salestransactionSeq=ta.salestransactionseq
         And Ta.Positionname=T.Positionname
             -- and ta.tenantid='AIAS'
        )
        when matched then update set
          ta.genericAttribute4=decode( nvl(ta.genericAttribute4,'Standard'),'Standard', 'Standard_AOR', ta.genericAttribute4||'_AOR'),
          ta.genericAttribute10=t.ruleIndicator,
          ta.genericAttribute6=t.wAgency,
          ta.genericAttribute7=t.wAgyLdrTitle,
          ta.genericAttribute8=t.wAgyLdrDistrict;
    
    
        Commit;
        Log('41');
    
    
        --UPDATE XO result with to trxn.eb4
    \*Arjun 0520 - temporary patch*\
    \*update cs_transactionassignment ta
    set genericattribute4 = 'NADOR_Standard_AOR'
    where setnumber=1 and processingunitseq=gv_processingunitseq and tenantid='AIAS'
    and   ta.compensationDate>=v_periodStartDate
     and ta.compensationDate<v_periodEndDate
    and genericattribute4 = 'NADOR_AOR'
    ; *\
    commit;
    
        Log('42');
        Merge \*+ INDEX(gst AIA_Cs_gaSalestransaction_SEQ) *\ Into Cs_Gasalestransaction gst
        Using (
              Select Distinct Genericsequence1 As Salestransactionseq, --due to pi-aor might share one trxn seq, so need distinct here.
              0 as pagenumber
              From Sh_Query_Result
              where Component in ('AOR','PI')
         And Periodseq=Gv_Periodseq
         AND genericAttribute11 ='XO'
        ) T
        On (T.Salestransactionseq=Gst.Salestransactionseq
         and t.pagenumber=gst.pagenumber
         and gst.tenantid='AIAS'
        )
        When Matched Then Update Set
             genericBoolean4=1;
    
        commit;
        Log('42');
    
        exception
    
        when others then
        rollback;
        gv_error:='Error [SP_TXA_PIAOR]: '||sqlerrm||' - '||dbms_utility.format_error_backtrace;
    
    
        raise_application_error(-20000,gv_error);
    
    
    
      end SP_TXA_PIAOR;
    
      procedure SP_TXNTXA_YREND_PIAOR(i_periodSeq in int) as
    
        v_yrStartDate       date;
        v_yrEndDate         date;
        v_yrEndEventTypeSeq int := 0;
        v_modificationTime  timestamp := gv_plstartTime - interval '1' second;
        v_periodStartDate   date;
        v_periodEndDate     date;
        v_compDate          date;
        Vseq                Number;
        v_txnSeq            number;
    
        NO_YRENDFIXEDVALUE_FOUND EXCEPTION;
        NO_YRENDEVENTTYPE_FOUND  EXCEPTION;
        INVALID_PERIODDATE       EXCEPTION;
    
        v1 number;
        v2 number;
        v3 number;
    
      begin
        --year end process
    
        --dbms_output.put_line('get fixed value');
    
        select startdate, enddate, enddate - 1
          into v_periodStartDate, v_periodEndDate, v_compDate
          from cs_period
         Where tenantid='AIAS' and Periodseq = I_Periodseq
     AND REMOVEDATE = cdt_endoftime;
    
        begin
    
          select nvl(dataTypeSeq, 0)
            into v_yrEndEventTypeSeq
            from cs_eventType
           where tenantid='AIAS' and  eventTypeId = 'PI_Year_End'
     and removeDate = cdt_endoftime;
    
          --dbms_output.put_line('get event date');
    
        exception
          when no_data_found then
            raise NO_YRENDEVENTTYPE_FOUND;
        end;
    
        -- dbms_output.put_line('get start date');
    
        begin
          select y.startDate, y.endDate
            into v_yrStartDate, v_yrEndDate
            from cs_periodtype pt, cs_period y, cs_period p
           where pt.tenantid='AIAS'
     and        y.tenantid='AIAS'
     and        p.tenantid='AIAS'
     and pt.name = 'year'
     and pt.removeDate = cdt_EndOfTime
     and p.removeDate = cdt_EndOfTime
     and y.removeDate = cdt_EndOfTime
     and p.periodSeq = i_periodSeq
     and y.startDate <= p.startDate
     and y.endDate > p.startDate
     and y.calendarSeq = p.calendarSeq
     and y.periodTypeSeq = pt.periodTypeSeq;
        exception
          when no_data_found then
            raise INVALID_PERIODDATE;
        end;
    
        Log('50');
    
        delete \*+ parallel(8) FULL(cs_transactionAssignment)  *\
          from cs_transactionAssignment
         where
              tenantid='AIAS'
     and genericAttribute4 like '%PI%'
     and processingunitseq=GV_PROCESSINGUNITSEQ
     and Genericattribute9 = 'YE REASSIGN TO DISTRICT'
     AND COMPENSATIONDATE = v_compDate;
    
        commit;
        Log('50');
    
        Log('51');
    
        delete from cs_gasalestransaction ga
         Where tenantid='AIAS' and Exists
               (Select 1
                      From Cs_Salestransaction st
                     where
                           st.tenantid='AIAS'
         And Processingunitseq = Gv_Processingunitseq
         And Compensationdate = V_Compdate
         And Ga.Salestransactionseq = St.Salestransactionseq
         and Eventtypeseq = V_Yrendeventtypeseq
                   );
    
        commit;
        Log('51');
    
        Log('52');
        delete \*+ parallel(8) FULL(cs_salestransaction)  *\ from cs_salestransaction
         Where
         tenantid='AIAS'
     and processingUnitSeq = gv_processingUnitSeq
     and COMPENSATIONDATE = v_compDate
     and Eventtypeseq = V_Yrendeventtypeseq;
    
    
    
        commit;
        Log('52');
    
        --Vseq:=Sequencegenpkg.Getnextfullseq('auditLogSeq', Classid.Cidauditlog);
        --v_txnSeq := Sequencegenpkg.Getnextfullseq('salesTransactionSeq',
        --                                          Classid.Cidsalestransaction);
    
    
       \*Arjun 20170509
    
       The issue is that there are many salestransactionseqs that were deleted from cs_salestransaction,
       but not from cs_Gasalestransaction and Cs_transactionassignment.
    
    The logic the SH uses is to get the max STSEQ from CS_Salestransaction, and then adds to that
    before inserting the new Year End records. These clash with the existing records.
    I can change the logic to get the maximum seq from the SalesTransaction, GA and Assignment tables
    and use that as a base, but ideally, if we?re deleting transactions, they should be deleted from all the tables.
    
       *\
       -- select \*+ INDEX(CS_salestransaction,AIA_CS_SALESTRANSACTION_SEQ) *\  MAX(salesTransactionSeq)+1 into v_txnSeq
        --  from CS_salestransaction
    
    
    
    
    
           select max(salestransactionseq)+1
       into v_txnseq
       from (select \*+ INDEX(CS_salestransaction,AIA_CS_SALESTRANSACTION_SEQ) *\  max(salesTransactionSeq) salestransactionseq
              from CS_salestransaction
              union all
              select max(salestransactionseq ) from cs_transactionassignment
              union all
              select max(salestransactionseq )  from cs_gasalestransaction
          )
           ;
    
    
        --CREATE NEW TXN
    
        v1  := Comgeteventtypeseq('RYC');
        v2  := Comgeteventtypeseq('H_RYC');
        v3  := Comgeteventtypeseq('ORYC');
    
    -- et.eventTypeId in ('RYC', 'H_RYC', 'ORYC')
    
       \**
        create table AIA_MAX_sublinenumber tablespace tallydata
        as
        select *+ index(cs_salestransaction AIA_salestransaction_orderline) * salesorderseq,max(sublinenumber) as maxsublinenumber
                    from cs_salestransaction
                   where salesorderseq = st.salesorderseq and st.tenantid='AIAS' and 1=0 group by salesorderseq
    
                   create index AIA_MAX_sublinenumber_idx on AIA_MAX_sublinenumber(salesorderseq,maxsublinenumber) tablespace tallyindex
         *\
        execute immediate 'truncate table  AIA_MAX_sublinenumber';
        insert into AIA_MAX_sublinenumber
        select \*+ leading(ta,st) index(cs_salestransaction AIA_salestransaction_orderline)  index(ta     AIA_CS_TRANSACTIONASSIGN_IDX2) *\ ta.salesorderseq,max(sublinenumber) as maxsublinenumber
                    from cs_salestransaction st,  cs_transactionassignment ta
                    where ta.compensationDate >= v_yrStartDate
     And ta.Compensationdate < V_Yrenddate
     and ta.tenantid='AIAS'
     and ta.processingunitseq = Gv_Processingunitseq
     AND Ta.Genericattribute5 = 'PI - Direct Team' -- changed check ga5, and only create trxn for pi-direct team
     and ta.genericAttribute7 = 'FSAD'
     and st.salestransactionseq=ta.salestransactionseq
     and ta.processingunitseq=st.processingunitseq
     and ta.Compensationdate = st.Compensationdate
                    group by ta.salesorderseq;
        commit;
    
        Log('53 '||v_yrStartDate ||' ' ||v_yrEndDate || ' ' || v_compdate);
        insert all when salestransactionSeq > 0 then into cs_salestransaction
          (tenantid,salestransactionseq,
               salesOrderSeq,
               linenumber,
               sublinenumber,
               eventtypeseq,
               compensationDate,
               value,
               unittypeforvalue,
               modificationDate,
               isRunnable,
               ORIGINTYPEID,
               PREADJUSTEDVALUE,
               UNITTYPEFORPREADJUSTEDVALUE,
               PROCESSINGUNITSEQ,
               genericDate6,
               pipelineRunSeq,
               unittypeForLineNumber,
               unitTypeForSubLineNumber,
               businessUnitMap,
               --GENERIC FIELDS
               productId,
               productName,
               productDescription,
               dataSource,
               genericAttribute1,
               genericAttribute2,
               genericAttribute3,
               genericAttribute4,
               genericAttribute5,
               genericAttribute6,
               genericAttribute7,
               genericAttribute8,
               genericAttribute9,
               genericAttribute10,
               genericAttribute11,
               genericAttribute12,
               genericAttribute13,
               genericAttribute14,
               genericAttribute15,
               genericAttribute16,
               genericAttribute17,
               genericAttribute18,
               genericAttribute19,
               genericAttribute20,
               genericAttribute21,
               genericAttribute22,
               genericAttribute23,
               genericAttribute24,
               genericAttribute25,
               genericAttribute26,
               genericAttribute27,
               genericAttribute28,
               genericAttribute29,
               genericAttribute30,
               genericAttribute31,
               genericAttribute32,
               genericNumber1,
               genericNumber2,
               genericNumber3,
               genericNumber4,
               genericNumber5,
               genericNumber6,
               unitTypeForGenericNumber1,
               unitTypeForGenericNumber2,
               unitTypeForGenericNumber3,
               unitTypeForGenericNumber4,
               unitTypeForGenericNumber5,
               unitTypeForGenericNumber6,
               genericDate1,
               genericDate2,
               genericDate3,
               genericDate4,
               genericDate5,
               genericBoolean1,
               genericBoolean2,
               genericBoolean3,
               genericBoolean4,
               genericBoolean5,
               genericBoolean6
               ---
           )
        values
          ('AIAS',salesTransactionSeq,
               salesOrderSeq,
               linenumber,
               sublinenumber,
               v_yrEndEventTypeSeq,
               v_compDate,
               value,
               unittypeforvalue,
               modificationDate,
               isRunnable,
               ORIGINTYPEID,
               PREADJUSTEDVALUE,
               UNITTYPEFORPREADJUSTEDVALUE,
               PROCESSINGUNITSEQ,
               compensationDate,
               gv_pipelineRunSeq,
               unittypeForLineNumber,
               unitTypeForSubLineNumber,
               businessUnitMap,
               --GENERIC FIELDS
               productId,
               productName,
               productDescription,
               dataSource,
               genericAttribute1,
               genericAttribute2,
               genericAttribute3,
               genericAttribute4,
               genericAttribute5,
               genericAttribute6,
               genericAttribute7,
               genericAttribute8,
               genericAttribute9,
               genericAttribute10,
               genericAttribute11,
               genericAttribute12,
               genericAttribute13,
               genericAttribute14,
               genericAttribute15,
               genericAttribute16,
               genericAttribute17,
               genericAttribute18,
               genericAttribute19,
               genericAttribute20,
               genericAttribute21,
               genericAttribute22,
               genericAttribute23,
               genericAttribute24,
               genericAttribute25,
               genericAttribute26,
               genericAttribute27,
               genericAttribute28,
               genericAttribute29,
               genericAttribute30,
               genericAttribute31,
               genericAttribute32,
               genericNumber1,
               genericNumber2,
               genericNumber3,
               genericNumber4,
               genericNumber5,
               genericNumber6,
               unitTypeForGenericNumber1,
               unitTypeForGenericNumber2,
               unitTypeForGenericNumber3,
               unitTypeForGenericNumber4,
               unitTypeForGenericNumber5,
               unitTypeForGenericNumber6,
               genericDate1,
               genericDate2,
               genericDate3,
               genericDate4,
               genericDate5,
               genericBoolean1,
               genericBoolean2,
               genericBoolean3,
               genericBoolean4,
               genericBoolean5,
               GENERICBOOLEAN6
               --
           )
        --gaSalestransaction
        WHEN salestransactionSeq > 0 then into cs_gasalestransaction
          (tenantid, salestransactionSeq,
               pagenumber,
             --Added by Suresh 10292017
               PROCESSINGUNITSEQ,
               compensationDate,
               --End by Suresh 10292017
               GENERICATTRIBUTE1,
               GENERICATTRIBUTE2,
               GENERICATTRIBUTE3,
               GENERICATTRIBUTE4,
               GENERICATTRIBUTE5,
               GENERICATTRIBUTE6,
               GENERICATTRIBUTE7,
               GENERICATTRIBUTE8,
               GENERICATTRIBUTE9,
               GENERICATTRIBUTE10,
               GENERICATTRIBUTE11,
               GENERICATTRIBUTE12,
               GENERICATTRIBUTE13,
               GENERICATTRIBUTE14,
               GENERICATTRIBUTE15,
               GENERICATTRIBUTE16,
               GENERICATTRIBUTE17,
               GENERICATTRIBUTE18,
               GENERICATTRIBUTE19,
               GENERICATTRIBUTE20,
               GENERICDATE1,
               GENERICDATE2,
               GENERICDATE3,
               GENERICDATE4,
               GENERICDATE5,
               GENERICDATE6,
               GENERICDATE7,
               GENERICDATE8,
               GENERICDATE9,
               GENERICDATE10,
               GENERICDATE11,
               GENERICDATE12,
               GENERICDATE13,
               GENERICDATE14,
               GENERICDATE15,
               GENERICDATE16,
               GENERICDATE17,
               GENERICDATE18,
               GENERICDATE19,
               GENERICDATE20,
               GENERICBOOLEAN1,
               GENERICBOOLEAN2,
               GENERICBOOLEAN3,
               GENERICBOOLEAN4,
               GENERICBOOLEAN5,
               GENERICBOOLEAN6,
               GENERICBOOLEAN7,
               GENERICBOOLEAN8,
               GENERICBOOLEAN9,
               GENERICBOOLEAN10,
               GENERICBOOLEAN11,
               GENERICBOOLEAN12,
               GENERICBOOLEAN13,
               GENERICBOOLEAN14,
               GENERICBOOLEAN15,
               GENERICBOOLEAN16,
               GENERICBOOLEAN17,
               GENERICBOOLEAN18,
               GENERICBOOLEAN19,
               GENERICBOOLEAN20,
               GENERICNUMBER1,
               UNITTYPEFORGENERICNUMBER1,
               GENERICNUMBER2,
               UNITTYPEFORGENERICNUMBER2,
               GENERICNUMBER3,
               UNITTYPEFORGENERICNUMBER3,
               GENERICNUMBER4,
               UNITTYPEFORGENERICNUMBER4,
               GENERICNUMBER5,
               UNITTYPEFORGENERICNUMBER5,
               GENERICNUMBER6,
               UNITTYPEFORGENERICNUMBER6,
               GENERICNUMBER7,
               UNITTYPEFORGENERICNUMBER7,
               GENERICNUMBER8,
               UNITTYPEFORGENERICNUMBER8,
               GENERICNUMBER9,
               UNITTYPEFORGENERICNUMBER9,
               GENERICNUMBER10,
               UNITTYPEFORGENERICNUMBER10,
               GENERICNUMBER11,
               UNITTYPEFORGENERICNUMBER11,
               GENERICNUMBER12,
               UNITTYPEFORGENERICNUMBER12,
               GENERICNUMBER13,
               UNITTYPEFORGENERICNUMBER13,
               GENERICNUMBER14,
               UNITTYPEFORGENERICNUMBER14,
               GENERICNUMBER15,
               UNITTYPEFORGENERICNUMBER15,
               GENERICNUMBER16,
               UNITTYPEFORGENERICNUMBER16,
               GENERICNUMBER17,
               UNITTYPEFORGENERICNUMBER17,
               GENERICNUMBER18,
               UNITTYPEFORGENERICNUMBER18,
               GENERICNUMBER19,
               UNITTYPEFORGENERICNUMBER19,
               GENERICNUMBER20,
               UNITTYPEFORGENERICNUMBER20
           )
        values
          ('AIAS',salestransactionseq,
               0,
             --Added by Suresh 10292017
               PROCESSINGUNITSEQ,
               compensationDate,
               --End by Suresh 10292017
               GA1,
               GA2,
               GA3,
               GA4,
               GA5,
               GA6,
               GA7,
               GA8,
               GA9,
               GA10,
               GA11,
               GA12,
               GA13,
               GA14,
               GA15,
               GA16,
               GA17,
               GA18,
               GA19,
               GA20,
               GD1,
               GD2,
               GD3,
               GD4,
               GD5,
               GD6,
               GD7,
               GD8,
               GD9,
               GD10,
               GD11,
               GD12,
               GD13,
               GD14,
               GD15,
               GD16,
               GD17,
               GD18,
               GD19,
               GD20,
               GB1,
               GB2,
               GB3,
               GB4,
               GB5,
               GB6,
               GB7,
               GB8,
               GB9,
               GB10,
               GB11,
               GB12,
               GB13,
               GB14,
               GB15,
               GB16,
               GB17,
               GB18,
               GB19,
               GB20,
               GN1,
               UNITTYPEFORGN1,
               GN2,
               UNITTYPEFORGN2,
               GN3,
               UNITTYPEFORGN3,
               GN4,
               UNITTYPEFORGN4,
               GN5,
               UNITTYPEFORGN5,
               GN6,
               UNITTYPEFORGN6,
               GN7,
               UNITTYPEFORGN7,
               GN8,
               UNITTYPEFORGN8,
               GN9,
               UNITTYPEFORGN9,
               GN10,
               UNITTYPEFORGN10,
               GN11,
               UNITTYPEFORGN11,
               GN12,
               UNITTYPEFORGN12,
               GN13,
               UNITTYPEFORGN13,
               GN14,
               UNITTYPEFORGN14,
               GN15,
               UNITTYPEFORGN15,
               GN16,
               UNITTYPEFORGN16,
               GN17,
               UNITTYPEFORGN17,
               GN18,
               UNITTYPEFORGN18,
               GN19,
               UNITTYPEFORGN19,
               GN20,
           UNITTYPEFORGN20)
        --create new writing agency txta
        when salestransactionSeq > 0 then into cs_transactionAssignment
          (tenantid,salestransactionSeq,
               salesOrderSeq,
               setNumber,
               positionName,
               compensationDate,
               Genericattribute4,
               Genericattribute5,
               Genericattribute6,
               Genericattribute7,
               Genericattribute8,
               Genericattribute9,
               Genericdate6,
           PROCESSINGUNITSEQ)
        Values
          ('AIAS',Salestransactionseq,
               Salesorderseq,
               1,
               Positionname,
               V_Compdate,
               'PI',
               'PI - Direct Team',
               Ga6_Wagency,
               Ga7_Incepttitle,
               Ga8_Wdistrict,
               Ga9_Yrend,
               Compensationdate,
           PROCESSINGUNITSEQ)
        --create new writing distrcit txta
        when salestransactionSeq > 0 then into cs_transactionAssignment
          (tenantid, salestransactionSeq,
               salesOrderSeq,
               setNumber,
               positionName,
               compensationDate,
               Genericattribute4,
               Genericattribute5,
               Genericattribute6,
               Genericattribute7,
               Genericattribute8,
               Genericattribute9,
           Genericdate6,PROCESSINGUNITSEQ)
        Values
          ('AIAS' , Salestransactionseq,
               Salesorderseq,
               2,
               Ga8_Wdistrict,
               V_Compdate,
               'PI',
               'PI - Indirect Team',
               Ga6_Wagency,
               Ga7_Incepttitle,
               Ga8_Wdistrict,
               Ga9_Yrend,
           Compensationdate, processingunitseq)
          Select   \*+ LEADING(ta,st,gata)  USE_NL(ta,st) USE_NL(ta,cp) INDEX(ta,aia_cs_transactionassign_idx2) no_expand  *\ rownum as rn,
                 v_txnSeq + rownum As Salestransactionseq,
                 st.salestransactionseq as oldtrxnseq,
                 ta.salesorderseq,
                 ta.compensationDate,
                 nvl(v_modificationTime, st.modificationDate) as modificationDate,
                 ta.PositionName,
                 Ta.Genericattribute4 As Ga4_Piaor,
                 Ta.Genericattribute6 As Ga6_Wagency,
                 'FSAD' as GA7_inceptTitle, --only assign as FSAD title
                 ta.genericAttribute8 as GA8_WDistrict,
                 'YE REASSIGN TO DISTRICT' as GA9_yrEnd,
                 cp.genericAttribute11 curTitle, -- new title
                 cpa.genericAttribute1 status,
                 st.eventtypeSeq, st.linenumber,
    maxsublinenumber + rownum as SUBLINENUMBER,
                 st.value,
                 st.unittypeforvalue,
                 1 as isRunnable,
                 st.ORIGINTYPEID,
                 st.PREADJUSTEDVALUE,
                 st.UNITTYPEFORPREADJUSTEDVALUE,
                 st.PROCESSINGUNITSEQ,
                 st.BusinessUnitMap,
                 gv_pipelinerunseq as pipelineRunSeq,
                 st.unittypeForLineNumber,
                 st.unitTypeForSubLineNumber,
                 --genericFields
                 st.productId,
                 st.productName,
                 st.productDescription,
                 st.dataSource,
                 st.genericAttribute1,
                 st.genericAttribute2,
                 st.genericAttribute3,
                 st.genericAttribute4,
                 st.genericAttribute5,
                 st.genericAttribute6,
                 st.genericAttribute7,
                 st.genericAttribute8,
                 st.genericAttribute9,
                 st.genericAttribute10,
                 st.genericAttribute11,
                 st.genericAttribute12,
                 st.genericAttribute13,
                 st.genericAttribute14,
                 st.genericAttribute15,
                 st.genericAttribute16,
                 st.genericAttribute17,
                 st.genericAttribute18,
                 st.genericAttribute19,
                 st.genericAttribute20,
                 st.genericAttribute21,
                 st.genericAttribute22,
                 st.genericAttribute23,
                 st.genericAttribute24,
                 st.genericAttribute25,
                 st.genericAttribute26,
                 st.genericAttribute27,
                 st.genericAttribute28,
                 st.genericAttribute29,
                 st.genericAttribute30,
                 st.genericAttribute31,
                 st.genericAttribute32,
                 st.genericNumber1,
                 st.genericNumber2,
                 st.genericNumber3,
                 st.genericNumber4,
                 st.genericNumber5,
                 st.genericNumber6,
                 st.unitTypeForGenericNumber1,
                 st.unitTypeForGenericNumber2,
                 st.unitTypeForGenericNumber3,
                 st.unitTypeForGenericNumber4,
                 st.unitTypeForGenericNumber5,
                 st.unitTypeForGenericNumber6,
                 st.genericDate1,
                 st.genericDate2,
                 st.genericDate3,
                 st.genericDate4,
                 st.genericDate5,
                 st.genericBoolean1,
                 st.genericBoolean2,
                 st.genericBoolean3,
                 st.genericBoolean4,
                 st.genericBoolean5,
                 st.GENERICBOOLEAN6,
                 ----extend generic fields
                 gata.GENERICATTRIBUTE1          as GA1,
                 gata.GENERICATTRIBUTE2          as GA2,
                 gata.GENERICATTRIBUTE3          as GA3,
                 gata.GENERICATTRIBUTE4          as GA4,
                 gata.GENERICATTRIBUTE5          as GA5,
                 gata.GENERICATTRIBUTE6          as GA6,
                 gata.GENERICATTRIBUTE7          as GA7,
                 gata.GENERICATTRIBUTE8          as GA8,
                 gata.GENERICATTRIBUTE9          as GA9,
                 gata.GENERICATTRIBUTE10         as GA10,
                 gata.GENERICATTRIBUTE11         as GA11,
                 gata.GENERICATTRIBUTE12         as GA12,
                 gata.GENERICATTRIBUTE13         as GA13,
                 gata.GENERICATTRIBUTE14         as GA14,
                 gata.GENERICATTRIBUTE15         as GA15,
                 gata.GENERICATTRIBUTE16         as GA16,
                 gata.GENERICATTRIBUTE17         as GA17,
                 gata.GENERICATTRIBUTE18         as GA18,
                 gata.GENERICATTRIBUTE19         as GA19,
                 gata.GENERICATTRIBUTE20         as GA20,
                 gata.GENERICDATE1               as GD1,
                 gata.GENERICDATE2               as GD2,
                 gata.GENERICDATE3               as GD3,
                 gata.GENERICDATE4               as GD4,
                 gata.GENERICDATE5               as GD5,
                 gata.GENERICDATE6               as GD6,
                 gata.GENERICDATE7               as GD7,
                 gata.GENERICDATE8               as GD8,
                 gata.GENERICDATE9               as GD9,
                 gata.GENERICDATE10              as GD10,
                 gata.GENERICDATE11              as GD11,
                 gata.GENERICDATE12              as GD12,
                 gata.GENERICDATE13              as GD13,
                 gata.GENERICDATE14              as GD14,
                 gata.GENERICDATE15              as GD15,
                 gata.GENERICDATE16              as GD16,
                 gata.GENERICDATE17              as GD17,
                 gata.GENERICDATE18              as GD18,
                 gata.GENERICDATE19              as GD19,
                 gata.GENERICDATE20              as GD20,
                 gata.GENERICBOOLEAN1            as GB1,
                 gata.GENERICBOOLEAN2            as GB2,
                 gata.GENERICBOOLEAN3            as GB3,
                 gata.GENERICBOOLEAN4            as GB4,
                 gata.GENERICBOOLEAN5            as GB5,
                 gata.GENERICBOOLEAN6            as GB6,
                 gata.GENERICBOOLEAN7            as GB7,
                 gata.GENERICBOOLEAN8            as GB8,
                 gata.GENERICBOOLEAN9            as GB9,
                 gata.GENERICBOOLEAN10           as GB10,
                 gata.GENERICBOOLEAN11           as GB11,
                 gata.GENERICBOOLEAN12           as GB12,
                 gata.GENERICBOOLEAN13           as GB13,
                 gata.GENERICBOOLEAN14           as GB14,
                 gata.GENERICBOOLEAN15           as GB15,
                 gata.GENERICBOOLEAN16           as GB16,
                 gata.GENERICBOOLEAN17           as GB17,
                 gata.GENERICBOOLEAN18           as GB18,
                 gata.GENERICBOOLEAN19           as GB19,
                 gata.GENERICBOOLEAN20           as GB20,
                 gata.GENERICNUMBER1             as GN1,
                 gata.UNITTYPEFORGENERICNUMBER1  aS UNITTYPEFORGN1,
                 gata.GENERICNUMBER2             as GN2,
                 gata.UNITTYPEFORGENERICNUMBER2  as UNITTYPEFORGN2,
                 gata.GENERICNUMBER3             as GN3,
                 gata.UNITTYPEFORGENERICNUMBER3  as UNITTYPEFORGN3,
                 gata.GENERICNUMBER4             as GN4,
                 gata.UNITTYPEFORGENERICNUMBER4  as UNITTYPEFORGN4,
                 gata.GENERICNUMBER5             as GN5,
                 gata.UNITTYPEFORGENERICNUMBER5  as UNITTYPEFORGN5,
                 gata.GENERICNUMBER6             as GN6,
                 gata.UNITTYPEFORGENERICNUMBER6  as UNITTYPEFORGN6,
                 gata.GENERICNUMBER7             as GN7,
                 gata.UNITTYPEFORGENERICNUMBER7  as UNITTYPEFORGN7,
                 gata.GENERICNUMBER8             as GN8,
                 gata.UNITTYPEFORGENERICNUMBER8  as UNITTYPEFORGN8,
                 gata.GENERICNUMBER9             as GN9,
                 gata.UNITTYPEFORGENERICNUMBER9  as UNITTYPEFORGN9,
                 gata.GENERICNUMBER10            as GN10,
                 gata.UNITTYPEFORGENERICNUMBER10 as UNITTYPEFORGN10,
                 gata.GENERICNUMBER11            as GN11,
                 gata.UNITTYPEFORGENERICNUMBER11 as UNITTYPEFORGN11,
                 gata.GENERICNUMBER12            as GN12,
                 gata.UNITTYPEFORGENERICNUMBER12 as UNITTYPEFORGN12,
                 gata.GENERICNUMBER13            as GN13,
                 gata.UNITTYPEFORGENERICNUMBER13 as UNITTYPEFORGN13,
                 gata.GENERICNUMBER14            as GN14,
                 gata.UNITTYPEFORGENERICNUMBER14 as UNITTYPEFORGN14,
                 gata.GENERICNUMBER15            as GN15,
                 gata.UNITTYPEFORGENERICNUMBER15 as UNITTYPEFORGN15,
                 gata.GENERICNUMBER16            as GN16,
                 gata.UNITTYPEFORGENERICNUMBER16 as UNITTYPEFORGN16,
                 gata.GENERICNUMBER17            as GN17,
                 gata.UNITTYPEFORGENERICNUMBER17 as UNITTYPEFORGN17,
                 gata.GENERICNUMBER18            as GN18,
                 gata.UNITTYPEFORGENERICNUMBER18 as UNITTYPEFORGN18,
                 gata.GENERICNUMBER19            as GN19,
                 gata.UNITTYPEFORGENERICNUMBER19 as UNITTYPEFORGN19,
                 gata.GENERICNUMBER20            as GN20,
                 gata.UNITTYPEFORGENERICNUMBER20 as UNITTYPEFORGN20
            from cs_transactionAssignment ta,
                 cs_salestransaction      st,
    --             cs_eventType             et,
                 cs_position              cp,
                 cs_participant           cpa,
                 Cs_Gasalestransaction    Gata, AIA_MAX_sublinenumber
           Where
           -- et.tenantid='AIAS'
           -- and et.eventTypeId in ('RYC', 'H_RYC', 'ORYC')
           -- AND et.removeDate = cdt_EndOfTime
           -- and et.tenantid=st.tenantid
           -- And Et.Datatypeseq = St.Eventtypeseq
           -- AND
           AIA_MAX_sublinenumber.salesorderseq=st.salesorderseq and
            st.tenantid='AIAS' and St.Eventtypeseq IN (v1,v2,v3)
     and st.processingunitseq=Gv_Processingunitseq
     and st.compensationDate >= v_yrStartDate
     And St.Compensationdate < V_Yrenddate
     and ta.compensationDate >= v_yrStartDate
     And ta.Compensationdate < V_Yrenddate
     and st.genericdate2 < to_date('12/1/2015', 'mm/dd/yyyy')
     and ta.tenantid='AIAS'
     and ta.processingunitseq = Gv_Processingunitseq
     and st.compensationdate = ta.compensationdate
     and st.salesTransactionSeq = ta.salesTransactionSeq
     AND Ta.Genericattribute5 = 'PI - Direct Team' -- changed check ga5, and only create trxn for pi-direct team
     and ta.genericAttribute7 = 'FSAD'
     and cp.tenantid ='AIAS'
     and ta.positionName = cp.name
     And Cp.Effectivestartdate <= V_Compdate
     and cp.effectiveEndDate > V_Compdate
     and cp.removeDate = cdt_EndOfTime
     and cpa.tenantid='AIAS'
     and Cp.Payeeseq = Cpa.Payeeseq
     And Cpa.Effectivestartdate <= V_Compdate
     And Cpa.Effectiveenddate > V_Compdate
     and cpa.removeDate = cdt_EndOfTime
     And ((Cp.Genericattribute11 In ('FSAD', 'FSD') And
                         Cpa.Genericattribute1 Not In ('00', '0')) OR
                     (CP.Genericattribute11 In ('AM', 'FSM', 'FSC') And
                         CPa.Genericattribute1 In ('00', '0')))
     and st.tenantid = gata.tenantid(+)
     And St.Salestransactionseq = Gata.Salestransactionseq(+)
     and gata.pagenumber(+) = 0
            -- and st.salestransactionseq=14636698977976073
             ;
    
      Log('53 '||SQL%ROWCOUNT);
        commit;
    
    
        --     SequenceGenPkg.UpdateSeq('auditLogSeq');
    
      exception
        when NO_YRENDEVENTTYPE_FOUND then
          gv_error := 'Error [SP_TXNTXA_YREND_PIAOR]: the PI_Year_End event type is not found - ' ||
                      dbms_utility.format_error_backtrace;
          raise_application_error(-20000, gv_error);
    
        when INVALID_PERIODDATE then
          gv_error := 'Error [SP_TXNTXA_YREND_PIAOR]: the year start date  date are invalid - ' ||
                      dbms_utility.format_error_backtrace;
          raise_application_error(-20000, gv_error);
        when others then
          rollback;
          gv_error := 'Error [SP_TXNTXA_YREND_PIAOR]: ' || sqlerrm || ' - ' ||
                      dbms_utility.format_error_backtrace;
    
          comDebugger('PIAOR YR DEBUGGER', 'ERROR' || gv_error);
    
          raise_application_error(-20000, gv_error);
    
      end SP_TXNTXA_YREND_PIAOR;
    */
    --for revamp begin
    --Batch2
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__SP_TXA_NADOR_EXCEPTION') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_TXA_OVERRIDING_ASSIGNMENT' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__SP_TXA_OVERRIDING_ASSIGNMENT''...' );
go

/* ORIGSQL: procedure SP_TXA_OVERRIDING_ASSIGNMENT(i_periodSeq in int) as v_periodStartDate date; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__SP_TXA_OVERRIDING_ASSIGNMENT
(
    IN i_periodSeq BIGINT     /* ORIGSQL: i_periodSeq IN int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE gv_error VARCHAR(1000); /* package/session variable */
    DECLARE Gv_Setnumberordist BIGINT; /* package/session variable */
    DECLARE Gv_Setnumberoragy BIGINT; /* package/session variable */
    DECLARE Gv_Setnumberoragyanddist BIGINT; /* package/session variable */
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE v_periodStartDate TIMESTAMP;  /* ORIGSQL: v_periodStartDate date; */
    DECLARE V_Periodenddate TIMESTAMP;  /* ORIGSQL: V_Periodenddate Date; */
    DECLARE V_Componentvalue VARCHAR(30) = 'OVERRIDING_ASSIGNMENT';  /* ORIGSQL: V_Componentvalue Varchar2(30) := 'OVERRIDING_ASSIGNMENT'; */
    DECLARE V_Fyceventtypeseq BIGINT;  /* ORIGSQL: V_Fyceventtypeseq Int; */
    DECLARE V_Ryceventtypeseq BIGINT;  /* ORIGSQL: V_Ryceventtypeseq Int; */
    DECLARE V_ORyceventtypeseq BIGINT;  /* ORIGSQL: V_ORyceventtypeseq Int; */
    DECLARE V_Sscpeventtypeseq BIGINT;  /* ORIGSQL: V_Sscpeventtypeseq Int; */
    DECLARE V_Apieventtypeseq BIGINT;  /* ORIGSQL: V_Apieventtypeseq Int; */

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            gv_error = 'Error [SP_OVERRIDING_ASSIGNMENT]: ' || ::SQL_ERROR_MESSAGE || ' - ' ||  /* ORIGSQL: sqlerrm */

            /* RESOLVE: Standard Package call(not converted): 'dbms_utility.format_error_backtrace' not supported, manual conversion required */
            dbms_utility.format_error_backtrace;
            /* Saving modified package/session variable 'gv_error': */ 
            SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR' = :gv_error;

            /* ORIGSQL: rollback; */
            ROLLBACK;

            /* ORIGSQL: COMDEBUGGER('SP_TXA_OVERRIDING_ASSIGNMENT', gv_error) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SP_TXA_OVERRIDING_ASSIGNMENT', :gv_error);

            /* ORIGSQL: commit; */
            COMMIT;

            /* sapdbmtk: Closing RETURN in exception handler commented out, not supported in HANA */
            --RETURN;
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR') INTO gv_error FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERORDIST') AS BIGINT) INTO Gv_Setnumberordist FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERORAGY') AS BIGINT) INTO Gv_Setnumberoragy FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERORAGYANDDIST') AS BIGINT) INTO Gv_Setnumberoragyanddist FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
        /* end of package/session variables */

         

    SELECT
        startDate,
        endDate
    INTO
        v_periodStartDate,
        V_Periodenddate
    FROM
        cs_period
    WHERE
        periodSeq = :i_periodSeq;

    /* ORIGSQL: comInitialPartition('OA', v_componentValue, i_periodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__ComInitialpartition('OA', :V_Componentvalue, :i_periodSeq);

    V_Fyceventtypeseq = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('FYC');  /* ORIGSQL: Comgeteventtypeseq('FYC') */

    V_Ryceventtypeseq = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('RYC');  /* ORIGSQL: Comgeteventtypeseq('RYC') */

    V_ORyceventtypeseq = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('ORYC');  /* ORIGSQL: Comgeteventtypeseq('ORYC') */

    V_Sscpeventtypeseq = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('SSCP');  /* ORIGSQL: Comgeteventtypeseq('SSCP') */

    /* ORIGSQL: comDebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL1 START:' || SYSDATE) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL1 START:'|| CURRENT_TIMESTAMP 
    );  /* ORIGSQL: SYSDATE */

    --identify the vaild data
    --Revised by Win Tan at 20151119
    --begin
    /* ORIGSQL: Execute Immediate 'TRUNCATE TABLE temp_override_assign'; */
    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.TEMP_OVERRIDE_ASSIGN' not found */

    /* ORIGSQL: TRUNCATE TABLE temp_override_assign ; */
    EXECUTE IMMEDIATE 'TRUNCATE TABLE temp_override_assign';

    /* ORIGSQL: insert into temp_override_assign Select t.to_district as to_unit, t.to_agent, t.original_unit, t.effective_from, t.effective_to, t.policy_no, t.comp_code, Gv_Setnumberordist as setNumber from in_overr(...) */
    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.IN_OVERRIDE_ASSIGN' not found */
    INSERT INTO temp_override_assign
        SELECT   /* ORIGSQL: Select t.to_district as to_unit, t.to_agent, t.original_unit, t.effective_from, t.effective_to, t.policy_no, t.comp_code, Gv_Setnumberordist as setNumber from in_override_assign t where t.to_district (...) */
            t.to_district AS to_unit /* -- If to district IS NOT NULL, than generate an assignment for this district */, t.to_agent,
            t.original_unit,
            t.effective_from,
            t.effective_to,
            t.policy_no,
            t.comp_code,
            :Gv_Setnumberordist AS setNumber
        FROM
            in_override_assign t
        WHERE
            t.to_district IS NOT NULL
            AND t.to_district <> IFNULL(t.to_agency, 'aa')  /* ORIGSQL: nvl(t.to_agency, 'aa') */
UNION ALL
    SELECT   /* ORIGSQL: Select t2.to_agency as to_unit, t2.to_agent, t2.original_unit, t2.effective_from, t2.effective_to, t2.policy_no, t2.comp_code, Gv_Setnumberoragy as setNumber from in_override_assign t2 where t2.to_age(...) */
        t2.to_agency AS to_unit /* -- If to agency IS NOT NULL, than generate an assignment for this agency */, t2.to_agent,
        t2.original_unit,
        t2.effective_from,
        t2.effective_to,
        t2.policy_no,
        t2.comp_code,
        :Gv_Setnumberoragy AS setNumber
    FROM
        in_override_assign t2
    WHERE
        t2.to_agency IS NOT NULL
        AND t2.to_agency <> IFNULL(t2.to_district, 'aa')  /* ORIGSQL: nvl(t2.to_district, 'aa') */
UNION ALL
    SELECT   /* ORIGSQL: Select t3.to_agency as to_unit, t3.to_agent, t3.original_unit, t3.effective_from, t3.effective_to, t3.policy_no, t3.comp_code, Gv_Setnumberoragyanddist as setNumber from in_override_assign t3 where t3(...) */
        t3.to_agency AS to_unit /* -- If to agency = to district, than generate only one assignment for this district */, t3.to_agent,
        t3.original_unit,
        t3.effective_from,
        t3.effective_to,
        t3.policy_no,
        t3.comp_code,
        :Gv_Setnumberoragyanddist AS setNumber
    FROM
        in_override_assign t3
    WHERE
        t3.to_agency IS NOT NULL
        AND t3.to_district IS NOT NULL
        AND t3.to_district = t3.to_agency;

    /* ORIGSQL: log('SP_TXA_OVERRIDING_ASSIGNMENT 1 '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_TXA_OVERRIDING_ASSIGNMENT 1 '||::ROWCOUNT);  

    /* ORIGSQL: commit; */
    COMMIT;

    --end

    /* ORIGSQL: insert / *+APPEND* / */
    /* ORIGSQL: insert into sh_query_result (component, periodseq, genericSequence1, genericSequence2, genericNumber1, genericDate1, genericAttribute1, genericAttribute2, genericAttribute3, genericAttribute11, generi(...) */
    INSERT INTO sh_query_result
        (
            component,
            periodseq,
            genericSequence1,
            genericSequence2,
            genericNumber1,
            genericDate1,
            genericAttribute1,
            genericAttribute2,
            genericAttribute3,
            genericAttribute11,
            genericAttribute12,
            genericAttribute13,
            genericAttribute14,
            genericNumber2,
            genericAttribute15,
            genericAttribute16,
            genericNumber3,
            genericSequence4,
            genericSequence5
        )
        /* ORIGSQL: Select / *+ leading(os,cs,ta) USE_HASH(os,cs) FULL(cs) * / */
        SELECT   /* ORIGSQL: Select V_Componentvalue, i_periodSeq, cs.salestransactionSeq, Cs.Salesorderseq, OS.SETNUMBER, cs.compensationDate, os.to_unit, os.to_agent, Cs.Businessunitmap, ts.genericattribute11, ts.genericattribu(...) */
            :V_Componentvalue,
            :i_periodSeq,
            cs.salestransactionSeq,
            Cs.Salesorderseq,
            OS.SETNUMBER,
            cs.compensationDate,
            os.to_unit,
            os.to_agent,
            Cs.Businessunitmap,
            ts.genericattribute11,
            ts.genericattribute12,
            ts.genericattribute13,
            ts.genericattribute14,
            ts.genericnumber1,
            ts.genericattribute15,
            ts.genericattribute16,
            ts.genericnumber2,
            ts.unittypeforgenericnumber1,
            ts.unittypeforgenericnumber2
        FROM
            cs_transactionassignment ts
        INNER JOIN
            cs_salestransaction cs
            ON ts.salestransactionseq = cs.salestransactionseq
        INNER JOIN
            temp_override_assign os
            ON os.policy_no = cs.ponumber
            AND os.comp_code = cs.productid
            AND cs.compensationdate >= os.effective_from
            AND cs.compensationdate < os.effective_to
        WHERE
            cs.tenantid = 'AIAS'
            AND ts.tenantid = 'AIAS'
            AND cs.processingunitseq = :Gv_Processingunitseq
            AND ts.processingunitseq = :Gv_Processingunitseq
            AND 'SGY' || IFNULL(os.original_unit,'') = ts.positionname
            AND cs.compensationdate >= :v_periodStartDate
            AND cs.compensationdate < :V_Periodenddate
            AND ts.compensationdate >= :v_periodStartDate
            AND ts.compensationdate < :V_Periodenddate
            AND cs.eventtypeseq IN
            (:V_Fyceventtypeseq, :V_Ryceventtypeseq,:V_ORyceventtypeseq, :V_Sscpeventtypeseq)
            AND cs.genericdate2 >= sapdbmtk.sp_f_dbmtk_format_string_to_datetime('12/1/2015', 'mm/dd/yyyy')  /* ORIGSQL: to_date('12/1/2015', 'mm/dd/yyyy') */
            AND ((cs.productname IN ('PA', 'HS', 'LF')
                    AND ts.genericattribute13 IN ('W', 'WC'))
                OR (cs.productname IN ('CS', 'CL')
            AND ts.genericattribute13 = 'C'))
            AND (ts.genericattribute4 IS NULL -- do not overlap with PI, APR, NADOR transaction assignment updates
                OR (ts.genericattribute4 NOT LIKE '%NADOR%'
                    AND ts.genericattribute4 NOT LIKE '%AOR%'
            AND ts.genericattribute4 NOT LIKE '%PI%'));

    /* ORIGSQL: log('SP_TXA_OVERRIDING_ASSIGNMENT 2 '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_TXA_OVERRIDING_ASSIGNMENT 2 '||::ROWCOUNT);  

    /* ORIGSQL: comDebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL1 END:' || SYSDATE || ' - ReusltNumber' || sql%rowcount) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL1 END:'|| CURRENT_TIMESTAMP || ' - ReusltNumber'|| ::ROWCOUNT   
    );  /* ORIGSQL: SYSDATE */

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Comdebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL2 START:' || Sysdate) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL2 START:'|| CURRENT_TIMESTAMP 
    );  /* ORIGSQL: Sysdate */

    /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
    /* ORIGSQL: Merge Into Cs_Transactionassignment Ta Using (SELECT distinct T1.Genericsequence1 AS Salestransactionseq, t1.genericSequence2 AS salesorderSeq, T1.Genericnumber1 AS Setnumber, t1.Genericdate1 AS Compe(...) */
    MERGE INTO Cs_Transactionassignment AS Ta 
        USING
        (
            SELECT   /* ORIGSQL: (Select distinct T1.Genericsequence1 As Salestransactionseq, t1.genericSequence2 as salesorderSeq, T1.Genericnumber1 As Setnumber, t1.Genericdate1 As Compensationdate, 'SGY' || T1.Genericattribute1 As(...) */
                DISTINCT
                T1.Genericsequence1 AS Salestransactionseq,
                t1.genericSequence2 AS salesorderSeq,
                T1.Genericnumber1 AS Setnumber,
                t1.Genericdate1 AS Compensationdate,
                'SGY'|| IFNULL(T1.Genericattribute1,'') AS Positionname,
                NULL AS payeeid,
                'ORASGMT' AS genericAttribute4,
                /* --T1.Genericattribute3 As Businessunitmap, */
                T1.genericattribute11 AS ClassCodeIssueDate,
                T1.genericattribute12 AS LeaderTitleIssueDate,
                T1.genericattribute13 AS AgencyIndicator,
                T1.genericattribute14 AS WritingAgent,
                T1.genericnumber2 AS PercentSpilt,
                T1.genericattribute15 AS ClassCodeIssueDate2,
                T1.genericattribute16 AS WritingAgent2,
                T1.genericnumber3 AS PercentSpilt2,
                T1.Genericsequence4 AS unittypeforgenericnumber1,
                T1.Genericsequence5 AS unittypeforgenericnumber2,
                :Gv_Processingunitseq AS processingUnitSeq
            FROM
                sh_query_result T1
            WHERE
                1 = 1
                AND T1.Component = :V_Componentvalue
                AND t1.periodseq = :Gv_Periodseq
        ) AS R
        ON (Ta.Salestransactionseq = R.Salestransactionseq
        AND ta.positionName = r.Positionname)
    WHEN NOT MATCHED THEN
        INSERT
            (Ta.Salestransactionseq,
                Ta.Salesorderseq,
                Ta.Setnumber,
                Ta.Compensationdate,
                Ta.Positionname,
                Ta.Payeeid,
                Ta.Genericattribute4,
                Ta.genericattribute11,
                Ta.genericattribute12,
                Ta.genericattribute13,
                Ta.genericattribute14,
                Ta.Genericnumber1,
                Ta.genericattribute15,
                Ta.genericattribute16,
                Ta.Genericnumber2,
                Ta.unittypeforgenericnumber1,
                Ta.unittypeforgenericnumber2,
            Ta.PROCESSINGUNITSEQ)
        VALUES
            (R.Salestransactionseq,
                R.Salesorderseq,
                R.SETNUMBER,
                R.Compensationdate,
                R.Positionname,
                R.Payeeid,
                R.Genericattribute4,
                R.ClassCodeIssueDate,
                R.LeaderTitleIssueDate,
                R.AgencyIndicator,
                R.WritingAgent,
                R.PercentSpilt,
                R.ClassCodeIssueDate2,
                R.WritingAgent2,
                R.PercentSpilt2,
                R.unittypeforgenericnumber1,
                R.unittypeforgenericnumber2,
            R.PROCESSINGUNITSEQ);,
    Ta.Compensationdate,
    Ta.Positionname,
    Ta.Payeeid,
    Ta.Genericattribute4,
    Ta.genericattribute11,
    Ta.genericattribute12,
    Ta.genericattribute13,
    Ta.genericattribute14,
    Ta.Genericnumber1,
    Ta.genericattribute15,
    Ta.genericattribute16,
    Ta.Genericnumber2,
    Ta.unittypeforgenericnumber1,
    Ta.unittypeforgenericnumber2,
Ta.PROCESSINGUNITSEQ)
VALUES
(R.Salestransactionseq,
    R.Salesorderseq,
    R.SETNUMBER,
    R.Compensationdate,
    R.Positionname,
    R.Payeeid,
    R.Genericattribute4,
    R.ClassCodeIssueDate,
    R.LeaderTitleIssueDate,
    R.AgencyIndicator,
    R.WritingAgent,
    R.PercentSpilt,
    R.ClassCodeIssueDate2,
    R.WritingAgent2,
    R.PercentSpilt2,
    R.unittypeforgenericnumber1,
    R.unittypeforgenericnumber2,
R.PROCESSINGUNITSEQ);;/* NOT CONVERTED! */

    /* ORIGSQL: log('SP_TXA_OVERRIDING_ASSIGNMENT 3 '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_TXA_OVERRIDING_ASSIGNMENT 3 '||::ROWCOUNT);  

    /* ORIGSQL: Comdebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL2 END:' || Sysdate || ' - ReusltNumber' || Sql%Rowcount) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL2 END:'|| CURRENT_TIMESTAMP || ' - ReusltNumber'|| ::ROWCOUNT   
    );  /* ORIGSQL: Sysdate */

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Comdebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL3 START:' || Sysdate) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL3 START:'|| CURRENT_TIMESTAMP 
    );  /* ORIGSQL: Sysdate */

    --update txn EB5
    /* ORIGSQL: update / *+ INDEX(cs_gaSalestransaction AIA_Cs_gaSalestransaction_SEQ) * / */
    /* ORIGSQL: update cs_gaSalestransaction SET genericBoolean5 = 1 where salestransactionSeq in (SELECT r.genericSequence1 FROM sh_query_result r Where r.Component = V_Componentvalue and r.periodSeq = gv_periodseq)(...) */
    UPDATE cs_gaSalestransaction
        SET
        /* ORIGSQL: genericBoolean5 = */
        genericBoolean5 = 1
    FROM
        cs_gaSalestransaction
    WHERE
        salestransactionSeq  
        IN
        (
            SELECT   /* ORIGSQL: (select r.genericSequence1 from sh_query_result r Where r.Component = V_Componentvalue and r.periodSeq = gv_periodseq) */
                r.genericSequence1
            FROM
                sh_query_result r
            WHERE
                r.Component = :V_Componentvalue
                AND r.periodSeq = :Gv_Periodseq
        )
        AND PAGENUMBER = 0;

    /* ORIGSQL: Comdebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL3 END:' || Sysdate || ' - ReusltNumber' || Sql%Rowcount) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL3 END:'|| CURRENT_TIMESTAMP || ' - ReusltNumber'|| ::ROWCOUNT   
    );  /* ORIGSQL: Sysdate */

    /* ORIGSQL: log('SP_TXA_OVERRIDING_ASSIGNMENT 4 '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_TXA_OVERRIDING_ASSIGNMENT 4 '||::ROWCOUNT);  

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Comdebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL4 START:' || Sysdate) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL4 START:'|| CURRENT_TIMESTAMP 
    );  /* ORIGSQL: Sysdate */

    --update txn EA1, EA2

    /* ORIGSQL: update / *+ INDEX(ga AIA_Cs_gaSalestransaction_SEQ) * / */
    /* ORIGSQL: update cs_gaSalestransaction ga SET ga.genericAttribute1 = (SELECT 'SGY'|| r.genericattribute1 FROM sh_query_result r where r.Component = V_Componentvalue and r.periodSeq = gv_periodseq and r.genericn(...) */
    UPDATE cs_gaSalestransaction ga 
        SET
        /* ORIGSQL: ga.genericAttribute1 = */
        genericAttribute1 = (
            /* RESOLVE: Review semantics in source vs. target DBMS: LIMIT/OFFSET without ORDER BY: consistent results not guaranteed */
            SELECT   /* ORIGSQL: (select 'SGY'|| r.genericattribute1 from sh_query_result r where r.Component = V_Componentvalue and r.periodSeq = gv_periodseq and r.genericnumber1 in (Gv_Setnumberoragy, Gv_Setnumberoragyanddist) and(...) */
                'SGY'|| IFNULL(r.genericattribute1,'')
            FROM
                sh_query_result r
            WHERE
                r.Component = :V_Componentvalue
                AND r.periodSeq = :Gv_Periodseq
                AND r.genericnumber1 IN
                (:Gv_Setnumberoragy, :Gv_Setnumberoragyanddist)
                AND ga.salestransactionseq = r.genericsequence1
                AND ga.PAGENUMBER = 0
            LIMIT 1  /* ORIGSQL: rownum = 1 */
        )
    WHERE
        ga.PAGENUMBER = 0
        AND 
        EXISTS
        (
            SELECT   /* ORIGSQL: (select 1 from sh_query_result sh where sh.genericSequence1 = ga.salestransactionSeq and sh.genericnumber1 in (Gv_Setnumberoragy, Gv_Setnumberoragyanddist) and sh.Component = v_componentValue and sh.p(...) */
                1
            FROM
                sh_query_result sh
            WHERE
                sh.genericSequence1 = ga.salestransactionSeq
                AND sh.genericnumber1 IN
                (:Gv_Setnumberoragy, :Gv_Setnumberoragyanddist)
                AND sh.Component = :V_Componentvalue
                AND sh.periodSeq = :Gv_Periodseq
        );

    /* ORIGSQL: log('SP_TXA_OVERRIDING_ASSIGNMENT 5 '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_TXA_OVERRIDING_ASSIGNMENT 5 '||::ROWCOUNT);  

    /* ORIGSQL: Comdebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL4 END:' || Sysdate || ' - ReusltNumber' || Sql%Rowcount) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL4 END:'|| CURRENT_TIMESTAMP || ' - ReusltNumber'|| ::ROWCOUNT   
    );  /* ORIGSQL: Sysdate */

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Comdebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL5 START:' || Sysdate) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL5 START:'|| CURRENT_TIMESTAMP 
    );  /* ORIGSQL: Sysdate */

    /* ORIGSQL: update / *+ INDEX(ga AIA_Cs_gaSalestransaction_SEQ) * / */
    /* ORIGSQL: update cs_gaSalestransaction ga SET ga.genericAttribute2 = (SELECT 'SGY'|| r.genericattribute1 FROM sh_query_result r where r.Component = V_Componentvalue and r.periodSeq = gv_periodseq and r.genericn(...) */
    UPDATE cs_gaSalestransaction ga 
        SET
        /* ORIGSQL: ga.genericAttribute2 = */
        genericAttribute2 = (
            /* RESOLVE: Review semantics in source vs. target DBMS: LIMIT/OFFSET without ORDER BY: consistent results not guaranteed */
            SELECT   /* ORIGSQL: (select 'SGY'|| r.genericattribute1 from sh_query_result r where r.Component = V_Componentvalue and r.periodSeq = gv_periodseq and r.genericnumber1 in (Gv_Setnumberordist, Gv_Setnumberoragyanddist) an(...) */
                'SGY'|| IFNULL(r.genericattribute1,'')
            FROM
                sh_query_result r
            WHERE
                r.Component = :V_Componentvalue
                AND r.periodSeq = :Gv_Periodseq
                AND r.genericnumber1 IN
                (:Gv_Setnumberordist, :Gv_Setnumberoragyanddist)
                AND ga.salestransactionseq = r.genericsequence1
                AND ga.PAGENUMBER = 0
            LIMIT 1  /* ORIGSQL: rownum = 1 */
        )
    WHERE 
        EXISTS
        (
            SELECT   /* ORIGSQL: (select 1 from sh_query_result sh where sh.genericSequence1 = ga.salestransactionSeq and sh.genericnumber1 in (Gv_Setnumberordist, Gv_Setnumberoragyanddist) and ga.PAGENUMBER = 0 and sh.Component = v_(...) */
                1
            FROM
                sh_query_result sh
            WHERE
                sh.genericSequence1 = ga.salestransactionSeq
                AND sh.genericnumber1 IN
                (:Gv_Setnumberordist, :Gv_Setnumberoragyanddist)
                AND ga.PAGENUMBER = 0
                AND sh.Component = :V_Componentvalue
                AND sh.periodSeq = :Gv_Periodseq
        );

    /* ORIGSQL: Comdebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL5 END:' || Sysdate || ' - ReusltNumber' || Sql%Rowcount) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('SQL Performance', 'Stagehook[SP_OVERRIDING_ASSIGNMENT]-SQL5 END:'|| CURRENT_TIMESTAMP || ' - ReusltNumber'|| ::ROWCOUNT   
    );  /* ORIGSQL: Sysdate */

    /* ORIGSQL: log('SP_TXA_OVERRIDING_ASSIGNMENT 6 '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_TXA_OVERRIDING_ASSIGNMENT 6 '||::ROWCOUNT);  

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: exception when others then */
END;
--for revamp end
/**
SP_CLAWBACK_CALCULATION: this procedure is for Fair BSC project to insert the data to TrueComp build-in tables
1. Insert the data into cs_credit from AIA_CB_CREDIT_STG by clawback batch number
2. Insert the data into cs_measurement from AIA_CB_PM_STG by clawback batch number
3. Insert the data into cs_pmcredittrace from AIA_CB_PMCRDTRACE_STG by clawback batch number
**/
--Added for version 3
--by Win Tan
--begin
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__SP_TXA_OVERRIDING_ASSIGNMENT') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_CLAWBACK_CALCULATION' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__SP_CLAWBACK_CALCULATION''...' );
go

/* ORIGSQL: procedure SP_CLAWBACK_CALCULATION(i_periodSeq in int) as type tRun is record (pipelineRunSeq CS_PipelineRun.pipelineRunSeq%type, startTime CS_PipelineRun.startTime%type, stopTime CS_PipelineRun.stopTi(...) */
CREATE OR REPLACE PROCEDURE EXT.SP_CLAWBACK_CALCULATION
(
    IN i_periodSeq BIGINT     /* ORIGSQL: i_periodSeq IN int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */
    DECLARE gv_calendarSeq BIGINT; /* package/session variable */
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE v_tempcount BIGINT;  /* ORIGSQL: v_tempcount integer; */
    DECLARE v_pipelinerunseq BIGINT;  /* ORIGSQL: v_pipelinerunseq integer; */
    DECLARE v_pipelinerundate TIMESTAMP;  /* ORIGSQL: v_pipelinerundate date; */
    DECLARE v_batch_no_lumpsum_comm BIGINT;  /* ORIGSQL: v_batch_no_lumpsum_comm integer; */
    DECLARE v_batch_no_lumpsum_comp BIGINT;  /* ORIGSQL: v_batch_no_lumpsum_comp integer; */
    DECLARE v_batch_no_ongoing_comm BIGINT;  /* ORIGSQL: v_batch_no_ongoing_comm integer; */
    DECLARE v_batch_no_ongoing_comp BIGINT;  /* ORIGSQL: v_batch_no_ongoing_comp integer; */
    DECLARE v_processingunitseq BIGINT;  /* ORIGSQL: v_processingunitseq integer; */
    DECLARE v_str_cycledate VARCHAR(20);  /* ORIGSQL: v_str_cycledate VARCHAR2(20); */
    DECLARE v_period_start TIMESTAMP;  /* ORIGSQL: v_period_start date; */
    DECLARE v_period_end TIMESTAMP;  /* ORIGSQL: v_period_end date; */
    DECLARE STR_CYCLEDATE_FILE_NAME CONSTANT VARCHAR(10) = 'GLOBAL';  /* ORIGSQL: STR_CYCLEDATE_FILE_NAME CONSTANT VARCHAR2(10) := 'GLOBAL'; */
    DECLARE STR_CYCLEDATE_KEY CONSTANT VARCHAR(20) = 'OPER_CYCLE_DATE';  /* ORIGSQL: STR_CYCLEDATE_KEY CONSTANT VARCHAR2(20) := 'OPER_CYCLE_DATE'; */
    DECLARE STR_LUMPSUM CONSTANT VARCHAR(20) = 'LUMPSUM';  /* ORIGSQL: STR_LUMPSUM CONSTANT VARCHAR2(20) := 'LUMPSUM'; */
    DECLARE STR_ONGOING CONSTANT VARCHAR(20) = 'ONGOING';  /* ORIGSQL: STR_ONGOING CONSTANT VARCHAR2(20) := 'ONGOING'; */
    DECLARE STR_COMMISSION CONSTANT VARCHAR(20) = 'COMMISSION';  /* ORIGSQL: STR_COMMISSION CONSTANT VARCHAR2(20) := 'COMMISSION'; */
    DECLARE STR_COMPENSATION CONSTANT VARCHAR(20) = 'COMPENSATION';  /* ORIGSQL: STR_COMPENSATION CONSTANT VARCHAR2(20) := 'COMPENSATION'; */
    DECLARE STR_STATUS_START CONSTANT VARCHAR(20) = 'start';  /* ORIGSQL: STR_STATUS_START CONSTANT VARCHAR2(20) := 'start'; */
    DECLARE STR_STATUS_PROCESSING CONSTANT VARCHAR(20) = 'processing';  /* ORIGSQL: STR_STATUS_PROCESSING CONSTANT VARCHAR2(20) := 'processing'; */
    DECLARE STR_STATUS_FAIL CONSTANT VARCHAR(20) = 'fail';  /* ORIGSQL: STR_STATUS_FAIL CONSTANT VARCHAR2(20) := 'fail'; */
    DECLARE STR_STATUS_COMPLETED_SP CONSTANT VARCHAR(20) = 'completed_sp';  /* ORIGSQL: STR_STATUS_COMPLETED_SP CONSTANT VARCHAR2(20) := 'completed_sp'; */
    DECLARE STR_STATUS_COMPLETED_SH CONSTANT VARCHAR(20) = 'completed_sh';  /* ORIGSQL: STR_STATUS_COMPLETED_SH CONSTANT VARCHAR2(20) := 'completed_sh'; */
    DECLARE V_MESSAGE VARCHAR(2000);  /* ORIGSQL: V_MESSAGE VARCHAR2(2000); */
    DECLARE v_batch_no_special BIGINT;  /* ORIGSQL: v_batch_no_special integer; */

    --added by Win for version 6
    --version 14 add by Amanda begin
    DECLARE v_periodStartDate TIMESTAMP;  /* ORIGSQL: v_periodStartDate date; */
    DECLARE v_previous_qtr VARCHAR(10);  /* ORIGSQL: v_previous_qtr varchar2(10); */

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: WHEN OTHERS THEN */
        BEGIN
            V_MESSAGE = SUBSTRING(::SQL_ERROR_MESSAGE,1,2000);  /* ORIGSQL: SUBSTR(SQLERRM,1,2000) */

            /* ORIGSQL: Log('[CB] ' || v_message) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] '|| IFNULL(:V_MESSAGE,''));

            --update the batch status to fail
            /* ORIGSQL: PK_AIA_CB_CALCULATION.sp_update_batch_status(v_batch_no_lumpsum_comm, STR_STATUS_FAIL) */
            CALL PK_AIA_CB_CALCULATION.sp_update_batch_status(:v_batch_no_lumpsum_comm, :STR_STATUS_FAIL);

            /* ORIGSQL: PK_AIA_CB_CALCULATION.sp_update_batch_status(v_batch_no_ongoing_comm, STR_STATUS_FAIL) */
            CALL PK_AIA_CB_CALCULATION.sp_update_batch_status(:v_batch_no_ongoing_comm, :STR_STATUS_FAIL);

            /* ORIGSQL: PK_AIA_CB_CALCULATION.sp_update_batch_status(v_batch_no_lumpsum_comp, STR_STATUS_FAIL) */
            CALL PK_AIA_CB_CALCULATION.sp_update_batch_status(:v_batch_no_lumpsum_comp, :STR_STATUS_FAIL);

            /* ORIGSQL: PK_AIA_CB_CALCULATION.sp_update_batch_status(v_batch_no_ongoing_comp, STR_STATUS_FAIL) */
            CALL PK_AIA_CB_CALCULATION.sp_update_batch_status(:v_batch_no_ongoing_comp, :STR_STATUS_FAIL);
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CALENDARSEQ') AS BIGINT) INTO gv_calendarSeq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
        /* end of package/session variables */



    /*---TYPE definition moved to  scripts/dbmtk_create_types.sqlscript ---
    type  tRun is record
    (
        pipelineRunSeq     CS_PipelineRun.pipelineRunSeq%type,  *//* RESOLVE: Identifier not found: Table/Column 'CS_PipelineRun.pipelineRunSeq' not found (for %TYPE declaration) *//*
        startTime          CS_PipelineRun.startTime%type,  *//* RESOLVE: Identifier not found: Table/Column 'CS_PipelineRun.startTime' not found (for %TYPE declaration) *//*
        stopTime           CS_PipelineRun.stopTime%type,  *//* RESOLVE: Identifier not found: Table/Column 'CS_PipelineRun.stopTime' not found (for %TYPE declaration) *//*
        periodSeq          CS_PipelineRun.periodSeq%type,  *//* RESOLVE: Identifier not found: Table/Column 'CS_PipelineRun.periodSeq' not found (for %TYPE declaration) *//*
        runMode            CS_PipelineRun.runMode%type,  *//* RESOLVE: Identifier not found: Table/Column 'CS_PipelineRun.runMode' not found (for %TYPE declaration) *//*
        stageTypeSeq       CS_PipelineRun.stageTypeSeq%type,  *//* RESOLVE: Identifier not found: Table/Column 'CS_PipelineRun.stageTypeSeq' not found (for %TYPE declaration) *//*
        status             CS_PipelineRun.status%type,  *//* RESOLVE: Identifier not found: Table/Column 'CS_PipelineRun.status' not found (for %TYPE declaration) *//*
        processingUnitSeq  CS_PipelineRun.processingUnitSeq%type  *//* RESOLVE: Identifier not found: Table/Column 'CS_PipelineRun.processingUnitSeq' not found (for %TYPE declaration) *//*
    );
    ---end of TYPE definition commented out---*/ 
    --version 14 end

    --get cycle date
    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.IN_ETL_CONTROL' not found */

    SELECT
        TXT_KEY_VALUE
    INTO
        v_str_cycledate
    FROM
        IN_ETL_CONTROL
    WHERE
        TXT_FILE_NAME = :STR_CYCLEDATE_FILE_NAME
        AND TXT_KEY_STRING = :STR_CYCLEDATE_KEY;

    /* ORIGSQL: Log('[CB] Oper cycle date is: ' || v_str_cycledate) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Oper cycle date is: '|| IFNULL(:v_str_cycledate,''));

    --get period start date and period end date 
    SELECT
        cp.startdate,
        (cp.enddate - 1)
    INTO
        v_period_start,
        v_period_end
    FROM
        cs_period cp
    WHERE
        cp.periodseq = :Gv_Periodseq;

    --if current cycle date not between pipeline period, then exit.
    IF sapdbmtk.sp_f_dbmtk_format_string_to_datetime(:v_str_cycledate,'yyyy-mm-dd') BETWEEN :v_period_start AND :v_period_end  /* ORIGSQL: to_date(v_str_cycledate,'yyyy-mm-dd') */
    THEN
        /* ORIGSQL: Log('[CB] SP_EXEC_COMMISSION_ONGOING starting ' || v_str_cycledate) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] SP_EXEC_COMMISSION_ONGOING starting '|| IFNULL(:v_str_cycledate,''));

        /* ORIGSQL: PK_AIA_CB_CALCULATION.SP_EXEC_COMMISSION_ONGOING(v_str_cycledate) */
        CALL PK_AIA_CB_CALCULATION.SP_EXEC_COMMISSION_ONGOING(:v_str_cycledate);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION.SP_EXEC_COMMISSION_ONGOING' */

        /* ORIGSQL: Log('[CB] SP_EXEC_COMMISSION_ONGOING ending') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] SP_EXEC_COMMISSION_ONGOING ending');

        /* ORIGSQL: Log('[CB] SP_EXEC_COMPENSATION_ONGOING starting') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] SP_EXEC_COMPENSATION_ONGOING starting');

        /* ORIGSQL: PK_AIA_CB_CALCULATION.SP_EXEC_COMPENSATION_ONGOING(v_str_cycledate) */
        CALL PK_AIA_CB_CALCULATION.SP_EXEC_COMPENSATION_ONGOING(:v_str_cycledate);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION.SP_EXEC_COMPENSATION_ONGOING' */

        /* ORIGSQL: Log('[CB] SP_EXEC_COMPENSATION_ONGOING ended') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] SP_EXEC_COMPENSATION_ONGOING ended');

        --get pipeline run sequence number
        --  v_pipelinerunseq := tcmp.pipelinerun.GetLatestActiveRunSeq(i_periodSeq, gv_processingUnitSeq);

        --get pipeline run date
        --  v_pipelinerundate := tcmp.pipelinerun.GetRunDate(v_pipelinerunseq, gv_processingUnitSeq);

        /*Arjun 0607 - to get around the grants. temporary*/
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_PIPELINERUN' not found */

        SELECT
            MAX(y.pipelinerunseq),
            MAX(y.starttime)
        INTO
            v_pipelinerunseq,
            v_pipelinerundate
        FROM
            cs_pipelinerun y
        WHERE
            y.command = 'PipelineRun'
            AND y.stoptime IS NULL
            AND y.starttime  
            =
            (
                SELECT   /* ORIGSQL: (Select MAX(x.starttime) from cs_pipelinerun x where x.command='PipelineRun' and x.stoptime IS NULL) */
                    MAX(x.starttime)
                FROM
                    cs_pipelinerun x
                WHERE
                    x.command = 'PipelineRun'
                    AND x.stoptime IS NULL
            );

        IF :v_pipelinerundate IS NULL
        THEN 
            SELECT
                MAX(pipelinerunseq),
                CURRENT_TIMESTAMP   /* ORIGSQL: sysdate */
            INTO
                v_pipelinerunseq,
                v_pipelinerundate
            FROM
                cs_pipelinerun y
            WHERE
                y.command = 'PipelineRun';
        END IF;

        --added by Win for version 6
        --begin
        --get the batch number for special handling
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.AIA_CB_BATCH_SPECIAL' not found */

        SELECT
            IFNULL(MAX(batchnum), 0)  /* ORIGSQL: nvl(max(batchnum), 0) */
        INTO
            v_batch_no_special
        FROM
            aia_cb_batch_special
        WHERE
            ISACTIVE = 'Y'
            AND SPEC_RUN_DATE = sapdbmtk.sp_f_dbmtk_format_string_to_datetime(:v_str_cycledate, 'yyyy-mm-dd')  /* ORIGSQL: to_date(v_str_cycledate, 'yyyy-mm-dd') */
            AND BUNAME = 'SGPAGY';--v19 add BUNAME

        /* ORIGSQL: Log('[CB] Special run batch number is: ' || v_batch_no_special) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Special run batch number is: '|| IFNULL(TO_VARCHAR(:v_batch_no_special),''));

        --end

        --get active batch number for lumpsum commission
        v_batch_no_lumpsum_comm = PK_AIA_CB_CALCULATION.fn_get_batch_no(:v_str_cycledate, :STR_COMMISSION, :STR_LUMPSUM, :STR_STATUS_COMPLETED_SP);

        IF :v_batch_no_lumpsum_comm = 0
        THEN
            v_batch_no_lumpsum_comm = PK_AIA_CB_CALCULATION.fn_get_batch_no(:v_str_cycledate, :STR_COMMISSION, :STR_LUMPSUM, :STR_STATUS_COMPLETED_SH);
        END IF;

        /* ORIGSQL: Log('[CB] Clawback batch for commission LUMPSUM: ' || v_batch_no_lumpsum_comm) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Clawback batch for commission LUMPSUM: '|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comm),''));

        /* ORIGSQL: PK_AIA_CB_CALCULATION.sp_revert_by_batch(v_batch_no_lumpsum_comm) */
        CALL PK_AIA_CB_CALCULATION.sp_revert_by_batch(:v_batch_no_lumpsum_comm);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION.sp_revert_by_batch' */

        --get active batch number for on-going commission
        v_batch_no_ongoing_comm = PK_AIA_CB_CALCULATION.fn_get_batch_no(:v_str_cycledate, :STR_COMMISSION, :STR_ONGOING, :STR_STATUS_COMPLETED_SP);

        /* ORIGSQL: Log('[CB] Clawback batch for commission ONGOING: ' || v_batch_no_ongoing_comm) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Clawback batch for commission ONGOING: '|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comm),''));

        /* ORIGSQL: PK_AIA_CB_CALCULATION.sp_revert_by_batch(v_batch_no_ongoing_comm) */
        CALL PK_AIA_CB_CALCULATION.sp_revert_by_batch(:v_batch_no_ongoing_comm);

        --get active batch number for lumpsum compensation
        v_batch_no_lumpsum_comp = PK_AIA_CB_CALCULATION.fn_get_batch_no(:v_str_cycledate, :STR_COMPENSATION, :STR_LUMPSUM, :STR_STATUS_COMPLETED_SP);

        IF :v_batch_no_lumpsum_comp = 0
        THEN
            v_batch_no_lumpsum_comp = PK_AIA_CB_CALCULATION.fn_get_batch_no(:v_str_cycledate, :STR_COMPENSATION, :STR_LUMPSUM, :STR_STATUS_COMPLETED_SH);
        END IF;
        /* ORIGSQL: Log('[CB] Clawback batch for compensation LUMPSUM: ' || v_batch_no_lumpsum_comp) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Clawback batch for compensation LUMPSUM: '|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comp),''));

        /* ORIGSQL: PK_AIA_CB_CALCULATION.sp_revert_by_batch(v_batch_no_lumpsum_comp) */
        CALL PK_AIA_CB_CALCULATION.sp_revert_by_batch(:v_batch_no_lumpsum_comp);

        --get active batch number for on-going compensation
        v_batch_no_ongoing_comp = PK_AIA_CB_CALCULATION.fn_get_batch_no(:v_str_cycledate, :STR_COMPENSATION, :STR_ONGOING, :STR_STATUS_COMPLETED_SP);

        /* ORIGSQL: Log('[CB] Clawback batch for compensation ONGOING: ' || v_batch_no_ongoing_comp) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Clawback batch for compensation ONGOING: '|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comp),''));

        /* ORIGSQL: PK_AIA_CB_CALCULATION.sp_revert_by_batch(v_batch_no_ongoing_comp) */
        CALL PK_AIA_CB_CALCULATION.sp_revert_by_batch(:v_batch_no_ongoing_comp);

        --prepare the commission clawback data for insert to TrueComp build in tables
        --credit
        /* ORIGSQL: PK_AIA_CB_CALCULATION.SP_CREDIT_COMMISSION (v_str_cycledate, v_batch_no_lumpsum_comm, v_batch_no_ongoing_comm) */
        CALL PK_AIA_CB_CALCULATION.SP_CREDIT_COMMISSION(:v_str_cycledate, :v_batch_no_lumpsum_comm, :v_batch_no_ongoing_comm);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION.SP_CREDIT_COMMISSION' */

        --primary measurement
        /* ORIGSQL: PK_AIA_CB_CALCULATION.SP_PM_COMMISSION (v_str_cycledate, v_batch_no_lumpsum_comm, v_batch_no_ongoing_comm) */
        CALL PK_AIA_CB_CALCULATION.SP_PM_COMMISSION(:v_str_cycledate, :v_batch_no_lumpsum_comm, :v_batch_no_ongoing_comm);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION.SP_PM_COMMISSION' */

        --pm credit trace
        /* ORIGSQL: PK_AIA_CB_CALCULATION.SP_PMCRDTRACE_COMMISSION (v_str_cycledate, v_batch_no_lumpsum_comm, v_batch_no_ongoing_comm) */
        CALL PK_AIA_CB_CALCULATION.SP_PMCRDTRACE_COMMISSION(:v_str_cycledate, :v_batch_no_lumpsum_comm, :v_batch_no_ongoing_comm);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION.SP_PMCRDTRACE_COMMISSION' */

        --Added by Win Tan for version 4 **Begin**
        IF sapdbmtk.sp_f_dbmtk_format_string_to_datetime(:v_str_cycledate,'yyyy-mm-dd') = :v_period_end  /* ORIGSQL: to_date(v_str_cycledate,'yyyy-mm-dd') */
        THEN
            --prepare the compensation clawback data for insert to TrueComp build in tables
            --credit
            /* ORIGSQL: PK_AIA_CB_CALCULATION.SP_CREDIT_COMP (v_str_cycledate, v_batch_no_lumpsum_comp, v_batch_no_ongoing_comp) */
            CALL PK_AIA_CB_CALCULATION.SP_CREDIT_COMP(:v_str_cycledate, :v_batch_no_lumpsum_comp, :v_batch_no_ongoing_comp);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION.SP_CREDIT_COMP' */

            --primary measurement
            /* ORIGSQL: PK_AIA_CB_CALCULATION.SP_PM_COMP (v_str_cycledate, v_batch_no_lumpsum_comp, v_batch_no_ongoing_comp) */
            CALL PK_AIA_CB_CALCULATION.SP_PM_COMP(:v_str_cycledate, :v_batch_no_lumpsum_comp, :v_batch_no_ongoing_comp);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION.SP_PM_COMP' */

            --pm credit trace
            /* ORIGSQL: PK_AIA_CB_CALCULATION.SP_PMCRDTRACE_COMP (v_str_cycledate, v_batch_no_lumpsum_comp, v_batch_no_ongoing_comp) */
            CALL PK_AIA_CB_CALCULATION.SP_PMCRDTRACE_COMP(:v_str_cycledate, :v_batch_no_lumpsum_comp, :v_batch_no_ongoing_comp);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION.SP_PMCRDTRACE_COMP' */
        END IF;
        --Added by Win Tan for version 4 **End**
        --return; --arjun 0531 to stop proc
        --insert records into cs_credit

        /* ORIGSQL: Log('[CB] Insert COMMISSION records into cs_credit for batch-' || v_batch_no_lumpsum_comm || ' and batch-' || v_batch_no_ongoing_comm) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert COMMISSION records into cs_credit for batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comm),'') || ' and batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comm),''));

        /* ORIGSQL: Log('[CB] Insert COMPENSATION records into cs_credit for batch-' || v_batch_no_lumpsum_comp || ' and batch-' || v_batch_no_ongoing_comp) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert COMPENSATION records into cs_credit for batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comp),'') || ' and batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comp),'')); 

        /* ORIGSQL: insert into cs_credit (TENANTID, CREDITSEQ, PAYEESEQ, POSITIONSEQ, SALESORDERSEQ, SALESTRANSACTIONSEQ, PERIODSEQ, CREDITTYPESEQ, NAME, PIPELINERUNSEQ, ORIGINTYPEID, COMPENSATIONDATE, PIPELINERUNDATE, (...) */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.AIA_CB_CREDIT_STG' not found */
        INSERT INTO cs_credit
            --version 10 fix compile error
            (
                TENANTID,
                CREDITSEQ,
                PAYEESEQ,
                POSITIONSEQ,
                SALESORDERSEQ,
                SALESTRANSACTIONSEQ,
                PERIODSEQ,
                CREDITTYPESEQ,
                NAME,
                PIPELINERUNSEQ,
                ORIGINTYPEID,
                COMPENSATIONDATE,
                PIPELINERUNDATE,
                BUSINESSUNITMAP,
                PREADJUSTEDVALUE,
                UNITTYPEFORPREADJUSTEDVALUE,
                VALUE,
                UNITTYPEFORVALUE,
                RELEASEDATE,
                RULESEQ,
                ISHELD,
                ISROLLABLE,
                ROLLDATE,
                REASONSEQ,
                COMMENTS,
                GENERICATTRIBUTE1,
                GENERICATTRIBUTE2,
                GENERICATTRIBUTE3,
                GENERICATTRIBUTE4,
                GENERICATTRIBUTE5,
                GENERICATTRIBUTE6,
                GENERICATTRIBUTE7,
                GENERICATTRIBUTE8,
                GENERICATTRIBUTE9,
                GENERICATTRIBUTE10,
                GENERICATTRIBUTE11,
                GENERICATTRIBUTE12,
                GENERICATTRIBUTE13,
                GENERICATTRIBUTE14,
                GENERICATTRIBUTE15,
                GENERICATTRIBUTE16,
                GENERICNUMBER1,
                UNITTYPEFORGENERICNUMBER1,
                GENERICNUMBER2,
                UNITTYPEFORGENERICNUMBER2,
                GENERICNUMBER3,
                UNITTYPEFORGENERICNUMBER3,
                GENERICNUMBER4,
                UNITTYPEFORGENERICNUMBER4,
                GENERICNUMBER5,
                UNITTYPEFORGENERICNUMBER5,
                GENERICNUMBER6,
                UNITTYPEFORGENERICNUMBER6,
                GENERICDATE1,
                GENERICDATE2,
                GENERICDATE3,
                GENERICDATE4,
                GENERICDATE5,
                GENERICDATE6,
                GENERICBOOLEAN1,
                GENERICBOOLEAN2,
                GENERICBOOLEAN3,
                GENERICBOOLEAN4,
                GENERICBOOLEAN5,
                GENERICBOOLEAN6,
                PROCESSINGUNITSEQ
            )
            --version 10 end

            SELECT   /* ORIGSQL: select 'AIAS' as tenantid, new_creditseq, payeeseq, positionseq, salesorderseq, salestransactionseq, periodseq, credittypeseq, name, v_pipelinerunseq as pipelinerunseq, origintypeid, compensationdate,(...) */
                'AIAS' AS tenantid,
                new_creditseq,
                payeeseq,
                positionseq,
                salesorderseq,
                salestransactionseq,
                periodseq,
                credittypeseq,
                name,
                :v_pipelinerunseq AS pipelinerunseq,
                origintypeid,
                compensationdate,
                :v_pipelinerundate AS pipelinerundate,
                businessunitmap,
                preadjustedvalue,
                unittypeforpreadjustedvalue,
                value,
                unittypeforvalue,
                releasedate,
                ruleseq,
                isheld,
                isrollable,
                rolldate,
                reasonseq,
                comments,
                genericattribute1,
                genericattribute2,
                genericattribute3,
                genericattribute4,
                genericattribute5,
                genericattribute6,
                genericattribute7,
                genericattribute8,
                genericattribute9,
                genericattribute10,
                genericattribute11,
                genericattribute12,
                genericattribute13,
                genericattribute14,
                genericattribute15,
                genericattribute16,
                genericnumber1,
                unittypeforgenericnumber1,
                genericnumber2,
                unittypeforgenericnumber2,
                genericnumber3,
                unittypeforgenericnumber3,
                genericnumber4,
                unittypeforgenericnumber4,
                genericnumber5,
                unittypeforgenericnumber5,
                genericnumber6,
                unittypeforgenericnumber6,
                genericdate1,
                genericdate2,
                genericdate3,
                genericdate4,
                genericdate5,
                genericdate6,
                genericboolean1,
                genericboolean2,
                genericboolean3,
                genericboolean4,
                genericboolean5,
                genericboolean6,
                processingunitseq
            FROM
                AIA_CB_CREDIT_STG crd
            WHERE
                crd.batch_no IN (:v_batch_no_lumpsum_comm,
                    :v_batch_no_ongoing_comm,
                    :v_batch_no_lumpsum_comp,
                    :v_batch_no_ongoing_comp,
                    :v_batch_no_special --revised by Win Tan for version 6
                )
                /*    inner join AIA_CB_BATCH_LIST cbl
                on crd.batch_no = cbl.batchnum*/;

        /* ORIGSQL: Log('[CB] Insert records into cs_credit' || '; row count: ' || to_char(sql%rowcount)) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert records into cs_credit'|| '; row count: '|| IFNULL(TO_VARCHAR(::ROWCOUNT),'')   
            );  /* ORIGSQL: to_char(sql%rowcount) */

        /* ORIGSQL: commit; */
        COMMIT;

        --delete the obsolete PM records belongs to last batchs
        -- Un Supported feature in Callidus - Commented out - Balaji Mar 17 2017
        --Log('[CB] Delete obsolete records in cs_measurement');
        --delete from cs_measurement pm
        -- where periodseq = Gv_Periodseq
        -- and pm.value = 0
        -- and pm.numberofcredits = 0
        -- and pm.genericnumber1 IS NULL
        -- and substr(pm.name, -3) = '_CB';
        --
        --Log('[CB] Delete obsolete records in cs_measurement' || '; row count: ' || to_char(sql%rowcount));
        --
        --commit;

        --insert records into cs_measurement
        /* ORIGSQL: Log('[CB] Insert COMMISSION records into cs_measurement for batch-' || v_batch_no_lumpsum_comm || ' and batch-' || v_batch_no_ongoing_comm) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert COMMISSION records into cs_measurement for batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comm),'') || ' and batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comm),''));

        /* ORIGSQL: Log('[CB] Insert COMPENSATION records into cs_measurement for batch-' || v_batch_no_lumpsum_comp || ' and batch-' || v_batch_no_ongoing_comp) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert COMPENSATION records into cs_measurement for batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comp),'') || ' and batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comp),''));

        /* ORIGSQL: Log(v_processingunitseq) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log(:v_processingunitseq);

        /* ORIGSQL: Log(v_batch_no_lumpsum_comm||' '|| v_batch_no_ongoing_comm||' '|| v_batch_no_lumpsum_comp||' '|| v_batch_no_ongoing_comp) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log(IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comm),'')||' '|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comm),'')||' '|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comp),'')||' '|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comp),''));

        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.AIA_CB_PM_STG' not found */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_POSITION' not found */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_PLANASSIGNABLE' not found */

        SELECT
            COUNT(*)
        INTO
            v_tempcount
        FROM
            AIA_CB_PM_STG pms
        INNER JOIN
            cs_period pd
            ON pd.periodseq = pms.periodseq
            AND pd.removedate = '1-jan-2200'
        INNER JOIN
            cs_position p
            ON p.ruleelementownerseq = pms.positionseq
            AND p.removedate = '1-jan-2200'
            AND pd.startdate BETWEEN p.effectivestartdate AND p.effectiveenddate-1
        LEFT OUTER JOIN
            cs_planassignable  pa
            ON (pa.ruleelementownerseq = p.titleseq)
            AND pa.removedate = '1-jan-2200'
            AND pd.startdate BETWEEN pa.effectivestartdate AND pa.effectiveenddate-1
        WHERE
            pms.batch_no IN (:v_batch_no_lumpsum_comm,
                :v_batch_no_ongoing_comm,
                :v_batch_no_lumpsum_comp,
                :v_batch_no_ongoing_comp,
                :v_batch_no_special --revised by Win Tan for version 6
            );

        -- group by new_measurementseq, pms.name, pms.payeeseq, pms.positionseq, pms.periodseq;

        /* ORIGSQL: Log('v_tempcount '||v_tempcount) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('v_tempcount '||IFNULL(TO_VARCHAR(:v_tempcount),'')); 

        /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
        /* ORIGSQL: merge into cs_measurement tgt using (SELECT MAX(new_measurementseq) AS measurementseq, MAX(pa.planseq) AS planseq, 'AIAS' AS tenantid, pms.name, pms.payeeseq, pms.positionseq, pms.periodseq, MAX(pms.r(...) */
        MERGE INTO cs_measurement AS tgt    
            USING
            (
                SELECT   /* ORIGSQL: (select MAX(new_measurementseq) as measurementseq, MAX(pa.planseq) planseq, 'AIAS' tenantid, pms.name, pms.payeeseq, pms.positionseq, pms.periodseq, MAX(pms.ruleseq) as ruleseq, SUM(pms.value) as valu(...) */
                    --revised by Win for version 6
                    --new_measurementseq as measurementseq, 
                    MAX(new_measurementseq) AS measurementseq,
                    MAX(pa.planseq) AS planseq,
                    'AIAS' AS tenantid,
                    pms.name,
                    pms.payeeseq,
                    pms.positionseq,
                    pms.periodseq,
                    /* --v_pipelinerunseq as pipelinerunseq, */
                    /* --v_pipelinerundate as pipelinerundate, */
                    MAX(pms.ruleseq) AS ruleseq,
                    SUM(pms.value) AS value,
                    MAX(pms.unittypeforvalue) AS unittypeforvalue,
                    SUM(pms.numberofcredits) AS numberofcredits,
                    MAX(pms.businessunitmap) AS businessunitmap,
                    MAX(pms.genericnumber1) AS genericnumber1,
                    MAX(pms.unittypeforgenericnumber1) AS unittypeforgenericnumber1,
                    MAX(pms.processingunitseq) AS processingunitseq,
                    MAX(pms.unittypefornumberofcredits) AS unittypefornumberofcredits
                FROM
                    AIA_CB_PM_STG pms
                INNER JOIN
                    cs_period pd
                    ON pd.periodseq = pms.periodseq
                    AND pd.removedate = '1-jan-2200'
                INNER JOIN
                    cs_position p
                    ON p.ruleelementownerseq = pms.positionseq
                    AND p.removedate = '1-jan-2200'
                    AND pd.startdate BETWEEN p.effectivestartdate AND p.effectiveenddate-1
                LEFT OUTER JOIN
                    cs_planassignable pa
                    ON (pa.ruleelementownerseq = p.titleseq)
                    AND pa.removedate = '1-jan-2200'
                    AND pd.startdate BETWEEN pa.effectivestartdate AND pa.effectiveenddate-1
                WHERE
                    pms.batch_no IN (:v_batch_no_lumpsum_comm,
                        :v_batch_no_ongoing_comm,
                        :v_batch_no_lumpsum_comp,
                        :v_batch_no_ongoing_comp,
                        :v_batch_no_special --revised by Win Tan for version 6
                    )
                GROUP BY
                    --new_measurementseq,  --revised by Win for version 6
                    pms.name, pms.payeeseq, pms.positionseq, pms.periodseq
            ) AS src
            ON (src.positionseq = tgt.positionseq
                AND src.payeeseq = tgt.payeeseq
                AND src.periodseq = tgt.periodseq
                AND src.tenantid = tgt.tenantid
                AND src.processingunitseq = tgt.processingunitseq
            AND src.name = tgt.name)
        WHEN MATCHED THEN
            UPDATE
                SET tgt.planseq = src.planseq,
                -- tgt.pipelinerunseq=src.pipelinerunseq,
                --tgt.pipelinerundate=src.pipelinerundate,
                tgt.ruleseq = src.ruleseq,
                tgt.value = src.value,
                tgt.unittypeforvalue = src.unittypeforvalue,
                tgt.numberofcredits = src.numberofcredits,
                tgt.businessunitmap = src.businessunitmap,
                tgt.genericnumber1 = src.genericnumber1,
                tgt.unittypeforgenericnumber1 = src.unittypeforgenericnumber1,
                tgt.unittypefornumberofcredits = src.unittypefornumberofcredits
            WHERE
                tgt.tenantid = 'AIAS';
        --and tgt.processingunitseq=v_processingunitseq;

        /*This query only works once  - since the orig measurement seq is not backed up*/
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.AIA_CB_PMCRDTRACE_STG' not found */
        /* ORIGSQL: update AIA_CB_PMCRDTRACE_STG tgt SET measurementseq = (SELECT CASE WHEN MAX(m.measurementseq) IS NULL THEN tgt.measurementseq ELSE MAX(m.measurementseq) END FROM cs_measurement m INNER join AIA_CB_PM_(...) */
        UPDATE AIA_CB_PMCRDTRACE_STG tgt 
            SET
            /* ORIGSQL: measurementseq = */
            measurementseq = (
                SELECT   /* ORIGSQL: (select CASE WHEN MAX(m.measurementseq) IS NULL THEN tgt.measurementseq ELSE MAX(m.measurementseq) END from cs_measurement m join AIA_CB_PM_STG pms on m.positionseq=pms.positionseq and m.payeeseq=pms.(...) */
                    /* --Version 14 add by Amanda begin */
                    /* --max(m.measurementseq) */
                    CASE
                        WHEN MAX(m.measurementseq) IS NULL
                        THEN tgt.measurementseq /* --for SPI CB, no need to update credit trace stage */
                        ELSE MAX(m.measurementseq)
                    END
                    /* --Version 14 add by Amanda end */
                FROM
                    cs_measurement m
                INNER JOIN
                    AIA_CB_PM_STG pms
                    ON m.positionseq = pms.positionseq
                    AND m.payeeseq = pms.payeeseq
                    AND m.periodseq = pms.periodseq /* --and src.tenantid=pms.tenantid */
                    AND m.processingunitseq = pms.processingunitseq
                    AND m.name = pms.name
                    AND m.tenantid = 'AIAS'
                WHERE
                    pms.batch_no IN (:v_batch_no_lumpsum_comm,
                        :v_batch_no_ongoing_comm,
                        :v_batch_no_lumpsum_comp,
                        :v_batch_no_ongoing_comp,
                        :v_batch_no_special /* --revised by Win Tan for version 6 */
                    )
                    AND pms.new_measurementseq = tgt.measurementseq
                    AND pms.batch_no = tgt.batch_no
            )
        FROM
            AIA_CB_PMCRDTRACE_STG tgt
        WHERE
            tgt.batch_no IN (:v_batch_no_lumpsum_comm,
                :v_batch_no_ongoing_comm,
                :v_batch_no_lumpsum_comp,
                :v_batch_no_ongoing_comp,
                :v_batch_no_special /* --revised by Win Tan for version 6 */
            );

        /*
        
        insert into cs_measurement
          (measurementseq, planseq,
               name,
               payeeseq,
               positionseq,
               periodseq,
               pipelinerunseq,
               pipelinerundate,
               ruleseq,
               value,
               unittypeforvalue,
               numberofcredits,
               businessunitmap,
               genericnumber1,
               unittypeforgenericnumber1,
               processingunitseq,
           unittypefornumberofcredits)
          select new_measurementseq as measurementseq, max(pa.planseq),
                 pms.name,
                 pms.payeeseq,
                 pms.positionseq,
                 pms.periodseq,
                 v_pipelinerunseq as pipelinerunseq,
                 v_pipelinerundate as pipelinerundate,
                 max(pms.ruleseq) as ruleseq,
                 sum(pms.value) as value,
                 max(pms.unittypeforvalue) as unittypeforvalue,
                 sum(pms.numberofcredits) as numberofcredits,
                 max(pms.businessunitmap) as businessunitmap,
                 max(pms.genericnumber1) as genericnumber1,
                 max(pms.unittypeforgenericnumber1) as unittypeforgenericnumber1,
                 max(pms.processingunitseq),
                 max(pms.unittypefornumberofcredits)
            from AIA_CB_PM_STG pms
            join cs_period pd
        on pd.periodseq=pms.periodseq and pd.removedate='1-jan-2200'
        join  cs_position p
        on p.ruleelementownerseq=pms.positionseq and p.removedate='1-jan-2200'
        and pd.startdate between p.effectivestartdate and p.effectiveenddate-1
        left join  cs_planassignable  pa
        on (pa.ruleelementownerseq=p.titleseq) and pa.removedate='1-jan-2200'
        and pd.startdate between pa.effectivestartdate and pa.effectiveenddate-1
            where pms.batch_no in (v_batch_no_lumpsum_comm,
                                      v_batch_no_ongoing_comm,
                                      v_batch_no_lumpsum_comp,
                                  v_batch_no_ongoing_comp)
            group by new_measurementseq, pms.name, pms.payeeseq, pms.positionseq, pms.periodseq
        ; */

        /* ORIGSQL: Log('[CB] Merge records into cs_measurement' || '; row count: ' || to_char(sql%rowcount)) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Merge records into cs_measurement'|| '; row count: '|| IFNULL(TO_VARCHAR(::ROWCOUNT),'')   
            );  /* ORIGSQL: to_char(sql%rowcount) */

        /*
        select ruleelementownerseq, count(*)
        from cs_planassignable
        where effectiveenddate>sysdate and removedate>sysdate
        group by ruleelementownerseq
        having count(*)>1 returns  nothing
        
        
        merge into cs_measurement tgt
        using(
            select m.measurementseq, pa.planseq from cs_measurement m
            join cs_period pd
            on pd.periodseq=m.periodseq and pd.removedate='1-jan-2200'
            join  cs_position p
            on p.ruleelementownerseq=m.positionseq and p.removedate='1-jan-2200'
            and pd.startdate between pos.effectivestartdate and pos.effectiveenddate-1
            join cs_planassignable pa
            on (pa.ruleelementownerseq=p.ruleelementownerseq or pa.ruleelementownerseq=p.titleseq) and pa.removedate='1-jan-2200'
            and pd.startdate between pa.effectivestartdate and pa.effectiveenddate-1
            where  pa.planseq IS NOT NULL and m.tenantid = 'AIAS' and m.processingunitseq=gv_processingUnitSeq
            and m.name in (select name from AIA_CB_PM_STG pms where pms.batch_no in (v_batch_no_lumpsum_comm,
                                              v_batch_no_ongoing_comm,
                                      v_batch_no_lumpsum_comp, v_batch_no_ongoing_comp))
        ) src
        on (src.measurementseq=tgt.measurementseq)
        when matched then update set tgt.planseq=src.planseq
        where    tgt.planseq IS NULL
         and tgt.tenantid='AIAS' and tgt.processingunitseq=gv_processingUnitSeq ;
          */

        /* ORIGSQL: commit; */
        COMMIT;

        --insert records into cs_pmcredittrace
        /* ORIGSQL: Log('[CB] Insert COMMISSION records into cs_pmcredittrace for batch-' || v_batch_no_lumpsum_comm || ' and batch-' || v_batch_no_ongoing_comm) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert COMMISSION records into cs_pmcredittrace for batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comm),'') || ' and batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comm),''));

        /* ORIGSQL: Log('[CB] Insert COMPENSATION records into cs_pmcredittrace for batch-' || v_batch_no_lumpsum_comp || ' and batch-' || v_batch_no_ongoing_comp) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert COMPENSATION records into cs_pmcredittrace for batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comp),'') || ' and batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comp),''));
        --v12 
        /* ORIGSQL: insert into cs_pmcredittrace (Tenantid, creditSeq, measurementSeq, ruleSeq, pipelineRunSeq, sourcePeriodSeq, targetPeriodSeq, sourceorigintypeid, contributionValue, unittypeforContributionValue, busin(...) */
        INSERT INTO cs_pmcredittrace
            (
                Tenantid,
                creditSeq,
                measurementSeq,
                ruleSeq,
                pipelineRunSeq,
                sourcePeriodSeq,
                targetPeriodSeq,
                sourceorigintypeid,
                contributionValue,
                unittypeforContributionValue,
                businessunitMap,
                processingUnitSeq
            )
            SELECT   /* ORIGSQL: select 'AIAS' as Tenantid, creditseq, measurementseq, ruleseq, v_pipelinerunseq as pipelinerunseq, sourceperiodseq, targetperiodseq, sourceorigintypeid, contributionvalue, unittypeforcontributionvalue(...) */
                'AIAS' AS Tenantid,
                creditseq,
                measurementseq,
                ruleseq,
                :v_pipelinerunseq AS pipelinerunseq,
                sourceperiodseq,
                targetperiodseq,
                sourceorigintypeid,
                contributionvalue,
                unittypeforcontributionvalue,
                businessunitmap,
                processingunitseq
            FROM
                AIA_CB_PMCRDTRACE_STG pcs
                /*    inner join AIA_CB_BATCH_LIST cbl
                on pcs.batch_no = cbl.batchnum */
            WHERE
                pcs.batch_no IN (:v_batch_no_lumpsum_comm,
                    :v_batch_no_ongoing_comm,
                    :v_batch_no_lumpsum_comp,
                    :v_batch_no_ongoing_comp,
                    :v_batch_no_special --revised by Win Tan for version 6
                );

        /* ORIGSQL: Log('[CB] Insert records into cs_pmcredittrace' || '; row count: ' || to_char(sql%rowcount)) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert records into cs_pmcredittrace'|| '; row count: '|| IFNULL(TO_VARCHAR(::ROWCOUNT),'')   
            );  /* ORIGSQL: to_char(sql%rowcount) */

        /* ORIGSQL: commit; */
        COMMIT;

        --Version 12 add by Amanda begin 
        SELECT
            startDate
        INTO
            v_periodStartDate
        FROM
            cs_period
        WHERE
            periodSeq = :i_periodSeq;

        --get previous quarter for YTD clawback  
        SELECT
            qtr.name
        INTO
            v_previous_qtr
        FROM
            cs_period csp
        INNER JOIN
            cs_period qtr
            ON csp.parentseq = qtr.periodseq
            AND qtr.removedate = '1-jan-2200'
            AND qtr.calendarseq = :gv_calendarSeq
            AND qtr.periodtypeseq = 2814749767106563 --quarter
        WHERE
            csp.startdate = ADD_MONTHS(:v_periodStartDate, -3)
            AND csp.removedate = '1-jan-2200'
            AND csp.periodtypeseq = 2814749767106561 --month
            AND csp.calendarseq = :gv_calendarSeq;

        /* ORIGSQL: Log('[CB] Get previous quarter for SPI CB' || '; row count: ' || to_char(sql%rowcount)) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Get previous quarter for SPI CB'|| '; row count: '|| IFNULL(TO_VARCHAR(::ROWCOUNT),'')   
            );  /* ORIGSQL: to_char(sql%rowcount) */

        --sum up YTD SPI CB if one agent has more than one policy 
        /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
        /* ORIGSQL: merge into cs_measurement tgt using (SELECT 'AIAS' AS tenantid, cb.buname, cb.year, cb.quarter, cb.WRI_AGT_CODE, pos.ruleelementownerseq, pos.payeeseq, sum(CASE WHEN cb.year = EXTRACT(YEAR FROM v_peri(...) */
        MERGE INTO cs_measurement AS tgt
            /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.AIA_CB_SPI_CLAWBACK' not found */
            USING
            (
                SELECT   /* ORIGSQL: (select 'AIAS' as tenantid, cb.buname, cb.year, cb.quarter, cb.WRI_AGT_CODE, pos.ruleelementownerseq, pos.payeeseq, sum(CASE WHEN cb.year = EXTRACT(YEAR FROM v_periodStartDate) THEN YTD_SPI_CB ELSE 0 (...) */
                    'AIAS' AS tenantid,
                    cb.buname,
                    cb.year,
                    cb.quarter,
                    cb.WRI_AGT_CODE,
                    pos.ruleelementownerseq,
                    pos.payeeseq,
                    SUM(
                        CASE   /* ORIGSQL: sum(CASE WHEN cb.year = EXTRACT(YEAR FROM v_periodStartDate) THEN YTD_SPI_CB ELSE 0 END) */
                            WHEN cb.year = EXTRACT(YEAR FROM :v_periodStartDate)
                            THEN YTD_SPI_CB /* --ONGONING YTD FYC CB */
                            ELSE 0
                        END
                    ) AS YTD_SPI_CB
                FROM
                    AIA_CB_SPI_CLAWBACK cb
                INNER JOIN
                    cs_position pos
                    ON pos.name = 'SGT'||IFNULL(cb.WRI_AGT_CODE,'')
                    AND pos.tenantid = 'AIAS'
                    AND pos.removedate = '1-jan-2200'
                    AND v_periodStartDate BETWEEN pos.effectivestartdate AND pos.effectiveenddate-1
                WHERE
                    (IFNULL(cb.quarter,'') || ' '|| IFNULL(cb.year,'')) = :v_previous_qtr
                    AND cb.buname = 'SGPAGY'
                GROUP BY
                    cb.buname,
                    cb.year,
                    cb.quarter,
                    cb.WRI_AGT_CODE,
                    pos.ruleelementownerseq,
                    pos.payeeseq
            ) AS src
            ON (src.ruleelementownerseq = tgt.positionseq
                AND src.payeeseq = tgt.payeeseq
                AND i_periodSeq = tgt.periodseq
                AND src.tenantid = tgt.tenantid
            )
        WHEN MATCHED THEN
            UPDATE
                SET tgt.value = YTD_SPI_CB --round(YTD_SPI_CB,2) fix round issue
            WHERE
                tgt.tenantid = 'AIAS'
                AND tgt.processingunitseq = :Gv_Processingunitseq
                AND tgt.name = 'PM_SPI_ONG_YTD_CB';

        /* ORIGSQL: Log('[CB] Merge records into cs_measurement for SPI ONGOING YTD CB' || '; row count: ' || to_char(sql%rowcount)) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Merge records into cs_measurement for SPI ONGOING YTD CB'|| '; row count: '|| IFNULL(TO_VARCHAR(::ROWCOUNT),'')   
            );  /* ORIGSQL: to_char(sql%rowcount) */

        --Version 12 end

        --update the batch status to complete
        /* ORIGSQL: PK_AIA_CB_CALCULATION.sp_update_batch_status(v_batch_no_lumpsum_comm, STR_STATUS_COMPLETED_SH) */
        CALL PK_AIA_CB_CALCULATION.sp_update_batch_status(:v_batch_no_lumpsum_comm, :STR_STATUS_COMPLETED_SH);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION.sp_update_batch_status' */

        /* ORIGSQL: PK_AIA_CB_CALCULATION.sp_update_batch_status(v_batch_no_ongoing_comm, STR_STATUS_COMPLETED_SH) */
        CALL PK_AIA_CB_CALCULATION.sp_update_batch_status(:v_batch_no_ongoing_comm, :STR_STATUS_COMPLETED_SH);

        --Commented by Win Tan for version 4
        --PK_AIA_CB_CALCULATION.sp_update_batch_status(v_batch_no_lumpsum_comp, STR_STATUS_COMPLETED_SH);
        --PK_AIA_CB_CALCULATION.sp_update_batch_status(v_batch_no_ongoing_comp, STR_STATUS_COMPLETED_SH);

        --Added by Win Tan for version 4 **Begin**
        IF sapdbmtk.sp_f_dbmtk_format_string_to_datetime(:v_str_cycledate,'yyyy-mm-dd') = :v_period_end  /* ORIGSQL: to_date(v_str_cycledate,'yyyy-mm-dd') */
        THEN
            /* ORIGSQL: PK_AIA_CB_CALCULATION.sp_update_batch_status(v_batch_no_lumpsum_comp, STR_STATUS_COMPLETED_SH) */
            CALL PK_AIA_CB_CALCULATION.sp_update_batch_status(:v_batch_no_lumpsum_comp, :STR_STATUS_COMPLETED_SH);

            /* ORIGSQL: PK_AIA_CB_CALCULATION.sp_update_batch_status(v_batch_no_ongoing_comp, STR_STATUS_COMPLETED_SH) */
            CALL PK_AIA_CB_CALCULATION.sp_update_batch_status(:v_batch_no_ongoing_comp, :STR_STATUS_COMPLETED_SH);
        END IF;
        --Added by Win Tan for version 4 **End**
        --added by Win for version 6
        --update the batch status for special handling   
        /* ORIGSQL: update aia_cb_batch_special SET ISACTIVE = 'N' where batchnum = v_batch_no_special and ISACTIVE = 'Y' and SPEC_RUN_DATE = to_date(v_str_cycledate, 'yyyy-mm-dd') and BUNAME = 'SGPAGY'; */
        UPDATE aia_cb_batch_special
            SET
            /* ORIGSQL: ISACTIVE = */
            ISACTIVE = 'N' 
        FROM
            aia_cb_batch_special
        WHERE
            batchnum = :v_batch_no_special
            AND ISACTIVE = 'Y'
            AND SPEC_RUN_DATE = sapdbmtk.sp_f_dbmtk_format_string_to_datetime(:v_str_cycledate, 'yyyy-mm-dd')  /* ORIGSQL: to_date(v_str_cycledate, 'yyyy-mm-dd') */
            AND BUNAME = 'SGPAGY';

        --v19 add BUNAME
    ELSE 
        /* ORIGSQL: Log('[CB] ' || v_str_cycledate || ' not exit in pipeline run period: ' || Gv_Periodseq) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] '|| IFNULL(:v_str_cycledate,'') || ' not exit in pipeline run period: '|| IFNULL(TO_VARCHAR(:Gv_Periodseq),''));
    END IF;

    ---catch exception
    /* ORIGSQL: EXCEPTION WHEN OTHERS THEN */
END;

--end
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__SP_CLAWBACK_CALCULATION') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_CLAWBACK_CALCULATION_FA' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__SP_CLAWBACK_CALCULATION_FA''...' );
go

/* ORIGSQL: procedure SP_CLAWBACK_CALCULATION_FA(i_periodSeq in int) as type tRun is record (pipelineRunSeq CS_PipelineRun.pipelineRunSeq%type, startTime CS_PipelineRun.startTime%type, stopTime CS_PipelineRun.sto(...) */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__SP_CLAWBACK_CALCULATION_FA
(
    IN i_periodSeq BIGINT     /* ORIGSQL: i_periodSeq IN int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */
    DECLARE gv_calendarSeq BIGINT; /* package/session variable */
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE v_tempcount BIGINT;  /* ORIGSQL: v_tempcount integer; */
    DECLARE v_pipelinerunseq BIGINT;  /* ORIGSQL: v_pipelinerunseq integer; */
    DECLARE v_pipelinerundate TIMESTAMP;  /* ORIGSQL: v_pipelinerundate date; */
    DECLARE v_batch_no_lumpsum_comm BIGINT;  /* ORIGSQL: v_batch_no_lumpsum_comm integer; */
    DECLARE v_batch_no_lumpsum_comp BIGINT;  /* ORIGSQL: v_batch_no_lumpsum_comp integer; */
    DECLARE v_batch_no_ongoing_comm BIGINT;  /* ORIGSQL: v_batch_no_ongoing_comm integer; */
    DECLARE v_batch_no_ongoing_comp BIGINT;  /* ORIGSQL: v_batch_no_ongoing_comp integer; */
    DECLARE v_processingunitseq BIGINT;  /* ORIGSQL: v_processingunitseq integer; */
    DECLARE v_str_cycledate VARCHAR(20);  /* ORIGSQL: v_str_cycledate VARCHAR2(20); */
    DECLARE v_period_start TIMESTAMP;  /* ORIGSQL: v_period_start date; */
    DECLARE v_period_end TIMESTAMP;  /* ORIGSQL: v_period_end date; */
    DECLARE STR_CYCLEDATE_FILE_NAME CONSTANT VARCHAR(10) = 'GLOBAL';  /* ORIGSQL: STR_CYCLEDATE_FILE_NAME CONSTANT VARCHAR2(10) := 'GLOBAL'; */
    DECLARE STR_CYCLEDATE_KEY CONSTANT VARCHAR(20) = 'OPER_CYCLE_DATE';  /* ORIGSQL: STR_CYCLEDATE_KEY CONSTANT VARCHAR2(20) := 'OPER_CYCLE_DATE'; */
    DECLARE STR_LUMPSUM CONSTANT VARCHAR(20) = 'LUMPSUM';  /* ORIGSQL: STR_LUMPSUM CONSTANT VARCHAR2(20) := 'LUMPSUM'; */
    DECLARE STR_ONGOING CONSTANT VARCHAR(20) = 'ONGOING';  /* ORIGSQL: STR_ONGOING CONSTANT VARCHAR2(20) := 'ONGOING'; */
    DECLARE STR_COMMISSION CONSTANT VARCHAR(20) = 'COMMISSION';  /* ORIGSQL: STR_COMMISSION CONSTANT VARCHAR2(20) := 'COMMISSION'; */
    DECLARE STR_COMPENSATION CONSTANT VARCHAR(20) = 'COMPENSATION';  /* ORIGSQL: STR_COMPENSATION CONSTANT VARCHAR2(20) := 'COMPENSATION'; */
    DECLARE STR_STATUS_START CONSTANT VARCHAR(20) = 'start';  /* ORIGSQL: STR_STATUS_START CONSTANT VARCHAR2(20) := 'start'; */
    DECLARE STR_STATUS_PROCESSING CONSTANT VARCHAR(20) = 'processing';  /* ORIGSQL: STR_STATUS_PROCESSING CONSTANT VARCHAR2(20) := 'processing'; */
    DECLARE STR_STATUS_FAIL CONSTANT VARCHAR(20) = 'fail';  /* ORIGSQL: STR_STATUS_FAIL CONSTANT VARCHAR2(20) := 'fail'; */
    DECLARE STR_STATUS_COMPLETED_SP CONSTANT VARCHAR(20) = 'completed_sp';  /* ORIGSQL: STR_STATUS_COMPLETED_SP CONSTANT VARCHAR2(20) := 'completed_sp'; */
    DECLARE STR_STATUS_COMPLETED_SH CONSTANT VARCHAR(20) = 'completed_sh';  /* ORIGSQL: STR_STATUS_COMPLETED_SH CONSTANT VARCHAR2(20) := 'completed_sh'; */
    DECLARE V_MESSAGE VARCHAR(2000);  /* ORIGSQL: V_MESSAGE VARCHAR2(2000); */
    DECLARE v_batch_no_special BIGINT;  /* ORIGSQL: v_batch_no_special integer; */

    --added by Win for version 6
    --version 12 add by Amanda begin
    DECLARE v_periodStartDate TIMESTAMP;  /* ORIGSQL: v_periodStartDate date; */
    DECLARE v_previous_qtr VARCHAR(10);  /* ORIGSQL: v_previous_qtr varchar2(10); */

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: WHEN OTHERS THEN */
        BEGIN
            V_MESSAGE = SUBSTRING(::SQL_ERROR_MESSAGE,1,2000);  /* ORIGSQL: SUBSTR(SQLERRM,1,2000) */

            /* ORIGSQL: Log('[CB] ' || v_message) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] '|| IFNULL(:V_MESSAGE,''));

            --update the batch status to fail
            /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(v_batch_no_lumpsum_comm, STR_STATUS_FAIL) */
            CALL PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(:v_batch_no_lumpsum_comm, :STR_STATUS_FAIL);

            /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(v_batch_no_ongoing_comm, STR_STATUS_FAIL) */
            CALL PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(:v_batch_no_ongoing_comm, :STR_STATUS_FAIL);

            /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(v_batch_no_lumpsum_comp, STR_STATUS_FAIL) */
            CALL PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(:v_batch_no_lumpsum_comp, :STR_STATUS_FAIL);

            /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(v_batch_no_ongoing_comp, STR_STATUS_FAIL) */
            CALL PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(:v_batch_no_ongoing_comp, :STR_STATUS_FAIL);
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CALENDARSEQ') AS BIGINT) INTO gv_calendarSeq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
        /* end of package/session variables */



    /*---TYPE definition moved to  scripts/dbmtk_create_types.sqlscript ---
    type  tRun is record
    (
        pipelineRunSeq     CS_PipelineRun.pipelineRunSeq%type,
        startTime          CS_PipelineRun.startTime%type,
        stopTime           CS_PipelineRun.stopTime%type,
        periodSeq          CS_PipelineRun.periodSeq%type,
        runMode            CS_PipelineRun.runMode%type,
        stageTypeSeq       CS_PipelineRun.stageTypeSeq%type,
        status             CS_PipelineRun.status%type,
        processingUnitSeq  CS_PipelineRun.processingUnitSeq%type
    );
    ---end of TYPE definition commented out---*/ 
    --version 12 end

    --get cycle date 
    SELECT
        TXT_KEY_VALUE
    INTO
        v_str_cycledate
    FROM
        IN_ETL_CONTROL
    WHERE
        TXT_FILE_NAME = :STR_CYCLEDATE_FILE_NAME
        AND TXT_KEY_STRING = :STR_CYCLEDATE_KEY;

    /* ORIGSQL: Log('[CB] Oper cycle date is: ' || v_str_cycledate) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Oper cycle date is: '|| IFNULL(:v_str_cycledate,''));

    --get period start date and period end date 
    SELECT
        cp.startdate,
        (cp.enddate - 1)
    INTO
        v_period_start,
        v_period_end
    FROM
        cs_period cp
    WHERE
        cp.periodseq = :Gv_Periodseq;

    --if current cycle date not between pipeline period, then exit.
    IF sapdbmtk.sp_f_dbmtk_format_string_to_datetime(:v_str_cycledate,'yyyy-mm-dd') BETWEEN :v_period_start AND :v_period_end  /* ORIGSQL: to_date(v_str_cycledate,'yyyy-mm-dd') */
    THEN
        /* ORIGSQL: Log('[CB] SP_EXEC_COMMISSION_ONGOING_FA starting ' || v_str_cycledate) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] SP_EXEC_COMMISSION_ONGOING_FA starting '|| IFNULL(:v_str_cycledate,''));

        /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.SP_EXEC_COMMISSION_ONGOING_FA(v_str_cycledate) */
        CALL PK_AIA_CB_CALCULATION_FA.SP_EXEC_COMMISSION_ONGOING_FA(:v_str_cycledate);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION_FA.SP_EXEC_COMMISSION_ONGOING_FA' */

        /* ORIGSQL: Log('[CB] SP_EXEC_COMMISSION_ONGOING_FA ending') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] SP_EXEC_COMMISSION_ONGOING_FA ending');

        /* ORIGSQL: Log('[CB] SP_EXEC_COMP_ONGOING_FA starting') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] SP_EXEC_COMP_ONGOING_FA starting');

        /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.SP_EXEC_COMP_ONGOING_FA(v_str_cycledate) */
        CALL PK_AIA_CB_CALCULATION_FA.SP_EXEC_COMP_ONGOING_FA(:v_str_cycledate);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION_FA.SP_EXEC_COMP_ONGOING_FA' */

        /* ORIGSQL: Log('[CB] SP_EXEC_COMP_ONGOING_FA ended') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] SP_EXEC_COMP_ONGOING_FA ended');

        --get pipeline run sequence number
        --  v_pipelinerunseq := tcmp.pipelinerun.GetLatestActiveRunSeq(i_periodSeq, gv_processingUnitSeq);

        --get pipeline run date
        --  v_pipelinerundate := tcmp.pipelinerun.GetRunDate(v_pipelinerunseq, gv_processingUnitSeq);

        /*Arjun 0607 - to get around the grants. temporary*/ 
        SELECT
            MAX(y.pipelinerunseq),
            MAX(y.starttime)
        INTO
            v_pipelinerunseq,
            v_pipelinerundate
        FROM
            cs_pipelinerun y
        WHERE
            y.command = 'PipelineRun'
            AND y.stoptime IS NULL
            AND y.starttime  
            =
            (
                SELECT   /* ORIGSQL: (Select MAX(x.starttime) from cs_pipelinerun x where x.command='PipelineRun' and x.stoptime IS NULL) */
                    MAX(x.starttime)
                FROM
                    cs_pipelinerun x
                WHERE
                    x.command = 'PipelineRun'
                    AND x.stoptime IS NULL
            );

        IF :v_pipelinerundate IS NULL
        THEN 
            SELECT
                MAX(pipelinerunseq),
                CURRENT_TIMESTAMP   /* ORIGSQL: sysdate */
            INTO
                v_pipelinerunseq,
                v_pipelinerundate
            FROM
                cs_pipelinerun y
            WHERE
                y.command = 'PipelineRun';
        END IF;

        --added by Win for version 6
        --begin
        --get the batch number for special handling 
        SELECT
            IFNULL(MAX(batchnum), 0)  /* ORIGSQL: nvl(max(batchnum), 0) */
        INTO
            v_batch_no_special
        FROM
            aia_cb_batch_special
        WHERE
            ISACTIVE = 'Y'
            AND SPEC_RUN_DATE = sapdbmtk.sp_f_dbmtk_format_string_to_datetime(:v_str_cycledate, 'yyyy-mm-dd')  /* ORIGSQL: to_date(v_str_cycledate, 'yyyy-mm-dd') */
            AND BUNAME = 'SGPAFA';
        --v19 add BUNAME

        /* ORIGSQL: Log('[CB] Special run batch number is: ' || v_batch_no_special) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Special run batch number is: '|| IFNULL(TO_VARCHAR(:v_batch_no_special),''));

        --end

        --get active batch number for lumpsum commission
        v_batch_no_lumpsum_comm = PK_AIA_CB_CALCULATION_FA.fn_get_batch_no_fa(:v_str_cycledate, :STR_COMMISSION, :STR_LUMPSUM, :STR_STATUS_COMPLETED_SP);

        IF :v_batch_no_lumpsum_comm = 0
        THEN
            v_batch_no_lumpsum_comm = PK_AIA_CB_CALCULATION_FA.fn_get_batch_no_fa(:v_str_cycledate, :STR_COMMISSION, :STR_LUMPSUM, :STR_STATUS_COMPLETED_SH);
        END IF;

        /* ORIGSQL: Log('[CB] Clawback batch for commission LUMPSUM: ' || v_batch_no_lumpsum_comm) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Clawback batch for commission LUMPSUM: '|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comm),''));

        /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.sp_revert_by_batch(v_batch_no_lumpsum_comm) */
        CALL PK_AIA_CB_CALCULATION_FA.sp_revert_by_batch(:v_batch_no_lumpsum_comm);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION_FA.sp_revert_by_batch' */

        --get active batch number for on-going commission
        v_batch_no_ongoing_comm = PK_AIA_CB_CALCULATION_FA.fn_get_batch_no_fa(:v_str_cycledate, :STR_COMMISSION, :STR_ONGOING, :STR_STATUS_COMPLETED_SP);

        /* ORIGSQL: Log('[CB] Clawback batch for commission ONGOING: ' || v_batch_no_ongoing_comm) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Clawback batch for commission ONGOING: '|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comm),''));

        /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.sp_revert_by_batch(v_batch_no_ongoing_comm) */
        CALL PK_AIA_CB_CALCULATION_FA.sp_revert_by_batch(:v_batch_no_ongoing_comm);

        --get active batch number for lumpsum compensation
        v_batch_no_lumpsum_comp = PK_AIA_CB_CALCULATION_FA.fn_get_batch_no_fa(:v_str_cycledate, :STR_COMPENSATION, :STR_LUMPSUM, :STR_STATUS_COMPLETED_SP);

        IF :v_batch_no_lumpsum_comp = 0
        THEN
            v_batch_no_lumpsum_comp = PK_AIA_CB_CALCULATION_FA.fn_get_batch_no_fa(:v_str_cycledate, :STR_COMPENSATION, :STR_LUMPSUM, :STR_STATUS_COMPLETED_SH);
        END IF;
        /* ORIGSQL: Log('[CB] Clawback batch for compensation LUMPSUM: ' || v_batch_no_lumpsum_comp) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Clawback batch for compensation LUMPSUM: '|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comp),''));

        /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.sp_revert_by_batch(v_batch_no_lumpsum_comp) */
        CALL PK_AIA_CB_CALCULATION_FA.sp_revert_by_batch(:v_batch_no_lumpsum_comp);

        --get active batch number for on-going compensation
        v_batch_no_ongoing_comp = PK_AIA_CB_CALCULATION_FA.fn_get_batch_no_fa(:v_str_cycledate, :STR_COMPENSATION, :STR_ONGOING, :STR_STATUS_COMPLETED_SP);

        /* ORIGSQL: Log('[CB] Clawback batch for compensation ONGOING: ' || v_batch_no_ongoing_comp) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Clawback batch for compensation ONGOING: '|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comp),''));

        /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.sp_revert_by_batch(v_batch_no_ongoing_comp) */
        CALL PK_AIA_CB_CALCULATION_FA.sp_revert_by_batch(:v_batch_no_ongoing_comp);

        --prepare the commission clawback data for insert to TrueComp build in tables
        --credit
        /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.SP_CREDIT_COMMISSION_FA (v_str_cycledate, v_batch_no_lumpsum_comm, v_batch_no_ongoing_comm) */
        CALL PK_AIA_CB_CALCULATION_FA.SP_CREDIT_COMMISSION_FA(:v_str_cycledate, :v_batch_no_lumpsum_comm, :v_batch_no_ongoing_comm);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION_FA.SP_CREDIT_COMMISSION_FA' */

        --primary measurement
        /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.SP_PM_COMMISSION_FA (v_str_cycledate, v_batch_no_lumpsum_comm, v_batch_no_ongoing_comm) */
        CALL PK_AIA_CB_CALCULATION_FA.SP_PM_COMMISSION_FA(:v_str_cycledate, :v_batch_no_lumpsum_comm, :v_batch_no_ongoing_comm);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION_FA.SP_PM_COMMISSION_FA' */

        --pm credit trace
        /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.SP_PMCRDTRACE_COMMISSION_FA (v_str_cycledate, v_batch_no_lumpsum_comm, v_batch_no_ongoing_comm) */
        CALL PK_AIA_CB_CALCULATION_FA.SP_PMCRDTRACE_COMMISSION_FA(:v_str_cycledate, :v_batch_no_lumpsum_comm, :v_batch_no_ongoing_comm);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION_FA.SP_PMCRDTRACE_COMMISSION_FA' */

        --Added by Win Tan for version 4 **Begin**
        IF sapdbmtk.sp_f_dbmtk_format_string_to_datetime(:v_str_cycledate,'yyyy-mm-dd') = :v_period_end  /* ORIGSQL: to_date(v_str_cycledate,'yyyy-mm-dd') */
        THEN
            --prepare the compensation clawback data for insert to TrueComp build in tables
            --credit
            /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.SP_CREDIT_COMP_FA (v_str_cycledate, v_batch_no_lumpsum_comp, v_batch_no_ongoing_comp) */
            CALL PK_AIA_CB_CALCULATION_FA.SP_CREDIT_COMP_FA(:v_str_cycledate, :v_batch_no_lumpsum_comp, :v_batch_no_ongoing_comp);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION_FA.SP_CREDIT_COMP_FA' */

            --primary measurement
            /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.SP_PM_COMP_FA (v_str_cycledate, v_batch_no_lumpsum_comp, v_batch_no_ongoing_comp) */
            CALL PK_AIA_CB_CALCULATION_FA.SP_PM_COMP_FA(:v_str_cycledate, :v_batch_no_lumpsum_comp, :v_batch_no_ongoing_comp);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION_FA.SP_PM_COMP_FA' */

            --pm credit trace
            /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.SP_PMCRDTRACE_COMP_FA (v_str_cycledate, v_batch_no_lumpsum_comp, v_batch_no_ongoing_comp) */
            CALL PK_AIA_CB_CALCULATION_FA.SP_PMCRDTRACE_COMP_FA(:v_str_cycledate, :v_batch_no_lumpsum_comp, :v_batch_no_ongoing_comp);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION_FA.SP_PMCRDTRACE_COMP_FA' */
        END IF;
        --Added by Win Tan for version 4 **End**
        --return; --arjun 0531 to stop proc
        --insert records into cs_credit

        /* ORIGSQL: Log('[CB] Insert COMMISSION records into cs_credit for batch-' || v_batch_no_lumpsum_comm || ' and batch-' || v_batch_no_ongoing_comm) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert COMMISSION records into cs_credit for batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comm),'') || ' and batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comm),''));

        /* ORIGSQL: Log('[CB] Insert COMPENSATION records into cs_credit for batch-' || v_batch_no_lumpsum_comp || ' and batch-' || v_batch_no_ongoing_comp) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert COMPENSATION records into cs_credit for batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comp),'') || ' and batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comp),'')); 

        /* ORIGSQL: insert into cs_credit (TENANTID, CREDITSEQ, PAYEESEQ, POSITIONSEQ, SALESORDERSEQ, SALESTRANSACTIONSEQ, PERIODSEQ, CREDITTYPESEQ, NAME, PIPELINERUNSEQ, ORIGINTYPEID, COMPENSATIONDATE, PIPELINERUNDATE, (...) */
        INSERT INTO cs_credit
            (
                TENANTID,
                CREDITSEQ,
                PAYEESEQ,
                POSITIONSEQ,
                SALESORDERSEQ,
                SALESTRANSACTIONSEQ,
                PERIODSEQ,
                CREDITTYPESEQ,
                NAME,
                PIPELINERUNSEQ,
                ORIGINTYPEID,
                COMPENSATIONDATE,
                PIPELINERUNDATE,
                BUSINESSUNITMAP,
                PREADJUSTEDVALUE,
                UNITTYPEFORPREADJUSTEDVALUE,
                VALUE,
                UNITTYPEFORVALUE,
                RELEASEDATE,
                RULESEQ,
                ISHELD,
                ISROLLABLE,
                ROLLDATE,
                REASONSEQ,
                COMMENTS,
                GENERICATTRIBUTE1,
                GENERICATTRIBUTE2,
                GENERICATTRIBUTE3,
                GENERICATTRIBUTE4,
                GENERICATTRIBUTE5,
                GENERICATTRIBUTE6,
                GENERICATTRIBUTE7,
                GENERICATTRIBUTE8,
                GENERICATTRIBUTE9,
                GENERICATTRIBUTE10,
                GENERICATTRIBUTE11,
                GENERICATTRIBUTE12,
                GENERICATTRIBUTE13,
                GENERICATTRIBUTE14,
                GENERICATTRIBUTE15,
                GENERICATTRIBUTE16,
                GENERICNUMBER1,
                UNITTYPEFORGENERICNUMBER1,
                GENERICNUMBER2,
                UNITTYPEFORGENERICNUMBER2,
                GENERICNUMBER3,
                UNITTYPEFORGENERICNUMBER3,
                GENERICNUMBER4,
                UNITTYPEFORGENERICNUMBER4,
                GENERICNUMBER5,
                UNITTYPEFORGENERICNUMBER5,
                GENERICNUMBER6,
                UNITTYPEFORGENERICNUMBER6,
                GENERICDATE1,
                GENERICDATE2,
                GENERICDATE3,
                GENERICDATE4,
                GENERICDATE5,
                GENERICDATE6,
                GENERICBOOLEAN1,
                GENERICBOOLEAN2,
                GENERICBOOLEAN3,
                GENERICBOOLEAN4,
                GENERICBOOLEAN5,
                GENERICBOOLEAN6,
                PROCESSINGUNITSEQ
            )
            SELECT   /* ORIGSQL: select 'AIAS' as tenantid, new_creditseq, payeeseq, positionseq, salesorderseq, salestransactionseq, periodseq, credittypeseq, name, v_pipelinerunseq as pipelinerunseq, origintypeid, compensationdate,(...) */
                'AIAS' AS tenantid,
                new_creditseq,
                payeeseq,
                positionseq,
                salesorderseq,
                salestransactionseq,
                periodseq,
                credittypeseq,
                name,
                :v_pipelinerunseq AS pipelinerunseq,
                origintypeid,
                compensationdate,
                :v_pipelinerundate AS pipelinerundate,
                businessunitmap,
                preadjustedvalue,
                unittypeforpreadjustedvalue,
                value,
                unittypeforvalue,
                releasedate,
                ruleseq,
                isheld,
                isrollable,
                rolldate,
                reasonseq,
                comments,
                genericattribute1,
                genericattribute2,
                genericattribute3,
                genericattribute4,
                genericattribute5,
                genericattribute6,
                genericattribute7,
                genericattribute8,
                genericattribute9,
                genericattribute10,
                genericattribute11,
                genericattribute12,
                genericattribute13,
                genericattribute14,
                genericattribute15,
                genericattribute16,
                genericnumber1,
                unittypeforgenericnumber1,
                genericnumber2,
                unittypeforgenericnumber2,
                genericnumber3,
                unittypeforgenericnumber3,
                genericnumber4,
                unittypeforgenericnumber4,
                genericnumber5,
                unittypeforgenericnumber5,
                genericnumber6,
                unittypeforgenericnumber6,
                genericdate1,
                genericdate2,
                genericdate3,
                genericdate4,
                genericdate5,
                genericdate6,
                genericboolean1,
                genericboolean2,
                genericboolean3,
                genericboolean4,
                genericboolean5,
                genericboolean6,
                processingunitseq
            FROM
                AIA_CB_CREDIT_STG crd
            WHERE
                crd.batch_no IN (:v_batch_no_lumpsum_comm,
                    :v_batch_no_ongoing_comm,
                    :v_batch_no_lumpsum_comp,
                    :v_batch_no_ongoing_comp,
                    :v_batch_no_special --revised by Win Tan for version 6
                )
                /*    inner join AIA_CB_BATCH_LIST cbl
                on crd.batch_no = cbl.batchnum*/;

        /* ORIGSQL: Log('[CB] Insert records into cs_credit' || '; row count: ' || to_char(sql%rowcount)) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert records into cs_credit'|| '; row count: '|| IFNULL(TO_VARCHAR(::ROWCOUNT),'')   
            );  /* ORIGSQL: to_char(sql%rowcount) */

        /* ORIGSQL: commit; */
        COMMIT;

        --delete the obsolete PM records belongs to last batchs
        -- Un Supported feature in Callidus - Commented out - Balaji Mar 17 2017
        --Log('[CB] Delete obsolete records in cs_measurement');
        --delete from cs_measurement pm
        -- where periodseq = Gv_Periodseq
        -- and pm.value = 0
        -- and pm.numberofcredits = 0
        -- and pm.genericnumber1 IS NULL
        -- and substr(pm.name, -3) = '_CB';
        --
        --Log('[CB] Delete obsolete records in cs_measurement' || '; row count: ' || to_char(sql%rowcount));
        --
        --commit;

        --insert records into cs_measurement
        /* ORIGSQL: Log('[CB] Insert COMMISSION records into cs_measurement for batch-' || v_batch_no_lumpsum_comm || ' and batch-' || v_batch_no_ongoing_comm) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert COMMISSION records into cs_measurement for batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comm),'') || ' and batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comm),''));

        /* ORIGSQL: Log('[CB] Insert COMPENSATION records into cs_measurement for batch-' || v_batch_no_lumpsum_comp || ' and batch-' || v_batch_no_ongoing_comp) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert COMPENSATION records into cs_measurement for batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comp),'') || ' and batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comp),''));

        /* ORIGSQL: Log(v_processingunitseq) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log(:v_processingunitseq);

        /* ORIGSQL: Log(v_batch_no_lumpsum_comm||' '|| v_batch_no_ongoing_comm||' '|| v_batch_no_lumpsum_comp||' '|| v_batch_no_ongoing_comp) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log(IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comm),'')||' '|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comm),'')||' '|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comp),'')||' '|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comp),''));    

        SELECT
            COUNT(*)
        INTO
            v_tempcount
        FROM
            AIA_CB_PM_STG pms
        INNER JOIN
            cs_period pd
            ON pd.periodseq = pms.periodseq
            AND pd.removedate = '1-jan-2200'
        INNER JOIN
            cs_position p
            ON p.ruleelementownerseq = pms.positionseq
            AND p.removedate = '1-jan-2200'
            AND pd.startdate BETWEEN p.effectivestartdate AND p.effectiveenddate-1
        LEFT OUTER JOIN
            cs_planassignable  pa
            ON (pa.ruleelementownerseq = p.titleseq)
            AND pa.removedate = '1-jan-2200'
            AND pd.startdate BETWEEN pa.effectivestartdate AND pa.effectiveenddate-1
        WHERE
            pms.batch_no IN (:v_batch_no_lumpsum_comm,
                :v_batch_no_ongoing_comm,
                :v_batch_no_lumpsum_comp,
                :v_batch_no_ongoing_comp,
                :v_batch_no_special --revised by Win Tan for version 6
            );

        -- group by new_measurementseq, pms.name, pms.payeeseq, pms.positionseq, pms.periodseq;

        /* ORIGSQL: Log('v_tempcount '||v_tempcount) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('v_tempcount '||IFNULL(TO_VARCHAR(:v_tempcount),''));

        --/*No permission in DEV 
        /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
        /* ORIGSQL: merge into cs_measurement tgt using (SELECT MAX(new_measurementseq) AS measurementseq, MAX(pa.planseq) AS planseq, 'AIAS' AS tenantid, pms.name, pms.payeeseq, pms.positionseq, pms.periodseq, MAX(pms.r(...) */
        MERGE INTO cs_measurement AS tgt    
            USING
            (
                SELECT   /* ORIGSQL: (select MAX(new_measurementseq) as measurementseq, MAX(pa.planseq) planseq, 'AIAS' tenantid, pms.name, pms.payeeseq, pms.positionseq, pms.periodseq, MAX(pms.ruleseq) as ruleseq, SUM(pms.value) as valu(...) */
                    --revised by Win for version 6
                    --new_measurementseq as measurementseq, 
                    MAX(new_measurementseq) AS measurementseq,
                    MAX(pa.planseq) AS planseq,
                    'AIAS' AS tenantid,
                    pms.name,
                    pms.payeeseq,
                    pms.positionseq,
                    pms.periodseq,
                    /* --v_pipelinerunseq as pipelinerunseq, */
                    /* --v_pipelinerundate as pipelinerundate, */
                    MAX(pms.ruleseq) AS ruleseq,
                    SUM(pms.value) AS value,
                    MAX(pms.unittypeforvalue) AS unittypeforvalue,
                    SUM(pms.numberofcredits) AS numberofcredits,
                    MAX(pms.businessunitmap) AS businessunitmap,
                    MAX(pms.genericnumber1) AS genericnumber1,
                    MAX(pms.unittypeforgenericnumber1) AS unittypeforgenericnumber1,
                    MAX(pms.processingunitseq) AS processingunitseq,
                    MAX(pms.unittypefornumberofcredits) AS unittypefornumberofcredits
                FROM
                    AIA_CB_PM_STG pms
                INNER JOIN
                    cs_period pd
                    ON pd.periodseq = pms.periodseq
                    AND pd.removedate = '1-jan-2200'
                INNER JOIN
                    cs_position p
                    ON p.ruleelementownerseq = pms.positionseq
                    AND p.removedate = '1-jan-2200'
                    AND pd.startdate BETWEEN p.effectivestartdate AND p.effectiveenddate-1
                LEFT OUTER JOIN
                    cs_planassignable pa
                    ON (pa.ruleelementownerseq = p.titleseq)
                    AND pa.removedate = '1-jan-2200'
                    AND pd.startdate BETWEEN pa.effectivestartdate AND pa.effectiveenddate-1
                WHERE
                    pms.batch_no IN (:v_batch_no_lumpsum_comm,
                        :v_batch_no_ongoing_comm,
                        :v_batch_no_lumpsum_comp,
                        :v_batch_no_ongoing_comp,
                        :v_batch_no_special --revised by Win Tan for version 6
                    )
                GROUP BY
                    --new_measurementseq,  --revised by Win for version 6
                    pms.name, pms.payeeseq, pms.positionseq, pms.periodseq
            ) AS src
            ON (src.positionseq = tgt.positionseq
                AND src.payeeseq = tgt.payeeseq
                AND src.periodseq = tgt.periodseq
                AND src.tenantid = tgt.tenantid
                AND src.processingunitseq = tgt.processingunitseq
            AND src.name = tgt.name)
        WHEN MATCHED THEN
            UPDATE
                SET tgt.planseq = src.planseq,
                -- tgt.pipelinerunseq=src.pipelinerunseq,
                --tgt.pipelinerundate=src.pipelinerundate,
                tgt.ruleseq = src.ruleseq,
                tgt.value = tgt.value+src.value, --Modified by Gopi-28112019-to get total sum of measurement
                tgt.unittypeforvalue = src.unittypeforvalue,
                tgt.numberofcredits = src.numberofcredits,
                tgt.businessunitmap = src.businessunitmap,
                tgt.genericnumber1 = src.genericnumber1,
                tgt.unittypeforgenericnumber1 = src.unittypeforgenericnumber1,
                tgt.unittypefornumberofcredits = src.unittypefornumberofcredits
            WHERE
                tgt.tenantid = 'AIAS';
        --and tgt.processingunitseq=v_processingunitseq;

        --*/

        /*This query only works once  - since the orig measurement seq is not backed up*/   
        /* ORIGSQL: update AIA_CB_PMCRDTRACE_STG tgt SET measurementseq = (SELECT CASE WHEN MAX(m.measurementseq) IS NULL THEN tgt.measurementseq ELSE MAX(m.measurementseq) END FROM cs_measurement m INNER join AIA_CB_PM_(...) */
        UPDATE AIA_CB_PMCRDTRACE_STG tgt 
            SET
            /* ORIGSQL: measurementseq = */
            measurementseq = (
                SELECT   /* ORIGSQL: (select CASE WHEN MAX(m.measurementseq) IS NULL THEN tgt.measurementseq ELSE MAX(m.measurementseq) END from cs_measurement m join AIA_CB_PM_STG pms on m.positionseq=pms.positionseq and m.payeeseq=pms.(...) */
                    /* --Version 12 add by Amanda begin */
                    /* --max(m.measurementseq) */
                    CASE
                        WHEN MAX(m.measurementseq) IS NULL
                        THEN tgt.measurementseq /* --for SPI CB, no need to update credit trace stage */
                        ELSE MAX(m.measurementseq)
                    END
                    /* --Version 12 add by Amanda end */
                FROM
                    cs_measurement m
                INNER JOIN
                    AIA_CB_PM_STG pms
                    ON m.positionseq = pms.positionseq
                    AND m.payeeseq = pms.payeeseq
                    AND m.periodseq = pms.periodseq /* --and src.tenantid=pms.tenantid */
                    AND m.processingunitseq = pms.processingunitseq
                    AND m.name = pms.name
                    AND m.tenantid = 'AIAS'
                WHERE
                    pms.batch_no IN (:v_batch_no_lumpsum_comm,
                        :v_batch_no_ongoing_comm,
                        :v_batch_no_lumpsum_comp,
                        :v_batch_no_ongoing_comp,
                        :v_batch_no_special /* --revised by Win Tan for version 6 */
                    )
                    AND pms.new_measurementseq = tgt.measurementseq
                    AND pms.batch_no = tgt.batch_no
            )
        FROM
            AIA_CB_PMCRDTRACE_STG tgt
        WHERE
            tgt.batch_no IN (:v_batch_no_lumpsum_comm,
                :v_batch_no_ongoing_comm,
                :v_batch_no_lumpsum_comp,
                :v_batch_no_ongoing_comp,
                :v_batch_no_special /* --revised by Win Tan for version 6 */
            );

        /*
        
        insert into cs_measurement
          (measurementseq, planseq,
               name,
               payeeseq,
               positionseq,
               periodseq,
               pipelinerunseq,
               pipelinerundate,
               ruleseq,
               value,
               unittypeforvalue,
               numberofcredits,
               businessunitmap,
               genericnumber1,
               unittypeforgenericnumber1,
               processingunitseq,
           unittypefornumberofcredits)
          select new_measurementseq as measurementseq, max(pa.planseq),
                 pms.name,
                 pms.payeeseq,
                 pms.positionseq,
                 pms.periodseq,
                 v_pipelinerunseq as pipelinerunseq,
                 v_pipelinerundate as pipelinerundate,
                 max(pms.ruleseq) as ruleseq,
                 sum(pms.value) as value,
                 max(pms.unittypeforvalue) as unittypeforvalue,
                 sum(pms.numberofcredits) as numberofcredits,
                 max(pms.businessunitmap) as businessunitmap,
                 max(pms.genericnumber1) as genericnumber1,
                 max(pms.unittypeforgenericnumber1) as unittypeforgenericnumber1,
                 max(pms.processingunitseq),
                 max(pms.unittypefornumberofcredits)
            from AIA_CB_PM_STG pms
            join cs_period pd
        on pd.periodseq=pms.periodseq and pd.removedate='1-jan-2200'
        join  cs_position p
        on p.ruleelementownerseq=pms.positionseq and p.removedate='1-jan-2200'
        and pd.startdate between p.effectivestartdate and p.effectiveenddate-1
        left join  cs_planassignable  pa
        on (pa.ruleelementownerseq=p.titleseq) and pa.removedate='1-jan-2200'
        and pd.startdate between pa.effectivestartdate and pa.effectiveenddate-1
            where pms.batch_no in (v_batch_no_lumpsum_comm,
                                      v_batch_no_ongoing_comm,
                                      v_batch_no_lumpsum_comp,
                                  v_batch_no_ongoing_comp)
            group by new_measurementseq, pms.name, pms.payeeseq, pms.positionseq, pms.periodseq
        ; */

        /* ORIGSQL: Log('[CB] Merge records into cs_measurement' || '; row count: ' || to_char(sql%rowcount)) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Merge records into cs_measurement'|| '; row count: '|| IFNULL(TO_VARCHAR(::ROWCOUNT),'')   
            );  /* ORIGSQL: to_char(sql%rowcount) */

        /*
        select ruleelementownerseq, count(*)
        from cs_planassignable
        where effectiveenddate>sysdate and removedate>sysdate
        group by ruleelementownerseq
        having count(*)>1 returns  nothing
        
        
        merge into cs_measurement tgt
        using(
            select m.measurementseq, pa.planseq from cs_measurement m
            join cs_period pd
            on pd.periodseq=m.periodseq and pd.removedate='1-jan-2200'
            join  cs_position p
            on p.ruleelementownerseq=m.positionseq and p.removedate='1-jan-2200'
            and pd.startdate between pos.effectivestartdate and pos.effectiveenddate-1
            join cs_planassignable pa
            on (pa.ruleelementownerseq=p.ruleelementownerseq or pa.ruleelementownerseq=p.titleseq) and pa.removedate='1-jan-2200'
            and pd.startdate between pa.effectivestartdate and pa.effectiveenddate-1
            where  pa.planseq IS NOT NULL and m.tenantid = 'AIAS' and m.processingunitseq=gv_processingUnitSeq
            and m.name in (select name from AIA_CB_PM_STG pms where pms.batch_no in (v_batch_no_lumpsum_comm,
                                              v_batch_no_ongoing_comm,
                                      v_batch_no_lumpsum_comp, v_batch_no_ongoing_comp))
        ) src
        on (src.measurementseq=tgt.measurementseq)
        when matched then update set tgt.planseq=src.planseq
        where    tgt.planseq IS NULL
         and tgt.tenantid='AIAS' and tgt.processingunitseq=gv_processingUnitSeq ;
          */

        /* ORIGSQL: commit; */
        COMMIT;

        --insert records into cs_pmcredittrace
        /* ORIGSQL: Log('[CB] Insert COMMISSION records into cs_pmcredittrace for batch-' || v_batch_no_lumpsum_comm || ' and batch-' || v_batch_no_ongoing_comm) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert COMMISSION records into cs_pmcredittrace for batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comm),'') || ' and batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comm),''));

        /* ORIGSQL: Log('[CB] Insert COMPENSATION records into cs_pmcredittrace for batch-' || v_batch_no_lumpsum_comp || ' and batch-' || v_batch_no_ongoing_comp) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert COMPENSATION records into cs_pmcredittrace for batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_lumpsum_comp),'') || ' and batch-'|| IFNULL(TO_VARCHAR(:v_batch_no_ongoing_comp),'')); 

        /* ORIGSQL: insert into cs_pmcredittrace (TENANTID, creditSeq, measurementSeq, ruleSeq, pipelineRunSeq, sourcePeriodSeq, targetPeriodSeq, sourceorigintypeid, contributionValue, unittypeforContributionValue, busin(...) */
        INSERT INTO cs_pmcredittrace
            (
                TENANTID,
                creditSeq,
                measurementSeq,
                ruleSeq,
                pipelineRunSeq,
                sourcePeriodSeq,
                targetPeriodSeq,
                sourceorigintypeid,
                contributionValue,
                unittypeforContributionValue,
                businessunitMap,
                processingUnitSeq
            )
            SELECT   /* ORIGSQL: select 'AIAS' as Tenantid, creditseq, measurementseq, ruleseq, v_pipelinerunseq as pipelinerunseq, sourceperiodseq, targetperiodseq, sourceorigintypeid, contributionvalue, unittypeforcontributionvalue(...) */
                'AIAS' AS Tenantid,
                creditseq,
                measurementseq,
                ruleseq,
                :v_pipelinerunseq AS pipelinerunseq,
                sourceperiodseq,
                targetperiodseq,
                sourceorigintypeid,
                contributionvalue,
                unittypeforcontributionvalue,
                businessunitmap,
                processingunitseq
            FROM
                AIA_CB_PMCRDTRACE_STG pcs
                /*    inner join AIA_CB_BATCH_LIST cbl
                on pcs.batch_no = cbl.batchnum */
            WHERE
                pcs.batch_no IN (:v_batch_no_lumpsum_comm,
                    :v_batch_no_ongoing_comm,
                    :v_batch_no_lumpsum_comp,
                    :v_batch_no_ongoing_comp,
                    :v_batch_no_special --revised by Win Tan for version 6
                );

        /* ORIGSQL: Log('[CB] Insert records into cs_pmcredittrace' || '; row count: ' || to_char(sql%rowcount)) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Insert records into cs_pmcredittrace'|| '; row count: '|| IFNULL(TO_VARCHAR(::ROWCOUNT),'')   
            );  /* ORIGSQL: to_char(sql%rowcount) */

        /* ORIGSQL: commit; */
        COMMIT;

        --Version 12 add by Amanda begin 
        SELECT
            startDate
        INTO
            v_periodStartDate
        FROM
            cs_period
        WHERE
            periodSeq = :i_periodSeq;

        --get previous quarter for YTD clawback  
        SELECT
            qtr.name
        INTO
            v_previous_qtr
        FROM
            cs_period csp
        INNER JOIN
            cs_period qtr
            ON csp.parentseq = qtr.periodseq
            AND qtr.removedate = '1-jan-2200'
            AND qtr.calendarseq = :gv_calendarSeq
            AND qtr.periodtypeseq = 2814749767106563 --quarter
        WHERE
            csp.startdate = ADD_MONTHS(:v_periodStartDate, -3)
            AND csp.removedate = '1-jan-2200'
            AND csp.periodtypeseq = 2814749767106561 --month
            AND csp.calendarseq = :gv_calendarSeq;

        /* ORIGSQL: Log('[CB] Get previous quarter for SPI FA CB' || '; row count: ' || to_char(sql%rowcount)) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Get previous quarter for SPI FA CB'|| '; row count: '|| IFNULL(TO_VARCHAR(::ROWCOUNT),'')   
            );  /* ORIGSQL: to_char(sql%rowcount) */

        /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
        /* ORIGSQL: merge into cs_measurement tgt using (SELECT 'AIAS' AS tenantid, cb.buname, cb.year, cb.quarter, cb.WRI_AGT_CODE, pos.ruleelementownerseq, pos.payeeseq, sum(CASE WHEN cb.year = EXTRACT(YEAR FROM v_peri(...) */
        MERGE INTO cs_measurement AS tgt  
            USING
            (
                SELECT   /* ORIGSQL: (select 'AIAS' as tenantid, cb.buname, cb.year, cb.quarter, cb.WRI_AGT_CODE, pos.ruleelementownerseq, pos.payeeseq, sum(CASE WHEN cb.year = EXTRACT(YEAR FROM v_periodStartDate) THEN YTD_SPI_CB ELSE 0 (...) */
                    'AIAS' AS tenantid,
                    cb.buname,
                    cb.year,
                    cb.quarter,
                    cb.WRI_AGT_CODE,
                    pos.ruleelementownerseq,
                    pos.payeeseq,
                    SUM(
                        CASE   /* ORIGSQL: sum(CASE WHEN cb.year = EXTRACT(YEAR FROM v_periodStartDate) THEN YTD_SPI_CB ELSE 0 END) */
                            WHEN cb.year = EXTRACT(YEAR FROM :v_periodStartDate)
                            THEN YTD_SPI_CB /* --ONGONING YTD FYC CB */
                            ELSE 0
                        END
                    ) AS YTD_SPI_CB
                FROM
                    AIA_CB_SPI_CLAWBACK cb
                INNER JOIN
                    cs_position pos
                    ON pos.name = 'SGT'||IFNULL(cb.WRI_AGT_CODE,'')
                    AND pos.tenantid = 'AIAS'
                    AND pos.removedate = '1-jan-2200'
                    AND v_periodStartDate BETWEEN pos.effectivestartdate AND pos.effectiveenddate-1
                WHERE
                    (IFNULL(cb.quarter,'') || ' '|| IFNULL(cb.year,'')) = :v_previous_qtr
                    AND cb.buname = 'SGPAFA'
                GROUP BY
                    cb.buname,
                    cb.year,
                    cb.quarter,
                    cb.WRI_AGT_CODE,
                    pos.ruleelementownerseq,
                    pos.payeeseq
            ) AS src
            ON (src.ruleelementownerseq = tgt.positionseq
                AND src.payeeseq = tgt.payeeseq
                AND i_periodSeq = tgt.periodseq
                AND src.tenantid = tgt.tenantid
            )
        WHEN MATCHED THEN
            UPDATE
                SET tgt.value = YTD_SPI_CB
            WHERE
                tgt.tenantid = 'AIAS'
                AND tgt.processingunitseq = :Gv_Processingunitseq
                AND tgt.name = 'PM_SPI_ONG_YTD_CB';

        /* ORIGSQL: Log('[CB] Merge records into cs_measurement for SPI FA ONGOING YTD CB' || '; row count: ' || to_char(sql%rowcount)) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] Merge records into cs_measurement for SPI FA ONGOING YTD CB'|| '; row count: '|| IFNULL(TO_VARCHAR(::ROWCOUNT),'')   
            );  /* ORIGSQL: to_char(sql%rowcount) */

        /* ORIGSQL: commit; */
        COMMIT;

        --Version 12 end

        --update the batch status to complete
        /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(v_batch_no_lumpsum_comm, STR_STATUS_COMPLETED_SH) */
        CALL PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(:v_batch_no_lumpsum_comm, :STR_STATUS_COMPLETED_SH);  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'PK_AIA_CB_CALCULATION_FA.sp_update_batch_status' */

        /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(v_batch_no_ongoing_comm, STR_STATUS_COMPLETED_SH) */
        CALL PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(:v_batch_no_ongoing_comm, :STR_STATUS_COMPLETED_SH);

        --Commented by Win Tan for version 4
        --PK_AIA_CB_CALCULATION.sp_update_batch_status(v_batch_no_lumpsum_comp, STR_STATUS_COMPLETED_SH);
        --PK_AIA_CB_CALCULATION.sp_update_batch_status(v_batch_no_ongoing_comp, STR_STATUS_COMPLETED_SH);

        --Added by Win Tan for version 4 **Begin**
        IF sapdbmtk.sp_f_dbmtk_format_string_to_datetime(:v_str_cycledate,'yyyy-mm-dd') = :v_period_end  /* ORIGSQL: to_date(v_str_cycledate,'yyyy-mm-dd') */
        THEN
            /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(v_batch_no_lumpsum_comp, STR_STATUS_COMPLETED_SH) */
            CALL PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(:v_batch_no_lumpsum_comp, :STR_STATUS_COMPLETED_SH);

            /* ORIGSQL: PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(v_batch_no_ongoing_comp, STR_STATUS_COMPLETED_SH) */
            CALL PK_AIA_CB_CALCULATION_FA.sp_update_batch_status(:v_batch_no_ongoing_comp, :STR_STATUS_COMPLETED_SH);
        END IF;
        --Added by Win Tan for version 4 **End**
        --added by Win for version 6
        --update the batch status for special handling   
        /* ORIGSQL: update aia_cb_batch_special SET ISACTIVE = 'N' where batchnum = v_batch_no_special and ISACTIVE = 'Y' and SPEC_RUN_DATE = to_date(v_str_cycledate, 'yyyy-mm-dd') and BUNAME = 'SGPAFA'; */
        UPDATE aia_cb_batch_special
            SET
            /* ORIGSQL: ISACTIVE = */
            ISACTIVE = 'N' 
        FROM
            aia_cb_batch_special
        WHERE
            batchnum = :v_batch_no_special
            AND ISACTIVE = 'Y'
            AND SPEC_RUN_DATE = sapdbmtk.sp_f_dbmtk_format_string_to_datetime(:v_str_cycledate, 'yyyy-mm-dd')  /* ORIGSQL: to_date(v_str_cycledate, 'yyyy-mm-dd') */
            AND BUNAME = 'SGPAFA';

        --v19 add BUNAME
    ELSE 
        /* ORIGSQL: Log('[CB] ' || v_str_cycledate || ' not exit in pipeline run period: ' || Gv_Periodseq) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] '|| IFNULL(:v_str_cycledate,'') || ' not exit in pipeline run period: '|| IFNULL(TO_VARCHAR(:Gv_Periodseq),''));
    END IF;

    ---catch exception
    /* ORIGSQL: EXCEPTION WHEN OTHERS THEN */
END;

--end

/********************below are common used store proc**********************************/
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__SP_CLAWBACK_CALCULATION_FA') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__comUpdPMCreditTrace' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__comUpdPMCreditTrace''...' );
go

/* ORIGSQL: procedure comUpdPMCreditTrace(i_component in varchar2) as vSeq number; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__comUpdPMCreditTrace
(
    IN i_component VARCHAR(255)   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                  /* ORIGSQL: i_component IN varchar2 */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE gv_error VARCHAR(1000); /* package/session variable */
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE vSeq DECIMAL(38,10);  /* ORIGSQL: vSeq number; */

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            gv_error = 'Error [' || IFNULL(:i_component,'') || ' pmCreditTrace]: ' ||
            ::SQL_ERROR_MESSAGE || ' - ' ||  /* ORIGSQL: sqlerrm */

            /* RESOLVE: Standard Package call(not converted): 'dbms_utility.format_error_backtrace' not supported, manual conversion required */
            dbms_utility.format_error_backtrace;
            /* Saving modified package/session variable 'gv_error': */ 
            SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR' = :gv_error;

            /* ORIGSQL: comDebugger('pm trace', 'err:' || gv_error) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('pm trace', 'err:'|| IFNULL(:gv_error,''));

            /* ORIGSQL: rollback; */
            ROLLBACK;
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR') INTO gv_error FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
        /* end of package/session variables */



    --refresh PMCreditTrace

    /* ORIGSQL: Log('55') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('55'); 

    /* ORIGSQL: delete from cs_PMCreditTrace t where exists (SELECT 1 FROM sh_sequence scm where 1 = 1 and scm.seqType = 'PMSEQ' and t.measurementSeq = scm.businessSeq) ; */
    DELETE
    FROM
        cs_PMCreditTrace
        t
    WHERE 
        EXISTS
        (
            SELECT   /* ORIGSQL: (select 1 from sh_sequence scm where 1 = 1 and scm.seqType = 'PMSEQ' and t.measurementSeq = scm.businessSeq) */
                1
            FROM
                sh_sequence scm
            WHERE
                1 = 1
                AND scm.seqType = 'PMSEQ'
                AND t.measurementSeq = scm.businessSeq
        );

    /* ORIGSQL: Commit; */
    COMMIT;

    /* ORIGSQL: Log('55') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('55');

    --vSeq := SequenceGenPkg.GetNextFullSeq('auditLogSeq', classid.cIdAuditLog);
    ---- update CS_PMCreditTrace

    /* ORIGSQL: Log('56') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('56');   

    /* RESOLVE: Syntax not supported in target DBMS: INSERT ALL (array-INSERT); not supported in target DBMS, manual conversion required */
    insert ALL into cs_pmCreditTrace
        (creditSeq,
            measurementSeq,
            ruleSeq,
            pipelineRunSeq,
            targetPeriodSeq,
            sourcePeriodSeq,
            sourceorigintypeid,
            contributionValue,
            unittypeforContributionValue,
            businessunitMap,
        processingUnitSeq)
    VALUES
        (creditSeq,
            measurementSeq,
            IFNULL(ruleSeq,0),  /* ORIGSQL: nvl(ruleSeq,0) */
            pipelineRunSeq,
            targetPeriodSeq,
            sourcePeriodSeq,
            sourceorigintypeid,
            contributionValue,
            unittypeforContributionValue,
            businessunitMap,
        processingUnitSeq)
        SELECT   /* ORIGSQL: select rn, creditSeq, measurementSeq, ruleSeq, pipelineRunSeq, targetPeriodSeq, sourcePeriodSeq, sourceOriginTypeId, contributionValue, unitTypeForContributionValue, businessUnitMap, processingunitseq(...) */
            rn,
            creditSeq,
            measurementSeq,
            ruleSeq,
            pipelineRunSeq,
            targetPeriodSeq,
            sourcePeriodSeq,
            sourceOriginTypeId,
            contributionValue,
            unitTypeForContributionValue,
            businessUnitMap,
            processingunitseq
        FROM
            (
                WITH 
                csp
                AS (
                    /* ORIGSQL: select / *+ materialize * / */
                    SELECT   /* ORIGSQL: (select scc.businessSeq as ccseq, scc.periodseq as pseq, scm.businessSeq as pmseq from sh_sequence scc, sh_sequence scm where scc.seqtype = 'CREDITSEQ' and scm.seqtype = 'PMSEQ' and scc.payeeseq = scm(...) */
                        scc.businessSeq AS ccseq,
                        scc.periodseq AS pseq,
                        scm.businessSeq AS pmseq
                    FROM
                        sh_sequence scc,
                        sh_sequence scm
                    WHERE
                        scc.seqtype = 'CREDITSEQ'
                        AND scm.seqtype = 'PMSEQ'
                        AND scc.payeeseq = scm.payeeseq
                        AND scc.positionseq = scm.positionseq
                        AND scc.periodSeq = scm.periodSeq
                
                )
                SELECT   /* ORIGSQL: select ROW_NUMBER() OVER (ORDER BY 0*0) as rn, cc.creditSeq, cm.measurementSeq, cm.ruleSeq, (SELECT MAX(Pipelinerunseq) FROM Cs_Pipelinerun Where Periodseq = Cc.Periodseq and command = 'PipelineRun'),(...) */
                    ROW_NUMBER() OVER (ORDER BY 0*0) AS rn,  /* ORIGSQL: rownum */
                    cc.creditSeq,
                    cm.measurementSeq,
                    cm.ruleSeq,
                    (
                        /* ORIGSQL: Select / *+ INDEX(Cs_Pipelinerun Cs_Pipelinerun_MAX) * / */
                        SELECT   /* ORIGSQL: (Select MAX(Pipelinerunseq) From Cs_Pipelinerun Where Periodseq = Cc.Periodseq and command = 'PipelineRun') */
                            MAX(Pipelinerunseq)
                        FROM
                            Cs_Pipelinerun
                        WHERE
                            Periodseq = Cc.Periodseq
                            AND command = 'PipelineRun'
                    )   /* RESOLVE: Syntax not supported in target DBMS: Subquery correlation name ('as pipelineRunSeq,') not allowed for expression subqueries */
                    ,  /* ORIGSQL: as pipelineRunSeq, */
                    cm.periodSeq AS targetPeriodSeq,
                    cc.periodSeq AS sourcePeriodSeq,
                    cc.originTypeId AS sourceOriginTypeId,
                    cc.value AS contributionValue,
                    cc.unitTypeForValue AS unitTypeForContributionValue,
                    cc.businessUnitMap,
                    cc.processingunitseq
                FROM
                    cs_credit cc,
                    cs_measurement cm,
                    csp
                WHERE
                    cc.tenantid = 'AIAS'
                    AND cm.tenantid = 'AIAS'
                    AND Cc.Processingunitseq = :Gv_Processingunitseq
                    AND Cm.Processingunitseq = :Gv_Processingunitseq
                    AND Cc.Origintypeid IN ('calculated', 'imported')
                    AND csp.pmseq = cm.measurementSeq
                AND csp.ccseq = cc.creditseq) t;

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('57') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('57');

    --comAuditLog('PMCreditTrace','Administrator','PMCreditTrace','');
    --SequenceGenPkg.updateSeq('auditLogSeq');

    /* ORIGSQL: exception when others then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__comUpdPMCreditTrace') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating function 'DBMTK_USER_NAME.PK_STAGE_HOOK__comGetQuarterMonth' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating function ''DBMTK_USER_NAME.PK_STAGE_HOOK__comGetQuarterMonth''...' );
go

/* ORIGSQL: function comGetQuarterMonth(i_periodSeq in int) return int is DECLARE NOT_QUARTER_END CONDITION; */
CREATE OR REPLACE FUNCTION DBMTK_USER_NAME.PK_STAGE_HOOK__comGetQuarterMonth
(
    IN i_periodSeq BIGINT     /* ORIGSQL: i_periodSeq IN int */
)
RETURNS dbmtk_function_result BIGINT   /* ORIGSQL: return int */
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
AS
BEGIN
    DECLARE gv_error VARCHAR(1000); /* package/session variable */
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();
    DECLARE gv_calendarSeq BIGINT; /* package/session variable */
    DECLARE gv_prePeriodSeq1 BIGINT; /* package/session variable */
    DECLARE gv_prePeriodSeq2 BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE NOT_QUARTER_END CONDITION;  /* ORIGSQL: NOT_QUARTER_END EXCEPTION; */
    DECLARE v_periodTypeSeq BIGINT = 0;  /* ORIGSQL: v_periodTypeSeq int := 0; */

    DECLARE EXIT HANDLER FOR NOT_QUARTER_END
        /* ORIGSQL: WHEN NOT_QUARTER_END then */
        BEGIN
            gv_error = 'Info [SP_UPDATE_DO_QUARTERLY]: The stage hook will be skip in current period.';
            /* Saving modified package/session variable 'gv_error': */ 
            SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR' = :gv_error;   
            dbmtk_function_result = - 1;
            /* sapdbmtk: Closing RETURN in exception handler commented out, not supported in HANA */
            --RETURN;
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this function */
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR') INTO gv_error FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CALENDARSEQ') AS BIGINT) INTO gv_calendarSeq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PREPERIODSEQ1') AS BIGINT) INTO gv_prePeriodSeq1 FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PREPERIODSEQ2') AS BIGINT) INTO gv_prePeriodSeq2 FROM SYS.DUMMY ;
        /* end of package/session variables */


    BEGIN 
        DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 1299 /*1299=ERR_SQLSCRIPT_NO_DATA_FOUND*/
            /* ORIGSQL: when no_data_found then */
            BEGIN 
                dbmtk_function_result = - 1;
                /* RESOLVE: Syntax not supported in target DBMS: RETURN in exception handler not supported in HANA, rewrite manually */
                RETURN;
            END;

             

        SELECT
            periodTypeSeq
        INTO
            v_periodTypeSeq
        FROM
            cs_period
        WHERE
            tenantid = 'AIAS'
            AND periodSeq = :i_periodSeq
            -- 20171213 COSIMO Project begin
            --and shortName in ('Feb', 'May', 'Aug', 'Nov')
            AND shortName IN ('Mar', 'Jun', 'Sep', 'Dec')
            -- 20171213 COSIMO Project end
            AND Removedate = :cdt_EndOfTime
            AND CALENDARSEQ = :gv_calendarSeq;

        /* ORIGSQL: exception when no_data_found then */
    END;

    IF :v_periodTypeSeq = NULL
    THEN
        /* ORIGSQL: raise NOT_QUARTER_END; */
        SIGNAL NOT_QUARTER_END;
    END IF;

    --version 7
    --select max(periodSeq)
    --  into gv_prePeriodSeq1
    --  from cs_period
    -- where tenantid='AIAS' and periodSeq < i_periodSeq
    -- and periodTypeSeq = v_periodTypeSeq
    -- And Removedate = Cdt_Endoftime
    -- AND CALENDARSEQ = GV_CALENDARSEQ;
    --
    --select max(periodSeq)
    --  into gv_prePeriodSeq2
    --  from cs_period
    -- where tenantid='AIAS' and periodSeq < gv_prePeriodSeq1
    -- and periodTypeSeq = v_periodTypeSeq
    -- and removeDate = cdt_EndOfTime
    -- AND CALENDARSEQ = GV_CALENDARSEQ; 

    SELECT
        MAX(a.periodseq) 
    INTO
        gv_prePeriodSeq1
    FROM
        cs_period a
        ,
        (
            SELECT   /* ORIGSQL: (select startdate,enddate from cs_period where periodseq = i_periodSeq and removedate = Cdt_Endoftime) */
                startdate,
                enddate
            FROM
                cs_period
            WHERE
                periodseq = :i_periodSeq
                AND removedate = :cdt_EndOfTime
        ) AS b
    WHERE
        a.tenantid = 'AIAS'
        AND a.periodTypeSeq = :v_periodTypeSeq
        AND a.Removedate = :cdt_EndOfTime
        AND a.CALENDARSEQ = :gv_calendarSeq
        AND a.startdate = ADD_MONTHS(b.startdate,-1)
        AND a.enddate = ADD_MONTHS(b.enddate,-1);

    SELECT
        MAX(a.periodseq) 
    INTO
        gv_prePeriodSeq2
    FROM
        cs_period a
        ,
        (
            SELECT   /* ORIGSQL: (select startdate,enddate from cs_period where periodseq = i_periodSeq and removedate = Cdt_Endoftime) */
                startdate,
                enddate
            FROM
                cs_period
            WHERE
                periodseq = :i_periodSeq
                AND removedate = :cdt_EndOfTime
        ) AS b
    WHERE
        a.tenantid = 'AIAS'
        AND a.periodTypeSeq = :v_periodTypeSeq
        AND a.Removedate = :cdt_EndOfTime
        AND a.CALENDARSEQ = :gv_calendarSeq
        AND a.startdate = ADD_MONTHS(b.startdate,-2)
        AND a.enddate = ADD_MONTHS(b.enddate,-2);

    dbmtk_function_result = 1;
    RETURN;

    /* ORIGSQL: exception WHEN NOT_QUARTER_END then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('function', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__comGetQuarterMonth') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__comExceptionHandling' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__comExceptionHandling''...' );
go

/* ORIGSQL: procedure comExceptionHandling(i_category in varchar2, i_subCategory in varchar2, i_module in varchar2, i_objSeq in int, i_errMsg in varchar2) as DEC_MessageLogSeq CS_Message.messageLogSeq%type; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__comExceptionHandling
(
    IN i_category VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                  /* ORIGSQL: i_category IN varchar2 */
    IN i_subCategory VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                     /* ORIGSQL: i_subCategory IN varchar2 */
    IN i_module VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                /* ORIGSQL: i_module IN varchar2 */
    IN i_objSeq BIGINT,   /* ORIGSQL: i_objSeq IN int */
    IN i_errMsg VARCHAR(255)   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                               /* ORIGSQL: i_errMsg IN varchar2 */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
READS SQL DATA
AS
BEGIN
    DECLARE DBMTK_TMPVAR_INT_1 BIGINT; /*sapdbmtk-generated help variable*/
    :DEC_MessageLogSeq CS_Message.messageLogSeq%type;;/* NOT CONVERTED! */
    :DEC_MessageSeq    CS_Message.messageSeq%type;;/* NOT CONVERTED! */

    /* ORIGSQL: NULL; */
    DBMTK_TMPVAR_INT_1 = 0;/* sapdbmtk: this is a dummy statement to avoid syntax errors, if possible, delete this line */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__comExceptionHandling') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__comAuditLog' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__comAuditLog''...' );
go

/* ORIGSQL: procedure comAuditLog(i_eventType in varchar2, i_userId in varchar2, i_objectName in varchar2, i_log in varchar2) as begin */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__comAuditLog
(
    IN i_eventType VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                   /* ORIGSQL: i_eventType IN varchar2 */
    IN i_userId VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                /* ORIGSQL: i_userId IN varchar2 */
    IN i_objectName VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                    /* ORIGSQL: i_objectName IN varchar2 */
    IN i_log VARCHAR(255)   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                            /* ORIGSQL: i_log IN varchar2 */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE gv_error VARCHAR(1000); /* package/session variable */ 

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            gv_error = 'Info [SP_UPDATE_DO_QUARTERLY]: The stage hook will be skip in current period.';
            /* Saving modified package/session variable 'gv_error': */ 
            SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR' = :gv_error;

            --comExceptionHandling(sqlcode,sqlerrm);
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR') INTO gv_error FROM SYS.DUMMY ;
        /* end of package/session variables */

         

    RETURN;

    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_AUDITLOG_CUSTOM' not found */

    /* ORIGSQL: INSERT INTO CS_AUDITLOG_CUSTOM (auditLogSeq, objectSeq, eventDate, eventType, userId, objectName, eventDescription, objectType, businessUnitMap) VALUES (DBMTK_USER_NAME.AIA_Sequence_msg.NEXTVAL+ROWNUM(...) */
    INSERT INTO CS_AUDITLOG_CUSTOM
        (
            auditLogSeq,
            objectSeq,
            eventDate,
            eventType,
            userId,
            objectName,
            eventDescription,
            objectType,
            businessUnitMap
        )
    VALUES
        (
                DBMTK_USER_NAME.AIA_Sequence_msg.NEXTVAL+ROWNUM,  /* RESOLVE: ROWNUM pseudo-column(not converted): Rewrite 'ROWNUM' as TOP/LIMIT or 'ROW_NUMBER() OVER...' with subquery */
                                                                  /* RESOLVE: Identifier not found: Sequence not found: */
                                                                  /* ORIGSQL: AIA_Sequence_msg.nextval */
                0 /* -- objSeq, */,
                CURRENT_TIMESTAMP   /* --ImportUtils.vPipelineRunDate, */,  /* ORIGSQL: sysdate */
                :i_eventType,
                :i_userId,
                :i_objectName,
                :i_log,
                NULL /* -- objectType */,
                NULL /* -- businessUnitMap */
        );

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: exception when others then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__comAuditLog') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger''...' );
go

/* ORIGSQL: procedure comDebugger(i_objName in varchar2, i_objContent in varchar2) is BEGIN AUTONOMOUS TRANSACTION begin pragma autonomous_transaction; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger
(
    IN i_objName VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                 /* ORIGSQL: i_objName IN varchar2 */
    IN i_objContent VARCHAR(255)   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                   /* ORIGSQL: i_objContent IN varchar2 */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    /* ORIGSQL: pragma autonomous_transaction; */
    BEGIN AUTONOMOUS TRANSACTION
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.SH_DEBUGGER' not found */

        /* ORIGSQL: insert into sh_debugger values (i_objName, sysdate, i_objContent); */
        INSERT INTO sh_debugger
        VALUES (
                :i_objName,
                CURRENT_TIMESTAMP,  /* ORIGSQL: sysdate */
                :i_objContent
        );

        /* ORIGSQL: commit; */
        COMMIT;
    END;

    /*
    Modified at Aug 17 2014
    Desc: change tbl_agent_role_move to DM_tbl_agent_role_move
    */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__comDebugger') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__comConvertAgentRole' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__comConvertAgentRole''...' );
go

/* ORIGSQL: procedure comConvertAgentRole(i_periodSeq in int) as v_perviousAgent varchar2(30) := ''; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__comConvertAgentRole
(
    IN i_periodSeq BIGINT     /* ORIGSQL: i_periodSeq IN int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE DBMTK_TMPVAR_INT_1 BIGINT; /*sapdbmtk-generated help variable*/
    DECLARE gv_error VARCHAR(1000); /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE v_perviousAgent VARCHAR(30) = '';  /* ORIGSQL: v_perviousAgent varchar2(30) := ''; */
    DECLARE v_perviousRown BIGINT = 1;  /* ORIGSQL: v_perviousRown int := 1; */
    DECLARE v_perAgentRole VARCHAR(30);  /* ORIGSQL: v_perAgentRole varchar2(30); */
    DECLARE v_perAgencyLeader VARCHAR(30);  /* ORIGSQL: v_perAgencyLeader varchar2(30); */
    DECLARE v_perAgencyCode VARCHAR(30);  /* ORIGSQL: v_perAgencyCode varchar2(30); */
    DECLARE v_perDistrict VARCHAR(30);  /* ORIGSQL: v_perDistrict varchar2(30); */
    DECLARE v_perClass VARCHAR(10);  /* ORIGSQL: v_perClass varchar2(10); */
    DECLARE v_perDteEffective TIMESTAMP;  /* ORIGSQL: v_perDteEffective date; */
    DECLARE v_cutoffdate TIMESTAMP;  /* ORIGSQL: v_cutoffdate date; */

    /* ORIGSQL: for c_agt in (select agt.*, CASE WHEN agt.old_role IN ('DM', 'FSD') THEN 'FSD' WHEN agt.old_role in ('ADM', 'FSAD') THEN 'FSAD' WHEN agt.old_role in ('M1', 'FSM') THEN 'FSM' WHEN agt.old_role = 'AM' T(...) */
    DECLARE CURSOR dbmtk_cursor_2023
    FOR 
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.DM_TBL_AGENT_ROLE_MOVE' not found */

        SELECT   /* ORIGSQL: select agt.*, CASE WHEN agt.old_role IN ('DM', 'FSD') THEN 'FSD' WHEN agt.old_role in ('ADM', 'FSAD') THEN 'FSAD' WHEN agt.old_role in ('M1', 'FSM') THEN 'FSM' WHEN agt.old_role = 'AM' THEN 'AM' WHEN (...) */
            agt.*,
            CASE
                WHEN agt.old_role IN ('DM', 'FSD')
                THEN 'FSD'
                WHEN agt.old_role IN ('ADM', 'FSAD')
                THEN 'FSAD'
                WHEN agt.old_role IN ('M1', 'FSM')
                THEN 'FSM'
                WHEN agt.old_role = 'AM'
                THEN 'AM'
                WHEN agt.old_role IN ('AAL', 'FSC')
                THEN 'FSC'
            END
            AS oldTitle,
            CASE
                WHEN agt.new_role IN ('DM', 'FSD')
                THEN 'FSD'
                WHEN agt.new_role IN ('ADM', 'FSAD')
                THEN 'FSAD'
                WHEN agt.new_role IN ('M1', 'FSM')
                THEN 'FSM'
                WHEN agt.new_role = 'AM'
                THEN 'AM'
                WHEN agt.new_role IN ('AAL', 'FSC')
                THEN 'FSC'
            END
            AS newTitle,
            ROW_NUMBER() OVER (PARTITION BY agt.txtagt ORDER BY agt.dteEffective) AS rown,
            MAX(agt.dteEffective) OVER(PARTITION BY agt.txtagt) AS maxEffectiveDate,
            COUNT(1) OVER(PARTITION BY Agt.Txtagt) AS Cnt
        FROM
            Dm_Tbl_Agent_Role_Move Agt
        WHERE
            1 = 1
            AND agt.dteeffective <= :v_cutoffdate
        ORDER BY
            txtagt, dteEffective;

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            gv_error = 'Error [comConvertAgentRole]: ' || ::SQL_ERROR_MESSAGE || ' - ' ||  /* ORIGSQL: sqlerrm */

            /* RESOLVE: Standard Package call(not converted): 'dbms_utility.format_error_backtrace' not supported, manual conversion required */
            dbms_utility.format_error_backtrace;
            /* Saving modified package/session variable 'gv_error': */ 
            SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR' = :gv_error;

            /* ORIGSQL: raise; */
            RESIGNAL;

            /* ORIGSQL: rollback; */
            ROLLBACK;
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR') INTO gv_error FROM SYS.DUMMY ;
        /* end of package/session variables */

         

    SELECT
        refdatevalue
    INTO
        v_cutoffdate
    FROM
        sh_reference
    WHERE
        refid = 'CUTOVERDATE';

    /* ORIGSQL: Log('60') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('60');

    --delete from sh_agent_role;

    /* ORIGSQL: execute immediate 'truncate table sh_agent_role'; */
    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.SH_AGENT_ROLE' not found */

    /* ORIGSQL: truncate table sh_agent_role ; */
    EXECUTE IMMEDIATE 'TRUNCATE TABLE sh_agent_role';

    /* ORIGSQL: Log('60') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('60');

    /* ORIGSQL: Log('61') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('61');

    FOR c_agt AS dbmtk_cursor_2023
    DO
        IF :c_agt.dteEffective = :v_perDteEffective
        AND :v_perviousAgent = :c_agt.txtAgt
        AND :c_agt.Rown != :c_agt.Cnt
        THEN
            -- modified by nelson

            GOTO end_loop;  /* ORIGSQL: goto end_loop; */
        END IF;

        IF :c_agt.rown = 1
        THEN
            --first row
            /* ORIGSQL: insert / *+ append* / */
            /* ORIGSQL: insert into sh_agent_role values (c_agt.txtAgt, c_agt.oldTitle, c_agt.txtOldAgyLeader, c_agt.txtOldAgy, c_agt.txtOldDistrict, c_agt.old_class, To_Date('1/1/1900', 'mm/dd/yyyy'), c_agt.Dteeffective, 0)(...) */
            INSERT INTO sh_agent_role
            VALUES
                (
                        :c_agt.txtAgt /* --agentcode */,
                        :c_agt.oldTitle /* --agentRole */,
                        :c_agt.txtOldAgyLeader /* --agencyLeader */,
                        :c_agt.txtOldAgy /* --agencyCode */,
                        :c_agt.txtOldDistrict /* --disctrict */,
                        :c_agt.old_class /* --classcode */,
                        sapdbmtk.sp_f_dbmtk_format_string_to_datetime('1/1/1900', 'mm/dd/yyyy') /* --efftiveStartDate */,  /* ORIGSQL: To_Date('1/1/1900', 'mm/dd/yyyy') */
                        :c_agt.Dteeffective,
                        0
                );
        END IF;

        IF :c_agt.Rown = :c_agt.Cnt
        THEN
            IF :c_agt.rown > 1
            AND :v_perviousAgent = :c_agt.Txtagt
            THEN 
                /* ORIGSQL: insert into sh_agent_role values (c_agt.txtAgt, v_perAgentRole, v_perAgencyLeader, v_perAgencyCode, v_perDistrict, v_perClass, V_Perdteeffective, c_agt.Dteeffective, 0); */
                INSERT INTO sh_agent_role
                VALUES
                    (
                            :c_agt.txtAgt /* --agentcode */,
                            :v_perAgentRole /* --agentRole */,
                            :v_perAgencyLeader /* --agencyLeader */,
                            :v_perAgencyCode /* --agencyCode */,
                            :v_perDistrict /* --disctrict */,
                            :v_perClass /* --class */,
                            :v_perDteEffective /* --efftiveStartDate */,
                            :c_agt.Dteeffective /* --effectiveEndDate */,
                            0
                    );
            END IF;

            IF (:c_agt.rown > 1
            AND :v_perviousAgent = :c_agt.Txtagt)
            OR :c_agt.rown = 1
            THEN
                --last row
                /* ORIGSQL: insert / *+ append* / */
                /* ORIGSQL: insert into sh_agent_role values (c_agt.txtAgt, c_agt.newTitle, c_agt.txtNewAgyLeader, c_agt.txtNewAgy, c_agt.txtNewDistrict, c_agt.new_class, c_agt.Dteeffective, V_Cutoffdate + 1, 0); */
                INSERT INTO sh_agent_role
                VALUES
                    (
                            :c_agt.txtAgt /* --agentcode */,
                            :c_agt.newTitle /* --agentRole */,
                            :c_agt.txtNewAgyLeader /* --agencyLeader */,
                            :c_agt.txtNewAgy /* --agencyCode */,
                            :c_agt.txtNewDistrict /* --disctrict */,
                            :c_agt.new_class /* --classcode */,
                            :c_agt.Dteeffective /* --efftiveStartDate */,
                            TO_DATE(ADD_SECONDS(:v_cutoffdate,(86400*1))) /* --follow option1 */
                        ,  /* ORIGSQL: V_Cutoffdate + 1 */
                            0
                    );
            END IF;
        END IF;

        IF :c_agt.rown > 1
        AND :c_agt.rown < :c_agt.cnt
        THEN
            --current 
            /* ORIGSQL: insert into sh_agent_role values (c_agt.txtAgt, v_perAgentRole, v_perAgencyLeader, v_perAgencyCode, v_perDistrict, v_perClass, V_Perdteeffective, c_agt.Dteeffective, 0); */
            INSERT INTO sh_agent_role
            VALUES
                (
                        :c_agt.txtAgt /* --agentcode */,
                        :v_perAgentRole /* --agentRole */,
                        :v_perAgencyLeader /* --agencyLeader */,
                        :v_perAgencyCode /* --agencyCode */,
                        :v_perDistrict /* --disctrict */,
                        :v_perClass /* --class */,
                        :v_perDteEffective /* --efftiveStartDate */,
                        :c_agt.Dteeffective /* --effectiveEndDate */,
                        0
                );
        END IF;

        /*
        if c_agt.cnt=2 and c_agt.rown=2  then
        
          insert into sh_agent_role
          values (
              c_agt.txtAgt, --agentcode
              v_perAgentRole,--agentRole
              v_perAgencyLeader, --agencyLeader
              v_perAgencyCode, --agencyCode
              v_perDistrict, --disctrict
              v_perClass, --class
              v_perDteEffective, --efftiveStartDate
              c_agt.dteEffective --effectiveEndDate
          );
        
        end if;*/

LABEL end_loop: BEGIN/*dummy block for label*/END;  /* ORIGSQL: <<end_loop>> */

        v_perviousRown = :c_agt.rown;

        v_perviousAgent = :c_agt.txtAgt;

        v_perAgentRole = :c_agt.newTitle;

        v_perAgencyLeader = :c_agt.txtNewAgyLeader;

        v_perAgencyCode = :c_agt.txtNewAgy;

        v_perDistrict = :c_agt.txtNewDistrict;

        v_perClass = :c_agt.old_class;

        v_perDteEffective = :c_agt.dteEffective;

        /* ORIGSQL: NULL; */
        DBMTK_TMPVAR_INT_1 = 0;/* sapdbmtk: this is a dummy statement to avoid syntax errors, if possible, delete this line */
    END FOR;  /* ORIGSQL: end loop; */

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('61') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('61'); 

    /* ORIGSQL: delete from sh_agent_role d where d.effectivestartdate = d.effectiveenddate; */
    DELETE
    FROM
        sh_agent_role
        d
    WHERE
        d.effectivestartdate = d.effectiveenddate;
    -- added by nelson

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: exception when others then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__comConvertAgentRole') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__comInit' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__comInit''...' );
go

/* ORIGSQL: procedure comInit as v_periodStartDate date; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__comInit
()
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */
    DECLARE gv_plStartTime TIMESTAMP; /* package/session variable */
    DECLARE Gv_Pipelinerunseq BIGINT; /* package/session variable */
    DECLARE gv_isYearEnd BIGINT; /* package/session variable */
    DECLARE gv_calendarSeq BIGINT; /* package/session variable */
    DECLARE Gv_Periodname VARCHAR(100); /* package/session variable */
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE v_periodStartDate TIMESTAMP;  /* ORIGSQL: v_periodStartDate date; */
    DECLARE INVALID_PIPELINE CONDITION;  /* ORIGSQL: INVALID_PIPELINE EXCEPTION; */
    DECLARE INVALID_PERIOD CONDITION;  /* ORIGSQL: INVALID_PERIOD EXCEPTION; */
    DECLARE INVALID_FIXEDVALUE CONDITION;  /* ORIGSQL: Invalid_Fixedvalue Exception; */
    DECLARE INVALID_PIPELINERUNSEQ CONDITION;  /* ORIGSQL: Invalid_PipelineRunSeq exception; */

    DECLARE EXIT HANDLER FOR INVALID_PIPELINE
        /* ORIGSQL: when INVALID_PIPELINE then */
        BEGIN
            /* ORIGSQL: comDebugger('Initializtion', 'Due to some gloable pipeline information is not found, the stagehook will abort') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('Initializtion', 'Due to some gloable pipeline information is not found, the stagehook will abort');

            /* ORIGSQL: raise_application_error(-20000, 'Due to some global pipeline information is not found, the stagehook will abort') */
            -- sapdbmtk: mapped error code -20000 => 10000: (ABS(-20000)%10000)+10000
            SIGNAL SQL_ERROR_CODE 10000 SET MESSAGE_TEXT =
            'Due to some global pipeline information is not found, the stagehook will abort';
        END;



    DECLARE EXIT HANDLER FOR INVALID_PIPELINERUNSEQ
        /* ORIGSQL: When Invalid_Pipelinerunseq Then */
        BEGIN
            /* ORIGSQL: comDebugger('Initializtion', 'Due to some gloable pipeline run seq is not zero, the stagehook will abort') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('Initializtion', 'Due to some gloable pipeline run seq is not zero, the stagehook will abort');

            /* ORIGSQL: raise_application_error(-20000, 'Due to some global pipeline run seq is not zero, the stagehook will abort') */
            -- sapdbmtk: mapped error code -20000 => 10000: (ABS(-20000)%10000)+10000
            SIGNAL SQL_ERROR_CODE 10000 SET MESSAGE_TEXT =
            'Due to some global pipeline run seq is not zero, the stagehook will abort';
        END;



    DECLARE EXIT HANDLER FOR INVALID_PERIOD
        /* ORIGSQL: when INVALID_PERIOD then */
        BEGIN
            /* ORIGSQL: comDebugger('Initializtion', 'Due to some gloable period information is not found, the stagehook will abort') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('Initializtion', 'Due to some gloable period information is not found, the stagehook will abort');

            /* ORIGSQL: raise_application_error(-20000, 'Due to some global period information is not found, the stagehook will abort') */
            -- sapdbmtk: mapped error code -20000 => 10000: (ABS(-20000)%10000)+10000
            SIGNAL SQL_ERROR_CODE 10000 SET MESSAGE_TEXT =
            'Due to some global period information is not found, the stagehook will abort';
        END;



    DECLARE EXIT HANDLER FOR INVALID_FIXEDVALUE
        /* ORIGSQL: when INVALID_FIXEDVALUE then */
        BEGIN
            /* ORIGSQL: comDebugger('Initializtion', 'Due to some gloable fixed value is not found, the stagehook will abort') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('Initializtion', 'Due to some gloable fixed value is not found, the stagehook will abort');

            /* ORIGSQL: raise_application_error(-20000, 'Due to some global fixed value is not found, the stagehook will abort') */
            -- sapdbmtk: mapped error code -20000 => 10000: (ABS(-20000)%10000)+10000
            SIGNAL SQL_ERROR_CODE 10000 SET MESSAGE_TEXT =
            'Due to some global fixed value is not found, the stagehook will abort';
        END;



    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            /* ORIGSQL: raise_application_error(-20000, 'Initializtion procedure has failed: ' || sqlerrm) */
            -- sapdbmtk: mapped error code -20000 => 10000: (ABS(-20000)%10000)+10000
            SIGNAL SQL_ERROR_CODE 10000 SET MESSAGE_TEXT =
            'Initializtion procedure has failed: ' ||
            ::SQL_ERROR_MESSAGE;  /* ORIGSQL: sqlerrm */
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
        SELECT TO_TIMESTAMP(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PLSTARTTIME'), 'yyyy Mon dd hh24:mi:ss:ff3') INTO gv_plStartTime FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PIPELINERUNSEQ') AS BIGINT) INTO Gv_Pipelinerunseq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ISYEAREND') AS BIGINT) INTO gv_isYearEnd FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CALENDARSEQ') AS BIGINT) INTO gv_calendarSeq FROM SYS.DUMMY ;
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODNAME') INTO Gv_Periodname FROM SYS.DUMMY ;
        /* end of package/session variables */



    --dbms_output.put_line('xxxxxx');
    BEGIN 
        DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 1299 /*1299=ERR_SQLSCRIPT_NO_DATA_FOUND*/
            /* ORIGSQL: WHEN NO_DATA_FOUND THEN */
            BEGIN
                --     gv_PeriodSeq := 2533274790395933;
                --     gv_processingUnitSeq := 38280596832649218;
                --     gv_plStartTime := sysdate;
                --     Gv_Pipelinerunseq    := 1;
                /* ORIGSQL: raise INVALID_PIPELINE; */
                SIGNAL INVALID_PIPELINE;
            END;



        /* ORIGSQL: Log('65') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('65'); 

        SELECT
            MAX(periodseq),
            MAX(processingUnitSeq),
            MAX(starttime),
            MAX(Pipelinerunseq)
        INTO
            Gv_Periodseq,
            Gv_Processingunitseq,
            gv_plStartTime,
            Gv_Pipelinerunseq
        FROM
            cs_pipelinerun
        WHERE
            tenantid = 'AIAS'
            AND Pipelinerunseq  
            IN
            (
                SELECT   /* ORIGSQL: (Select MAX(Pipelinerunseq) From Cs_Pipelinerun Where tenantid='AIAS' and Periodseq IS NOT NULL) */
                    MAX(Pipelinerunseq)
                FROM
                    Cs_Pipelinerun
                WHERE
                    tenantid = 'AIAS'
                    AND Periodseq IS NOT NULL
                    --and periodseq=2533274790398965
            )
            AND COMMAND = 'PipelineRun';

        /* ORIGSQL: Log('65') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('65');

        IF :Gv_Pipelinerunseq = 0
        THEN
            /* ORIGSQL: raise Invalid_PipelineRunSeq; */
            SIGNAL INVALID_PIPELINERUNSEQ;
        END IF;

        --     gv_PeriodSeq := 2533274790395933;
        --     gv_processingUnitSeq := 38280596832649218;
        --     gv_plStartTime := sysdate;
        --     Gv_Pipelinerunseq    := 1;
        /* ORIGSQL: EXCEPTION WHEN NO_DATA_FOUND THEN */
    END;

    /* ORIGSQL: Log('StageHook start for period [' || Gv_Periodseq || ']' || 'processingunitseq [' || Gv_Processingunitseq || '] plStartDate[' || Gv_Plstarttime || '] gv_pipelineRunSeq[' || Gv_Pipelinerunseq || '] gv(...) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('StageHook start for period ['|| IFNULL(TO_VARCHAR(:Gv_Periodseq),'') || ']'|| 'processingunitseq ['|| IFNULL(TO_VARCHAR(:Gv_Processingunitseq),'') || '] plStartDate['|| IFNULL(TO_VARCHAR(:gv_plStartTime),'') || '] gv_pipelineRunSeq['|| IFNULL(TO_VARCHAR(:Gv_Pipelinerunseq),'') || '] gv_isYearEnd['|| IFNULL(TO_VARCHAR(:gv_isYearEnd),'') || '] gv_calendarSeq['|| IFNULL(TO_VARCHAR(:gv_calendarSeq),'') || ']');

    /* ORIGSQL: Log('66') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('66');
    BEGIN 
        DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 1299 /*1299=ERR_SQLSCRIPT_NO_DATA_FOUND*/
            /* ORIGSQL: WHEN NO_DATA_FOUND THEN */
            BEGIN
                --    Gv_Periodname := 'May 2015';
                --    V_Periodstartdate := sysdate;
                --    gv_calendarSeq := 2251799813685249;
                /* ORIGSQL: raise INVALID_PERIOD; */
                SIGNAL INVALID_PERIOD;
            END;

             
        SELECT
            name,
            startdate,
            calendarSeq
        INTO
            Gv_Periodname,
            v_periodStartDate,
            gv_calendarSeq /* --add the calendarseq on nov/11/2014 */
        FROM
            cs_period
        WHERE
            Periodseq = :Gv_Periodseq
            AND REMOVEDATE = :cdt_EndOfTime;

        /* ORIGSQL: EXCEPTION WHEN NO_DATA_FOUND THEN */
    END;

    /* ORIGSQL: Log('67') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('67');

    /* ORIGSQL: Log('68') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('68');
    BEGIN 
        DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 1299 /*1299=ERR_SQLSCRIPT_NO_DATA_FOUND*/
            /* ORIGSQL: WHEN NO_DATA_FOUND THEN */
            BEGIN
                --gv_isYearEnd := 1;
                /* ORIGSQL: Raise Invalid_Fixedvalue; */
                SIGNAL INVALID_FIXEDVALUE;
            END;

             

        SELECT
            IFNULL(MAX(value), 0)  /* ORIGSQL: nvl(max(value), 0) */
        INTO
            gv_isYearEnd
        FROM
            cs_fixedValue
        WHERE
            name = 'FV_Mo_End'
            AND Removedate = cdt_EndOfTime
            AND Effectivestartdate <= v_periodStartDate
            AND effectiveEndDate > v_periodStartDate
            AND  
            /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_PERIODTYPE' not found */
            EXISTS
            (
                SELECT   /* ORIGSQL: (select 1 from cs_period p, cs_period py, Cs_Periodtype Pt where py.periodtypeseq = pt.periodtypeseq and py.enddate = p.enddate And P.Periodseq = Gv_Periodseq and pt.name = 'year' And Py.Calendarseq =(...) */
                    1
                FROM
                    cs_period p,
                    cs_period py,
                    Cs_Periodtype Pt
                WHERE
                    py.periodtypeseq = pt.periodtypeseq
                    AND py.enddate = p.enddate
                    AND P.Periodseq = :Gv_Periodseq
                    AND pt.name = 'year'
                    AND Py.Calendarseq = :gv_calendarSeq
                    AND py.removedate = :cdt_EndOfTime
                    AND Pt.Removedate = :cdt_EndOfTime
                    AND p.removedate = :cdt_EndOfTime
            );

        /* ORIGSQL: Log('68 gv_isYearEnd'||gv_isYearEnd) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('68 gv_isYearEnd'||IFNULL(TO_VARCHAR(:gv_isYearEnd),''));

        /* ORIGSQL: EXCEPTION WHEN NO_DATA_FOUND THEN */
    END;

    /* ORIGSQL: Log('68') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('68');

    /* Comdebugger('initialized','StageHook start for period ['||Gv_Periodseq||']'||'processingunitseq ['||Gv_Processingunitseq||
      '] plStartDate['||Gv_Plstarttime||'] gv_pipelineRunSeq['||Gv_Pipelinerunseq||'] gv_isYearEnd['||Gv_Isyearend||'] gv_calendarSeq['||Gv_Calendarseq||']');
    */

    -- gv_hryc:=comGetEventtypeSeq('H_RYC');

    /* ORIGSQL: exception when INVALID_PIPELINE then */
END;

--function comGetCrossoverAgy (i_oldAgy in varchar2, i_policyIssueDate in date) return string --comment by nelson
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__comInit') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating function 'DBMTK_USER_NAME.PK_STAGE_HOOK__comGetCrossoverAgy' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating function ''DBMTK_USER_NAME.PK_STAGE_HOOK__comGetCrossoverAgy''...' );
go

/* ORIGSQL: function comGetCrossoverAgy (i_comp in varchar2,I_wAgyLdr in varchar2, i_policyIssueDate in date) return string is v_oldDM varchar2(30); */
CREATE OR REPLACE FUNCTION DBMTK_USER_NAME.PK_STAGE_HOOK__comGetCrossoverAgy
(
    IN i_comp VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                              /* ORIGSQL: i_comp IN varchar2 */
    IN I_wAgyLdr VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                 /* ORIGSQL: I_wAgyLdr IN varchar2 */
    IN i_policyIssueDate TIMESTAMP     /* ORIGSQL: i_policyIssueDate IN date */
)
RETURNS dbmtk_function_result VARCHAR(255)   /* ORIGSQL: return string */
--add by nelson
/* RESOLVE: Manual edits required: VARCHAR2 function value(no length): user-configured length=255; adjust as needed */
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
AS
BEGIN
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */
    DECLARE gv_CrossoverEffectiveDate TIMESTAMP; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */

    DECLARE v_oldDM VARCHAR(30);  /* ORIGSQL: v_oldDM varchar2(30); */
    DECLARE v_countsetup BIGINT;  /* ORIGSQL: v_countsetup number(10); */
    DECLARE v_odm VARCHAR(30);  /* ORIGSQL: v_odm varchar2(30); */
    DECLARE v_effdate TIMESTAMP;  /* ORIGSQL: v_effdate date; */

    DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 1299 /*1299=ERR_SQLSCRIPT_NO_DATA_FOUND*/
        /* ORIGSQL: when no_data_found then */
        BEGIN
            --Log('70'); 

            dbmtk_function_result = NULL;
            /* sapdbmtk: Closing RETURN in exception handler commented out, not supported in HANA */
            --RETURN;
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this function */
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
        SELECT TO_TIMESTAMP(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CROSSOVEREFFECTIVEDATE'), 'yyyy Mon dd hh24:mi:ss:ff3') INTO gv_CrossoverEffectiveDate FROM SYS.DUMMY ;
        /* end of package/session variables */

        --Log('70');

        --add by nelson start

        IF :i_comp = 'PI' 
        THEN
            ---add version 5 (If Payee only include one setup , it will assign to old DM)
            SELECT
                COUNT(1),
                MAX(TXTOLDDMCODE),
                MAX(Dteeffectivedate)
            INTO
                v_countsetup,
                v_odm,
                v_effdate  
            FROM
                (
                    SELECT   /* ORIGSQL: (select MAX(ST.TXTOLDDMCODE) TXTOLDDMCODE, ST.Dteeffectivedate, ST.Txtagt from In_Pi_Aor_Setup ST, Cs_Period PT where 'SGT' || to_number(ST.Txtagt) = I_wAgyLdr and I_Policyissuedate <= ST.Dteeffective(...) */
                        MAX(ST.TXTOLDDMCODE) AS TXTOLDDMCODE,
                        ST.Dteeffectivedate,
                        ST.Txtagt
                    FROM
                        In_Pi_Aor_Setup ST,
                        Cs_Period PT
                    WHERE
                        'SGT' || IFNULL(TO_VARCHAR(TO_DECIMAL(ST.Txtagt,38,18)),'') = :I_wAgyLdr  /* ORIGSQL: to_number(ST.Txtagt) */
                        AND :i_policyIssueDate <= ST.Dteeffectivedate
                        AND ST.Dtecycle = PT.Enddate - 1
                        AND PT.Periodseq = :Gv_Periodseq
                        AND ST.Txttype IN ('C')
                        AND ST.Decstatus = 0
                    GROUP BY
                        ST.Dteeffectivedate, ST.Txtagt
                ) AS dbmtk_corrname_2322
            GROUP BY
                Txtagt;

            IF :v_countsetup = 1
            THEN
                v_oldDM = :v_odm;

                gv_CrossoverEffectiveDate = :v_effdate;
                /* Saving modified package/session variable 'gv_CrossoverEffectiveDate': */ 
                SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CROSSOVEREFFECTIVEDATE' = TO_VARCHAR(:gv_CrossoverEffectiveDate, 'yyyy Mon dd hh24:mi:ss:ff3');
            ELSE 
                /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.IN_PI_AOR_SETUP' not found */
                SELECT
                    ST.Txtolddistrict,
                    ST.Dteeffectivedate
                INTO
                    v_oldDM,
                    gv_CrossoverEffectiveDate
                FROM
                    In_Pi_Aor_Setup ST,
                    Cs_Period PT
                WHERE
                    'SGT'||IFNULL(TO_VARCHAR(TO_DECIMAL(ST.Txtagt,38,18)),'') = :I_wAgyLdr  /* ORIGSQL: to_number(ST.Txtagt) */
                    AND ST.Dteeffectivedate   
                    =
                    (
                        SELECT   /* ORIGSQL: (Select MIN(S.Dteeffectivedate) From In_Pi_Aor_Setup S,Cs_Period P Where 'SGT'||to_number(S.Txtagt) =I_wAgyLdr And I_Policyissuedate <= S.Dteeffectivedate And S.Dtecycle = P.Enddate - 1 And P.Periodse(...) */
                            MIN(S.Dteeffectivedate) 
                        FROM
                            In_Pi_Aor_Setup S,
                            Cs_Period P
                        WHERE
                            'SGT'||IFNULL(TO_VARCHAR(TO_DECIMAL(S.Txtagt,38,18)),'') = :I_wAgyLdr  /* ORIGSQL: to_number(S.Txtagt) */
                            AND :i_policyIssueDate <= S.Dteeffectivedate
                            AND S.Dtecycle = P.Enddate - 1
                            AND P.Periodseq = :Gv_Periodseq
                            AND S.Txttype IN ('C')
                            AND S.Decstatus = 0
                    )
                    AND ST.Dtecycle = PT.Enddate -1
                    AND PT.Periodseq = :Gv_Periodseq
                    AND :i_policyIssueDate  
                    >=
                    (
                        SELECT   /* ORIGSQL: (select MAX(g.effectiveenddate) from sh_agent_role g where g.agentcode = to_number(ST.Txtagt) and g.effectiveenddate < ST.dteeffectivedate) */
                            MAX(g.effectiveenddate)
                        FROM
                            sh_agent_role g
                        WHERE
                            g.agentcode = TO_DECIMAL(ST.Txtagt,38,18)  /* ORIGSQL: to_number(ST.Txtagt) */
                            AND g.effectiveenddate < ST.dteeffectivedate
                    );
            END IF;
            ELSEIF :i_comp = 'AOR'   /* ORIGSQL: elsif i_comp = 'AOR' then */
            THEN
                ---add version 5 (If Payee only include one setup , it will assign to old DM)
                SELECT
                    COUNT(1),
                    MAX(Txtolddistrict),
                    MAX(Dteeffectivedate)
                INTO
                    v_countsetup,
                    v_odm,
                    v_effdate  
                FROM
                    (
                        SELECT   /* ORIGSQL: (select MAX(ST.Txtolddistrict) Txtolddistrict, ST.Dteeffectivedate, ST.Txtagt from In_Pi_Aor_Setup ST, Cs_Period PT where 'SGT'|| to_number(ST.Txtagt) = I_wAgyLdr and I_Policyissuedate <= ST.Dteeffect(...) */
                            MAX(ST.Txtolddistrict) AS Txtolddistrict,
                            ST.Dteeffectivedate,
                            ST.Txtagt
                        FROM
                            In_Pi_Aor_Setup ST,
                            Cs_Period PT
                        WHERE
                            'SGT'|| IFNULL(TO_VARCHAR(TO_DECIMAL(ST.Txtagt,38,18)),'') = :I_wAgyLdr  /* ORIGSQL: to_number(ST.Txtagt) */
                            AND :i_policyIssueDate <= ST.Dteeffectivedate
                            AND ST.Dtecycle = PT.Enddate - 1
                            AND PT.Periodseq = :Gv_Periodseq
                            AND ST.Txttype IN ('C','D')
                            AND ST.Decstatus = 0
                        GROUP BY
                            ST.Dteeffectivedate, ST.Txtagt
                    ) AS dbmtk_corrname_2331
                GROUP BY
                    Txtagt;

                IF :v_countsetup = 1
                THEN
                    v_oldDM = :v_odm;

                    gv_CrossoverEffectiveDate = :v_effdate;
                    /* Saving modified package/session variable 'gv_CrossoverEffectiveDate': */ 
                    SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CROSSOVEREFFECTIVEDATE' = TO_VARCHAR(:gv_CrossoverEffectiveDate, 'yyyy Mon dd hh24:mi:ss:ff3');
                ELSE   
                    SELECT
                        ST.Txtolddistrict,
                        ST.Dteeffectivedate
                    INTO
                        v_oldDM,
                        gv_CrossoverEffectiveDate
                    FROM
                        In_Pi_Aor_Setup ST,
                        Cs_Period PT
                    WHERE
                        PT.tenantid = 'AIAS'
                        AND 'SGT'||IFNULL(TO_VARCHAR(TO_DECIMAL(ST.Txtagt,38,18)),'') = :I_wAgyLdr  /* ORIGSQL: to_number(ST.Txtagt) */
                        AND ST.Dteeffectivedate   
                        =
                        (
                            SELECT   /* ORIGSQL: (Select MIN(S.Dteeffectivedate) From In_Pi_Aor_Setup S,Cs_Period P Where 'SGT'||to_number(S.Txtagt) =I_wAgyLdr And I_Policyissuedate <= S.Dteeffectivedate And S.Dtecycle = p.enddate-1 And P.Periodseq=(...) */
                                MIN(S.Dteeffectivedate) 
                            FROM
                                In_Pi_Aor_Setup S,
                                Cs_Period P
                            WHERE
                                'SGT'||IFNULL(TO_VARCHAR(TO_DECIMAL(S.Txtagt,38,18)),'') = :I_wAgyLdr  /* ORIGSQL: to_number(S.Txtagt) */
                                AND :i_policyIssueDate <= S.Dteeffectivedate
                                AND S.Dtecycle = p.enddate-1
                                AND P.Periodseq = :Gv_Periodseq
                                AND S.Txttype IN ('C','D')
                                AND S.Decstatus = 0
                        )
                        AND ST.Dtecycle = PT.Enddate - 1
                        AND PT.Periodseq = :Gv_Periodseq
                        AND :i_policyIssueDate  
                        >=
                        (
                            SELECT   /* ORIGSQL: (select MAX(g.effectiveenddate) from sh_agent_role g where g.agentcode = to_number(ST.Txtagt) and g.effectiveenddate < ST.dteeffectivedate) */
                                MAX(g.effectiveenddate)
                            FROM
                                sh_agent_role g
                            WHERE
                                g.agentcode = TO_DECIMAL(ST.Txtagt,38,18)  /* ORIGSQL: to_number(ST.Txtagt) */
                                AND g.effectiveenddate < ST.dteeffectivedate
                        );
                END IF;
            END IF;
            --Log('70'); 

            dbmtk_function_result = :v_oldDM;
            RETURN;

            --add by nelson end

            /* ORIGSQL: exception when no_data_found then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('function', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__comGetCrossoverAgy') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__Comcleanassignment' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__Comcleanassignment''...' );
go

/* ORIGSQL: Procedure Comcleanassignment(I_Periodseq In Int) as V_Periodstartdate Date; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__Comcleanassignment
(
    IN I_Periodseq BIGINT     /* ORIGSQL: I_Periodseq IN Int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE gv_calendarSeq BIGINT; /* package/session variable */
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */
    DECLARE gv_hryc BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE V_Periodstartdate TIMESTAMP;  /* ORIGSQL: V_Periodstartdate Date; */
    DECLARE v_periodenddate TIMESTAMP;  /* ORIGSQL: v_periodenddate date; */

    /* initialize session variables, if not yet done */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
    /* retrieve the package/session variables referenced in this procedure */
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CALENDARSEQ') AS BIGINT) INTO gv_calendarSeq FROM SYS.DUMMY ;
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_HRYC') AS BIGINT) INTO gv_hryc FROM SYS.DUMMY ;
    /* end of package/session variables */ 

    SELECT
        Startdate,
        Enddate
    INTO
        V_Periodstartdate,
        v_periodenddate
    FROM
        Cs_Period
    WHERE
        Periodseq = :I_Periodseq
        AND calendarseq = :gv_calendarSeq
        AND removedate = :cdt_EndOfTime;

    /* ORIGSQL: Log('71') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('71');

    /* ORIGSQL: update / *+ full(ta) * / */
    /* ORIGSQL: update Cs_Transactionassignment Ta SET setnumber=genericnumber6 where genericnumber6 IS NOT NULL and genericnumber6<>setnumber and tenantid='AIAS' and processingUnitseq = gv_ProcessingUnitSeq and Comp(...) */
    UPDATE Cs_Transactionassignment Ta
        SET
        /* ORIGSQL: setnumber = */
        setnumber = genericnumber6
    WHERE
        genericnumber6 IS NOT NULL
        AND genericnumber6 <> setnumber
        AND tenantid = 'AIAS'
        AND processingUnitseq = :Gv_Processingunitseq
        AND Compensationdate >= :V_Periodstartdate
        AND Compensationdate < :v_periodenddate
        /* --version 13 add by sammi */
        AND NOT  
        EXISTS
        (
            SELECT   /* ORIGSQL: (select 1 from cs_salestransaction st where st.tenantid='AIAS' and st.processingUnitseq = gv_ProcessingUnitSeq and st.Compensationdate >= V_Periodstartdate and st.Compensationdate < V_Periodenddate an(...) */
                1
            FROM
                cs_salestransaction st
            WHERE
                st.tenantid = 'AIAS'
                AND st.processingUnitseq = :Gv_Processingunitseq
                AND st.Compensationdate >= :V_Periodstartdate
                AND st.Compensationdate < :v_periodenddate
                AND st.EVENTTYPESEQ  
                IN
                (
                    SELECT   /* ORIGSQL: (select DATATYPESEQ from cs_eventtype where eventtypeid in ('FYC_INTRODUCER','OFYC_INTRODUCER') and removedate=cdt_EndOfTime) */
                        DATATYPESEQ
                    FROM
                        cs_eventtype
                    WHERE
                        eventtypeid IN ('FYC_INTRODUCER','OFYC_INTRODUCER')
                        AND removedate = :cdt_EndOfTime
                )
                AND st.salestransactionseq = ta.salestransactionseq
        );/* --version 13 end */

    /* ORIGSQL: Log('71 Update Setnumber '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('71 Update Setnumber '||::ROWCOUNT);  

    /* ORIGSQL: Delete From Cs_Transactionassignment Ta Where tenantid='AIAS' and processingUnitseq=Gv_Processingunitseq and Compensationdate >= V_Periodstartdate And Compensationdate < V_Periodenddate And Setnumber (...) */
    DELETE
    FROM
        Cs_Transactionassignment
        Ta
    WHERE
        tenantid = 'AIAS'
        AND processingUnitseq = :Gv_Processingunitseq
        AND Compensationdate >= :V_Periodstartdate
        AND Compensationdate < :v_periodenddate
        AND Setnumber > 2
        AND Setnumber NOT IN (41, 51)
        AND (Genericattribute4 IS NOT NULL)
        AND 
        EXISTS
        (
            SELECT   /* ORIGSQL: (Select 1 From Cs_Salestransaction St Where St.tenantid='AIAS' and St.Processingunitseq = Gv_Processingunitseq And St.Salestransactionseq = Ta.Salestransactionseq And St.Compensationdate >= V_Periodst(...) */
                1
            FROM
                Cs_Salestransaction St
            WHERE
                St.tenantid = 'AIAS'
                AND St.Processingunitseq = :Gv_Processingunitseq
                AND St.Salestransactionseq = Ta.Salestransactionseq
                AND St.Compensationdate >= :V_Periodstartdate
                AND st.Compensationdate < :v_periodenddate
        )
        AND NOT  
        EXISTS
        (
            SELECT   /* ORIGSQL: (Select 1 From Cs_Salestransaction Where tenantid='AIAS' and Salestransactionseq = Ta.Salestransactionseq And (Eventtypeseq = gv_hryc OR EVENTTYPESEQ IN (SELECT DATATYPESEQ FROM cs_eventtype where eve(...) */
                1
            FROM
                Cs_Salestransaction
            WHERE
                tenantid = 'AIAS'
                AND Salestransactionseq = Ta.Salestransactionseq
                --version 13 add by sammi
                --And Eventtypeseq = gv_hryc
                AND (Eventtypeseq = :gv_hryc
                    OR EVENTTYPESEQ  
                    IN
                    (
                        SELECT   /* ORIGSQL: (select DATATYPESEQ from cs_eventtype where eventtypeid in ('FYC_INTRODUCER','OFYC_INTRODUCER','FYC_TP','RYC_TP','FYC_TPGI','RYC_TPGI','FYP_TPGI','RYP_TPGI') and removedate=cdt_EndOfTime) */
                            DATATYPESEQ
                        FROM
                            cs_eventtype
                        WHERE
                            eventtypeid IN ('FYC_INTRODUCER','OFYC_INTRODUCER'
                                ,'FYC_TP','RYC_TP' --version 18
                                ,'FYC_TPGI','RYC_TPGI','FYP_TPGI','RYP_TPGI' -- version 22 For MAS Section86 project
                            )
                            AND removedate = :cdt_EndOfTime
                    )
                )
                --version 13 end
                AND processingUnitseq = :Gv_Processingunitseq
                AND Compensationdate >= :V_Periodstartdate
                AND Compensationdate < :v_periodenddate
        );

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('71 Deletion '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('71 Deletion '||::ROWCOUNT);  
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__Comcleanassignment') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__Comtransferpiaor_debug' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__Comtransferpiaor_debug''...' );
go

/* ORIGSQL: Procedure Comtransferpiaor_debug(I_R_Agydisttrxn In R_Agydisttrxn) as v_policyIssueDate date; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__Comtransferpiaor_debug
(
    IN I_R_Agydisttrxn_FIELD_Salestransactionseq BIGINT,     /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_SALESORDERSEQ BIGINT,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Wagency VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_wAgencyLeader VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Wagyldrtitle VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_LdrCurRole VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Wagyldrdistrict VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_CurDistrict VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Policyissuedate TIMESTAMP,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Compensationdate TIMESTAMP,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Wagtclass VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Commissionagy VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Runningtype VARCHAR(100),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Eventtypeid VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Productname VARCHAR(100),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Businessunitmap VARCHAR(100),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Orphanpolicy VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Managerseq BIGINT,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Agyspinoffindicator VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Agyspinoffflag BIGINT,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Versioningdate TIMESTAMP,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Periodseq BIGINT,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Spinstartdate TIMESTAMP,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Spindaterange DECIMAL(38,10),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Txnclasscode VARCHAR(10),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Spinenddate TIMESTAMP,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_actualOrphanPolicy VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_wAgyLdrCde VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_setup VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_txnCode VARCHAR(30)   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */
    DECLARE Gv_Setnumberpi BIGINT; /* package/session variable */
    DECLARE gv_setnumberaor BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE v_policyIssueDate TIMESTAMP;  /* ORIGSQL: v_policyIssueDate date; */
    DECLARE V_Compensationdate TIMESTAMP;  /* ORIGSQL: V_Compensationdate Date; */
    DECLARE v_maxSetNumber BIGINT;  /* ORIGSQL: v_maxSetNumber int; */

    --removed
    DECLARE v_rule VARCHAR(100);  /* ORIGSQL: v_rule varchar2(100); */
    DECLARE v_writingAgyLdr VARCHAR(30);  /* ORIGSQL: v_writingAgyLdr varchar2(30); */
    DECLARE v_wAgency VARCHAR(30);  /* ORIGSQL: v_wAgency varchar2(30); */
    DECLARE v_wAgencyLeader VARCHAR(30);  /* ORIGSQL: v_wAgencyLeader varchar2(30); */
    DECLARE v_wAgyLdrTitle VARCHAR(30);  /* ORIGSQL: v_wAgyLdrTitle varchar2(30); */
    DECLARE v_wAgyLdrDistrict VARCHAR(30);  /* ORIGSQL: v_wAgyLdrDistrict varchar2(30); */
    DECLARE v_Wagtclass VARCHAR(10);  /* ORIGSQL: v_Wagtclass varchar2(10); */
    DECLARE vNewWritingAgy VARCHAR(10);  /* ORIGSQL: vNewWritingAgy varchar2(10); */
    DECLARE vAorNewWritingAgy VARCHAR(10);  /* ORIGSQL: vAorNewWritingAgy varchar2(10); */
    DECLARE v_AorRule VARCHAR(100);  /* ORIGSQL: v_AorRule varchar2(100); */
    DECLARE V_Aorwagyldr VARCHAR(30);  /* ORIGSQL: V_Aorwagyldr Varchar2(30); */
    DECLARE v_commissionAgy VARCHAR(30);  /* ORIGSQL: v_commissionAgy varchar2(30); */
    DECLARE v_CurDistrict VARCHAR(30);  /* ORIGSQL: v_CurDistrict Varchar2(30); */

    --add by nelson
    DECLARE v_LdrCurRole VARCHAR(30);  /* ORIGSQL: v_LdrCurRole Varchar2(30); */

    --add by nelson
    DECLARE v_wAgyLdrCde VARCHAR(30);  /* ORIGSQL: v_wAgyLdrCde Varchar2(30); */

    --add by nelson
    DECLARE v_setup VARCHAR(30);  /* ORIGSQL: v_setup Varchar2(30); */

    --add by nelson
    DECLARE v_wAgyLdrCurClass VARCHAR(30);  /* ORIGSQL: v_wAgyLdrCurClass varchar2(30); */
    DECLARE V_Crossoverflag BIGINT = 0;  /* ORIGSQL: V_Crossoverflag Int:=0; */
    DECLARE v_ConstantCrossoverDate TIMESTAMP = sapdbmtk.sp_f_dbmtk_format_string_to_datetime('1/1/2005','mm/dd/yyyy');  /* ORIGSQL: v_ConstantCrossoverDate date:=to_date('1/1/2005','mm/dd/yyyy') ; */

    DECLARE V_Manageragy VARCHAR(30);  /* ORIGSQL: V_Manageragy Varchar2(30); */
    DECLARE v_RunningType VARCHAR(255);  /* ORIGSQL: v_RunningType varchar2(255); */
    DECLARE v_OrphanPolicy VARCHAR(30);  /* ORIGSQL: v_OrphanPolicy varchar2(30); */
    DECLARE INVALID_MANAGER CONDITION;  /* ORIGSQL: Invalid_Manager exception; */

    DECLARE EXIT HANDLER FOR INVALID_MANAGER
        /* ORIGSQL: When Invalid_Manager Then */
        BEGIN
            /* ORIGSQL: Comdebugger('ComTransferPIAOR','Stagehook is not able get any spin off manager'||I_R_Agydisttrxn.salestransactionSeq) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('ComTransferPIAOR', 'Stagehook is not able get any spin off manager'||IFNULL(TO_VARCHAR(:I_R_Agydisttrxn_FIELD_Salestransactionseq),''));
        END;



    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            /* ORIGSQL: comDebugger('ComTransferPIAOR','Error'||sqlerrm) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('ComTransferPIAOR', 'Error'||::SQL_ERROR_MESSAGE 
            );  /* ORIGSQL: sqlerrm */
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERPI') AS BIGINT) INTO Gv_Setnumberpi FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERAOR') AS BIGINT) INTO gv_setnumberaor FROM SYS.DUMMY ;
        /* end of package/session variables */



    /*
    begin
      select nvl(max(setNumber),0)
      into v_maxSetNumber
      from cs_transactionAssignment
      where I_R_Agydisttrxn.salestransactionSeq=salestransactionSeq
     And Genericattribute4 IS NULL;
    
    exception when no_data_found then
      v_maxSetNumber:=0;
    end;
    
    */

    --DBMS_OUTPUT.put_line(c_txn.salestransactionSeq||'   start c_txn  issue date  '||to_char(v_policyIssueDate,'mm/dd/yyyy'));
    --DBMS_OUTPUT.put_line(v_policyIssueDate||' ---- '||v_cutoverdate);

    v_wAgency = :I_R_Agydisttrxn_FIELD_Wagency;

    v_wAgencyLeader = :I_R_Agydisttrxn_FIELD_wAgencyLeader;

    v_wAgyLdrTitle = :I_R_Agydisttrxn_FIELD_Wagyldrtitle;

    v_wAgyLdrDistrict = :I_R_Agydisttrxn_FIELD_Wagyldrdistrict;

    v_Wagtclass = :I_R_Agydisttrxn_FIELD_Wagtclass;

    v_policyIssueDate = :I_R_Agydisttrxn_FIELD_Policyissuedate;

    v_commissionAgy = :I_R_Agydisttrxn_FIELD_Commissionagy;

    v_RunningType = :I_R_Agydisttrxn_FIELD_Runningtype;

    v_OrphanPolicy = :I_R_Agydisttrxn_FIELD_Orphanpolicy;

    v_CurDistrict = :I_R_Agydisttrxn_FIELD_CurDistrict;
    --add by nelson

    v_LdrCurRole = :I_R_Agydisttrxn_FIELD_LdrCurRole;
    --add by nelson

    v_wAgyLdrCde = :I_R_Agydisttrxn_FIELD_wAgyLdrCde;
    --add by nelson

    v_setup = :I_R_Agydisttrxn_FIELD_setup;
    --add by nelson

    --comDebugger('PIAOR DEBUGGER','WAGENCY['||v_wAgency||']||');

    /* ORIGSQL: Log('Comtransferpiaor wAgency '|| I_R_Agydisttrxn.wAgency) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor wAgency '|| IFNULL(:I_R_Agydisttrxn_FIELD_Wagency,''));

    /* ORIGSQL: Log('Comtransferpiaor Eventtypeid '|| I_R_Agydisttrxn.Eventtypeid) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor Eventtypeid '|| IFNULL(:I_R_Agydisttrxn_FIELD_Eventtypeid,''));

    /* ORIGSQL: Log('Comtransferpiaor OrphanPolicy '|| I_R_Agydisttrxn.OrphanPolicy) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor OrphanPolicy '|| IFNULL(:I_R_Agydisttrxn_FIELD_Orphanpolicy,''));

    /* ORIGSQL: Log('Comtransferpiaor productname '|| I_R_Agydisttrxn.productname) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor productname '|| IFNULL(:I_R_Agydisttrxn_FIELD_Productname,''));

    /* ORIGSQL: Log('Comtransferpiaor txnCode '|| I_R_Agydisttrxn.txnCode) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor txnCode '|| IFNULL(:I_R_Agydisttrxn_FIELD_txnCode,''));

    /* ORIGSQL: Log('Comtransferpiaor CurDistrict '|| I_R_Agydisttrxn.CurDistrict) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor CurDistrict '|| IFNULL(:I_R_Agydisttrxn_FIELD_CurDistrict,''));

    /* ORIGSQL: Log('Comtransferpiaor LdrCurRole '|| I_R_Agydisttrxn.LdrCurRole) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor LdrCurRole '|| IFNULL(:I_R_Agydisttrxn_FIELD_LdrCurRole,''));

    /* ORIGSQL: Log('Comtransferpiaor wAgyLdrCde '|| I_R_Agydisttrxn.wAgyLdrCde) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor wAgyLdrCde '|| IFNULL(:I_R_Agydisttrxn_FIELD_wAgyLdrCde,''));

    /* ORIGSQL: Log('Comtransferpiaor wAgencyLeader '|| I_R_Agydisttrxn.wAgencyLeader) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor wAgencyLeader '|| IFNULL(:I_R_Agydisttrxn_FIELD_wAgencyLeader,''));

    /* ORIGSQL: Log('Comtransferpiaor wAgyLdrTitle '|| I_R_Agydisttrxn.wAgyLdrTitle) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor wAgyLdrTitle '|| IFNULL(:I_R_Agydisttrxn_FIELD_Wagyldrtitle,''));

    /* ORIGSQL: Log('Comtransferpiaor wAgyLdrDistrict '|| I_R_Agydisttrxn.wAgyLdrDistrict) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor wAgyLdrDistrict '|| IFNULL(:I_R_Agydisttrxn_FIELD_Wagyldrdistrict,''));

    /* ORIGSQL: Log('Comtransferpiaor Spinstartdate '|| I_R_Agydisttrxn.Spinstartdate) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor Spinstartdate '|| IFNULL(TO_VARCHAR(:I_R_Agydisttrxn_FIELD_Spinstartdate),''));

    /* ORIGSQL: Log('Comtransferpiaor SpinEnddate '|| I_R_Agydisttrxn.SpinEnddate) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor SpinEnddate '|| IFNULL(TO_VARCHAR(:I_R_Agydisttrxn_FIELD_Spinenddate),''));

    /* ORIGSQL: Log('Comtransferpiaor Txnclasscode '|| I_R_Agydisttrxn.Txnclasscode) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor Txnclasscode '|| IFNULL(:I_R_Agydisttrxn_FIELD_Txnclasscode,''));

    /* ORIGSQL: Log('Comtransferpiaor Salestransactionseq '|| I_R_Agydisttrxn.Salestransactionseq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor Salestransactionseq '|| IFNULL(TO_VARCHAR(:I_R_Agydisttrxn_FIELD_Salestransactionseq),''));

    /* ORIGSQL: Log('Comtransferpiaor Wagency '|| I_R_Agydisttrxn.Wagency) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor Wagency '|| IFNULL(:I_R_Agydisttrxn_FIELD_Wagency,''));

    /* ORIGSQL: Log('Comtransferpiaor Commissionagy '|| I_R_Agydisttrxn.Commissionagy) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comtransferpiaor Commissionagy '|| IFNULL(:I_R_Agydisttrxn_FIELD_Commissionagy,''));

    IF :I_R_Agydisttrxn_FIELD_Wagency IS NOT NULL
    THEN
        --comDebugger('PIAOR DEBUGGER','vNewWritingAgy: '||vNewWritingAgy ||' -- '||v_wAgencyLeader);
        /* ORIGSQL: Log('C1') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C1');

        -- pi

        IF (:I_R_Agydisttrxn_FIELD_Eventtypeid = 'RYC' 
            OR (I_R_Agydisttrxn_FIELD_Eventtypeid = 'ORYC'
                AND SUBSTRING(:I_R_Agydisttrxn_FIELD_Orphanpolicy,1,1) = 'X'))  /* ORIGSQL: substr(I_R_Agydisttrxn.OrphanPolicy,1,1) */
        AND :I_R_Agydisttrxn_FIELD_Productname IN ('LF','HS')
        AND :I_R_Agydisttrxn_FIELD_txnCode IN ('PAY2','PAY3','PAY4','PAY5','PAY6')
        THEN
            IF :v_wAgyLdrTitle = 'FSD' 
            THEN
                IF :v_wAgyLdrDistrict = :v_commissionAgy
                THEN
                    v_rule = 'PI - Direct Team';

                    v_writingAgyLdr = :v_wAgyLdrDistrict;

                    /* ORIGSQL: Log('C2') */
                    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C2');
                ELSE 
                    v_rule = 'PI - Indirect Team';

                    v_writingAgyLdr = :v_wAgyLdrDistrict;

                    /* ORIGSQL: Log('C3') */
                    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C3');
                END IF;
                ELSEIF :v_wAgyLdrTitle = 'FSAD'   /* ORIGSQL: Elsif V_Wagyldrtitle='FSAD' Then */
                THEN
                    -- If I_R_Agydisttrxn.Agyspinoffindicator='Y' And I_R_Agydisttrxn.Agyspinoffflag=1 Then
                    --above checking was disabled

                    IF :I_R_Agydisttrxn_FIELD_Spinstartdate IS NOT NULL
                    THEN
                        --spin off case

                        v_writingAgyLdr = :v_wAgencyLeader;

                        v_rule = 'PI - Direct Team';

                        v_RunningType = IFNULL(:v_RunningType,'')||'_SpinOff';

                        /* ORIGSQL: Log('C4') */
                        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C4');
                    ELSE 
                        --non spin off case

                        IF :I_R_Agydisttrxn_FIELD_Wagtclass <> '12' 
                        THEN
                            -- FSAD no need compare ga13 with district, as long as class=10, writingAgy always get PI  

                            SELECT
                                p.genericattribute4
                            INTO
                                v_wAgyLdrCurClass
                            FROM
                                cs_position p,
                                cs_period t
                            WHERE
                                p.name = :v_wAgyLdrCde
                                AND p.removeDate = :cdt_EndOfTime
                                AND t.periodseq = :Gv_Periodseq
                                AND p.effectiveStartDate <= t.enddate -1
                                AND p.effectiveEndDate > t.enddate-1;

                            /* ORIGSQL: Log('C5') */
                            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C5');

                            IF :v_wAgyLdrCurClass <> '12' 
                            THEN
                                v_rule = 'PI - Direct Team';

                                v_writingAgyLdr = :v_wAgencyLeader;

                                /* ORIGSQL: Log('C6') */
                                CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C6');
                            ELSE 
                                v_rule = 'PI - Indirect Team';

                                v_writingAgyLdr = :v_wAgyLdrDistrict;

                                /* ORIGSQL: Log('C7') */
                                CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C7');
                            END IF;
                        ELSE 
                            v_rule = 'PI - Indirect Team';

                            v_writingAgyLdr = :v_wAgyLdrDistrict;

                            /* ORIGSQL: Log('C8') */
                            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C8');
                        END IF;
                    END IF;
                    --spin off chking
                ELSEIF :v_wAgyLdrTitle IN ('FSM','AM')  /* ORIGSQL: elsif v_wAgyLdrTitle in ('FSM','AM') then */
                THEN
                    --
                    /* ORIGSQL: Log('C9') */
                    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C9');

                    IF :I_R_Agydisttrxn_FIELD_Agyspinoffindicator = 'N' 
                    AND :I_R_Agydisttrxn_FIELD_Agyspinoffflag = 1
                    THEN
                        --spin off case
                        BEGIN 
                            DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 1299 /*1299=ERR_SQLSCRIPT_NO_DATA_FOUND*/
                                /* ORIGSQL: When No_Data_Found Then */
                                BEGIN
                                    /* ORIGSQL: raise Invalid_Manager; */
                                    SIGNAL INVALID_MANAGER;
                                END;

                                 
                            SELECT
                                Name
                            INTO
                                V_Manageragy
                            FROM
                                Cs_Position
                            WHERE
                                Ruleelementownerseq = :I_R_Agydisttrxn_FIELD_Managerseq
                                AND Removedate = :cdt_EndOfTime
                                AND Effectivestartdate <= :I_R_Agydisttrxn_FIELD_Versioningdate
                                AND effectiveEndDate > :I_R_Agydisttrxn_FIELD_Versioningdate;

                            /* ORIGSQL: Exception When No_Data_Found Then */
                        END;

                        /* ORIGSQL: Log('C10') */
                        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C10');

                        v_rule = 'PI - Indirect Team';

                        v_writingAgyLdr = :V_Manageragy;

                        v_RunningType = IFNULL(:v_RunningType,'')||'_SpinOff';
                    ELSE 
                        --non spin off

                        IF :v_wAgyLdrDistrict = :v_commissionAgy
                        THEN
                            v_rule = 'PI - Indirect Team';

                            v_writingAgyLdr = :v_wAgyLdrDistrict;

                            /* ORIGSQL: Log('C11') */
                            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C11');
                        ELSE 
                            v_rule = 'PI - Indirect Team';

                            v_writingAgyLdr = :v_wAgyLdrDistrict;

                            /* ORIGSQL: Log('C12') */
                            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C12');
                        END IF;
                    END IF;
                    --spin off chking for um
                END IF;
                /* ORIGSQL: Log('C13') */
                CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C13');

                --check crossover set up
                IF :v_setup <> 'X' 
                AND :v_wAgyLdrTitle IN ('FSD','FSAD','FSM','AM')
                THEN
                    vNewWritingAgy = DBMTK_USER_NAME.PK_STAGE_HOOK__comGetCrossoverAgy('PI', :v_wAgyLdrCde, :v_policyIssueDate);  /* ORIGSQL: comGetCrossoverAgy('PI',v_wAgyLdrCde,v_policyIssueDate) */
                    --add by nelson
                    /* ORIGSQL: Log('C14') */
                    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C14');

                    IF :vNewWritingAgy IS NOT NULL
                    THEN
                        -- add by nelson

                        v_writingAgyLdr = 'SGY'||IFNULL(:vNewWritingAgy,'');
                        -- add by nelson

                        v_rule = 'PI - Direct Team';
                        -- add by nelson
                        /* ORIGSQL: Log('C15') */
                        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C15');
                    END IF;
                    -- add by nelson
                END IF;
            END IF;
            --eventtype check FOR PI
            --comDebugger('PIAOR DEBUGGER','v_rule1: '||v_rule);
            /* ORIGSQL: Log('C16') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C16');

            --aor

            IF :I_R_Agydisttrxn_FIELD_Eventtypeid IN ('API','IFYC','FYC', 'SSCP')
            OR (I_R_Agydisttrxn_FIELD_Eventtypeid = 'RYC'
                AND :I_R_Agydisttrxn_FIELD_Productname IN ('LF','HS','PA','CS'))
            THEN
                /* ORIGSQL: Log('C17') */
                CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C17');

                --add by nelson start

                IF :v_wAgyLdrTitle = 'FSD' 
                AND :v_wAgyLdrDistrict = :v_commissionAgy
                AND :v_wAgyLdrDistrict = :v_CurDistrict
                AND :v_LdrCurRole = 'FSD'
                THEN
                    v_AorRule = 'AOR - Direct Team';

                    V_Aorwagyldr = :v_CurDistrict;

                    /* ORIGSQL: Log('C18') */
                    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C18');
                ELSEIF :v_wAgyLdrTitle = 'FSAD'
                AND :v_wAgyLdrDistrict <> :v_CurDistrict
                AND :v_LdrCurRole = 'FSD'   /* ORIGSQL: Elsif v_wAgyLdrTitle = 'FSAD' and v_wAgyLdrDistrict<>v_CurDistrict and v_LdrCurRole ='FSD' then */
                THEN
                    v_AorRule = 'AOR - Indirect Team';

                    V_Aorwagyldr = :v_wAgyLdrDistrict;

                    /* ORIGSQL: Log('C19') */
                    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C19');
                ELSEIF :v_wAgyLdrTitle = 'FSAD'
                AND (:I_R_Agydisttrxn_FIELD_Spinstartdate IS NOT NULL
                    OR :I_R_Agydisttrxn_FIELD_Spinenddate IS NOT NULL)  /* ORIGSQL: Elsif v_wAgyLdrTitle = 'FSAD' and (I_R_Agydisttrxn.Spinstartdate IS NOT NULL or I_R_Agydisttrxn.Spinenddate IS NOT NULL) then */
                THEN
                    --spin off case

                    v_AorRule = 'AOR - Direct Team';

                    V_Aorwagyldr = :v_wAgyLdrDistrict;

                    /* ORIGSQL: Log('C20') */
                    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C20');

                    IF :I_R_Agydisttrxn_FIELD_Spindaterange > 8
                    OR (:I_R_Agydisttrxn_FIELD_actualOrphanPolicy <> 'O'
                    AND :I_R_Agydisttrxn_FIELD_Compensationdate > :I_R_Agydisttrxn_FIELD_Spinenddate)
                    THEN
                        v_OrphanPolicy = 'XO';
                        --- set the flag as 'XO', the transaction will not get PI or AOR, but stamp 1 to EB4 of trxn
                        /* ORIGSQL: Log('C21') */
                        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C21');
                    END IF;
                ELSE 
                    v_AorRule = 'AOR - Indirect Team';

                    V_Aorwagyldr = :v_CurDistrict;

                    /* ORIGSQL: Log('C22') */
                    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C22');
                END IF;
                --add by nelson end

                IF :v_setup <> 'X' 
                THEN
                    vAorNewWritingAgy = DBMTK_USER_NAME.PK_STAGE_HOOK__comGetCrossoverAgy('AOR', :v_wAgyLdrCde, :v_policyIssueDate);  /* ORIGSQL: comGetCrossoverAgy('AOR',v_wAgyLdrCde,v_policyIssueDate) */

                    /* ORIGSQL: Log('C23') */
                    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C23');

                    IF :vAorNewWritingAgy IS NOT NULL
                    THEN
                        --Vnewwritingagy:='SGY'||Vnewwritingagy; commented by nelson

                        V_Aorwagyldr = 'SGY'||IFNULL(:vAorNewWritingAgy,'');
                        -- add by nelson

                        v_AorRule = 'AOR - Direct Team';

                        /* ORIGSQL: Log('C24') */
                        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C24');
                    END IF;
                END IF;
            END IF;
            --EVENTTYPE CHECK FOR AOR
            --comDebugger('PIAOR DEBUGGER','v_rule2'||v_rule);
            /* ORIGSQL: Log('C25 '|| V_Rule) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C25 '|| IFNULL(:v_rule,''));

            IF :v_rule IS NOT NULL
            AND :I_R_Agydisttrxn_FIELD_Eventtypeid IN ('RYC','ORYC')
            THEN
                -- v_maxSetNumber:=v_maxSetNumber+1;
                /* ORIGSQL: Log('C26') */
                CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C26'); 

                /* ORIGSQL: insert into sh_query_result (component,periodseq, genericSequence1, genericSequence2, genericAttribute1, genericAttribute2, genericAttribute3, genericAttribute4, genericAttribute5, genericDate1, gener(...) */
                INSERT INTO sh_query_result
                    (
                        component, periodseq,
                        genericSequence1 /* --txnseq */,
                        genericSequence2  /* --orderSeq */,
                        genericAttribute1 /* --wAgyLdr */,
                        genericAttribute2  /* --wAgyLdrTitle */,
                        genericAttribute3   /* --wAgy */,
                        genericAttribute4   /* --wAgyDistrict */,
                        genericAttribute5  /* --rule */,
                        genericDate1    /* --policyIssueDate */,
                        genericDate2     /* --compensationDate */,
                        genericNumber1  /* --setNumber */,
                        genericAttribute6  /* --BUMap */,
                        GENERICATTRIBUTE7,
                        Genericattribute8,
                        Genericattribute9,
                        Genericattribute10 /* --ga10 is the rule before redirect */,
                        Genericattribute11,
                        genericAttribute12
                    )
                VALUES (
                        'PI',
                        :Gv_Periodseq,
                        :I_R_Agydisttrxn_FIELD_Salestransactionseq,
                        :I_R_Agydisttrxn_FIELD_SALESORDERSEQ,
                        :v_writingAgyLdr,
                        :v_wAgyLdrTitle,
                        :v_wAgency,
                        :v_wAgyLdrDistrict,
                        :v_rule,
                        :v_policyIssueDate,
                        :I_R_Agydisttrxn_FIELD_Compensationdate,
                        :Gv_Setnumberpi,
                        :I_R_Agydisttrxn_FIELD_Businessunitmap,
                        :I_R_Agydisttrxn_FIELD_Eventtypeid,
                        :I_R_Agydisttrxn_FIELD_Productname,
                        'PI '||IFNULL(:v_RunningType,''),
                        :v_rule,
                        :I_R_Agydisttrxn_FIELD_Orphanpolicy  /* --REAL GA17 */,
                        :I_R_Agydisttrxn_FIELD_Txnclasscode
                );
            END IF;

            IF :v_AorRule IS NOT NULL
            AND :I_R_Agydisttrxn_FIELD_Eventtypeid IN ('RYC','API','IFYC','FYC', 'SSCP')
            THEN
                --v_maxSetNumber:=v_maxSetNumber+1;
                /* ORIGSQL: Log('C27') */
                CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C27'); 

                /* ORIGSQL: insert into sh_query_result (component,periodseq, genericSequence1, genericSequence2, genericAttribute1, genericAttribute2, genericAttribute3, genericAttribute4, genericAttribute5, genericDate1, gener(...) */
                INSERT INTO sh_query_result
                    (
                        component, periodseq,
                        genericSequence1 /* --txnseq */,
                        genericSequence2  /* --orderSeq */,
                        genericAttribute1 /* --wAgyLdr */,
                        genericAttribute2  /* --wAgyLdrTitle */,
                        genericAttribute3   /* --wAgy */,
                        genericAttribute4   /* --wAgyDistrict */,
                        genericAttribute5  /* --rule */,
                        genericDate1    /* --policyIssueDate */,
                        genericDate2     /* --compensationDate */,
                        genericNumber1  /* --setNumber */,
                        genericAttribute6  /* --BUMap */,
                        GENERICATTRIBUTE7 /* --eventtype */,
                        GENERICATTRIBUTE8 /* --productname */,
                        Genericattribute9 /* --running type */,
                        Genericattribute10 /* --rule before redicrect, because, after the SP, stagehook will update GA5 */,
                        Genericattribute11  /* --REAL GA17 */,
                        Genericdate3 /* --spin off start date */,
                        Genericnumber2 /* --spin off range */,
                        genericAttribute12 /* --txn classcode */
                    )
                VALUES (
                        'AOR',
                        :Gv_Periodseq,
                        :I_R_Agydisttrxn_FIELD_Salestransactionseq,
                        :I_R_Agydisttrxn_FIELD_SALESORDERSEQ,
                        :V_Aorwagyldr,
                        :v_wAgyLdrTitle,
                        :v_wAgency,
                        :v_wAgyLdrDistrict,
                        :v_AorRule,
                        :v_policyIssueDate,
                        :I_R_Agydisttrxn_FIELD_Compensationdate,
                        :gv_setnumberaor,
                        :I_R_Agydisttrxn_FIELD_Businessunitmap,
                        :I_R_Agydisttrxn_FIELD_Eventtypeid,
                        :I_R_Agydisttrxn_FIELD_Productname,
                        'AOR '||IFNULL(:v_RunningType,''),
                        :v_AorRule,
                        :v_OrphanPolicy,
                        :I_R_Agydisttrxn_FIELD_Spinstartdate,
                        :I_R_Agydisttrxn_FIELD_Spindaterange,
                        :I_R_Agydisttrxn_FIELD_Txnclasscode
                );
            END IF;
        END IF;
        -- wAgency IS NOT NULL

        v_rule = NULL;

        v_AorRule = NULL;

        /* ORIGSQL: Log('C29') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('C29');

        /* ORIGSQL: Exception When Invalid_Manager Then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__Comtransferpiaor_debug') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__Comtransferpiaor' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__Comtransferpiaor''...' );
go

/* ORIGSQL: Procedure Comtransferpiaor(I_R_Agydisttrxn In R_Agydisttrxn) as v_policyIssueDate date; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__Comtransferpiaor
(
    IN I_R_Agydisttrxn_FIELD_Salestransactionseq BIGINT,     /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_SALESORDERSEQ BIGINT,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Wagency VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_wAgencyLeader VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Wagyldrtitle VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_LdrCurRole VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Wagyldrdistrict VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_CurDistrict VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Policyissuedate TIMESTAMP,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Compensationdate TIMESTAMP,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Wagtclass VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Commissionagy VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Runningtype VARCHAR(100),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Eventtypeid VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Productname VARCHAR(100),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Businessunitmap VARCHAR(100),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Orphanpolicy VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Managerseq BIGINT,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Agyspinoffindicator VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Agyspinoffflag BIGINT,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Versioningdate TIMESTAMP,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Periodseq BIGINT,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Spinstartdate TIMESTAMP,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Spindaterange DECIMAL(38,10),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Txnclasscode VARCHAR(10),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_Spinenddate TIMESTAMP,   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_actualOrphanPolicy VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_wAgyLdrCde VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_setup VARCHAR(30),   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
    IN I_R_Agydisttrxn_FIELD_txnCode VARCHAR(30)   /* ORIGSQL: I_R_Agydisttrxn In R_Agydisttrxn */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();
    DECLARE Gv_Setnumberpi BIGINT; /* package/session variable */
    DECLARE gv_setnumberaor BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE v_policyIssueDate TIMESTAMP;  /* ORIGSQL: v_policyIssueDate date; */
    DECLARE V_Compensationdate TIMESTAMP;  /* ORIGSQL: V_Compensationdate Date; */
    DECLARE v_maxSetNumber BIGINT;  /* ORIGSQL: v_maxSetNumber int; */

    --removed
    DECLARE v_rule VARCHAR(100);  /* ORIGSQL: v_rule varchar2(100); */
    DECLARE v_writingAgyLdr VARCHAR(30);  /* ORIGSQL: v_writingAgyLdr varchar2(30); */
    DECLARE v_wAgency VARCHAR(30);  /* ORIGSQL: v_wAgency varchar2(30); */
    DECLARE v_wAgencyLeader VARCHAR(30);  /* ORIGSQL: v_wAgencyLeader varchar2(30); */
    DECLARE v_wAgyLdrTitle VARCHAR(30);  /* ORIGSQL: v_wAgyLdrTitle varchar2(30); */
    DECLARE v_wAgyLdrDistrict VARCHAR(30);  /* ORIGSQL: v_wAgyLdrDistrict varchar2(30); */
    DECLARE v_Wagtclass VARCHAR(10);  /* ORIGSQL: v_Wagtclass varchar2(10); */
    DECLARE vNewWritingAgy VARCHAR(10);  /* ORIGSQL: vNewWritingAgy varchar2(10); */
    DECLARE vAorNewWritingAgy VARCHAR(10);  /* ORIGSQL: vAorNewWritingAgy varchar2(10); */
    DECLARE v_AorRule VARCHAR(100);  /* ORIGSQL: v_AorRule varchar2(100); */
    DECLARE V_Aorwagyldr VARCHAR(30);  /* ORIGSQL: V_Aorwagyldr Varchar2(30); */
    DECLARE v_commissionAgy VARCHAR(30);  /* ORIGSQL: v_commissionAgy varchar2(30); */
    DECLARE v_CurDistrict VARCHAR(30);  /* ORIGSQL: v_CurDistrict Varchar2(30); */

    --add by nelson
    DECLARE v_LdrCurRole VARCHAR(30);  /* ORIGSQL: v_LdrCurRole Varchar2(30); */

    --add by nelson
    DECLARE v_wAgyLdrCde VARCHAR(30);  /* ORIGSQL: v_wAgyLdrCde Varchar2(30); */

    --add by nelson
    DECLARE v_setup VARCHAR(30);  /* ORIGSQL: v_setup Varchar2(30); */

    --add by nelson
    DECLARE v_wAgyLdrCurClass VARCHAR(30);  /* ORIGSQL: v_wAgyLdrCurClass varchar2(30); */
    DECLARE v_standalone VARCHAR(30);  /* ORIGSQL: v_standalone varchar2(30); */

    --add by jeff
    DECLARE v_standalone2 DECIMAL(30);  /* ORIGSQL: v_standalone2 number(30); */

    --add by jeff
    DECLARE v_periodenddate TIMESTAMP;  /* ORIGSQL: v_periodenddate date; */

    --add by jeff

    DECLARE V_Crossoverflag BIGINT = 0;  /* ORIGSQL: V_Crossoverflag Int:=0; */
    DECLARE v_ConstantCrossoverDate TIMESTAMP = sapdbmtk.sp_f_dbmtk_format_string_to_datetime('1/1/2005','mm/dd/yyyy');  /* ORIGSQL: v_ConstantCrossoverDate date:=to_date('1/1/2005','mm/dd/yyyy') ; */

    DECLARE V_Manageragy VARCHAR(30);  /* ORIGSQL: V_Manageragy Varchar2(30); */
    DECLARE v_RunningType VARCHAR(255);  /* ORIGSQL: v_RunningType varchar2(255); */
    DECLARE v_OrphanPolicy VARCHAR(30);  /* ORIGSQL: v_OrphanPolicy varchar2(30); */
    DECLARE INVALID_MANAGER CONDITION;  /* ORIGSQL: Invalid_Manager exception; */

    DECLARE EXIT HANDLER FOR INVALID_MANAGER
        /* ORIGSQL: When Invalid_Manager Then */
        BEGIN
            /* ORIGSQL: Comdebugger('ComTransferPIAOR','Stagehook is not able get any spin off manager'||I_R_Agydisttrxn.salestransactionSeq) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('ComTransferPIAOR', 'Stagehook is not able get any spin off manager'||IFNULL(TO_VARCHAR(:I_R_Agydisttrxn_FIELD_Salestransactionseq),''));
        END;



    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            /* ORIGSQL: comDebugger('ComTransferPIAOR','Error'||sqlerrm) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('ComTransferPIAOR', 'Error'||::SQL_ERROR_MESSAGE 
            );  /* ORIGSQL: sqlerrm */
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERPI') AS BIGINT) INTO Gv_Setnumberpi FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_SETNUMBERAOR') AS BIGINT) INTO gv_setnumberaor FROM SYS.DUMMY ;
        /* end of package/session variables */



    /*
    begin
      select nvl(max(setNumber),0)
      into v_maxSetNumber
      from cs_transactionAssignment
      where I_R_Agydisttrxn.salestransactionSeq=salestransactionSeq
     And Genericattribute4 IS NULL;
    
    exception when no_data_found then
      v_maxSetNumber:=0;
    end;
    
    */

    --DBMS_OUTPUT.put_line(c_txn.salestransactionSeq||'   start c_txn  issue date  '||to_char(v_policyIssueDate,'mm/dd/yyyy'));
    --DBMS_OUTPUT.put_line(v_policyIssueDate||' ---- '||v_cutoverdate);

    v_wAgency = :I_R_Agydisttrxn_FIELD_Wagency;

    v_wAgencyLeader = :I_R_Agydisttrxn_FIELD_wAgencyLeader;

    v_wAgyLdrTitle = :I_R_Agydisttrxn_FIELD_Wagyldrtitle;

    v_wAgyLdrDistrict = :I_R_Agydisttrxn_FIELD_Wagyldrdistrict;

    v_Wagtclass = :I_R_Agydisttrxn_FIELD_Wagtclass;

    v_policyIssueDate = :I_R_Agydisttrxn_FIELD_Policyissuedate;

    v_commissionAgy = :I_R_Agydisttrxn_FIELD_Commissionagy;

    v_RunningType = :I_R_Agydisttrxn_FIELD_Runningtype;

    v_OrphanPolicy = :I_R_Agydisttrxn_FIELD_Orphanpolicy;

    v_CurDistrict = :I_R_Agydisttrxn_FIELD_CurDistrict;
    --add by nelson

    v_LdrCurRole = :I_R_Agydisttrxn_FIELD_LdrCurRole;
    --add by nelson

    v_wAgyLdrCde = :I_R_Agydisttrxn_FIELD_wAgyLdrCde;
    --add by nelson

    v_setup = :I_R_Agydisttrxn_FIELD_setup;
    --add by nelson 

    SELECT
        enddate
    INTO
        v_periodenddate
    FROM
        cs_period
    WHERE
        periodseq = :Gv_Periodseq;

    --comDebugger('PIAOR DEBUGGER','WAGENCY['||v_wAgency||']||');

    IF :I_R_Agydisttrxn_FIELD_Wagency IS NOT NULL
    THEN
        --comDebugger('PIAOR DEBUGGER','vNewWritingAgy: '||vNewWritingAgy ||' -- '||v_wAgencyLeader);
        -- pi

        IF (:I_R_Agydisttrxn_FIELD_Eventtypeid = 'RYC' 
            OR (I_R_Agydisttrxn_FIELD_Eventtypeid = 'ORYC'
                AND SUBSTRING(:I_R_Agydisttrxn_FIELD_Orphanpolicy,1,1) = 'X'))  /* ORIGSQL: substr(I_R_Agydisttrxn.OrphanPolicy,1,1) */
        AND :I_R_Agydisttrxn_FIELD_Productname IN ('LF','HS')
        AND :I_R_Agydisttrxn_FIELD_txnCode IN ('PAY2','PAY3','PAY4','PAY5','PAY6')
        THEN
            IF :v_wAgyLdrTitle = 'FSD' 
            THEN
                IF :v_wAgyLdrDistrict = :v_commissionAgy
                THEN
                    v_rule = 'PI - Direct Team';

                    v_writingAgyLdr = :v_wAgyLdrDistrict;

                    --               Log('C2');
                ELSE 
                    v_rule = 'PI - Indirect Team';

                    v_writingAgyLdr = :v_wAgyLdrDistrict;

                    --         Log('C3');
                END IF;
                ELSEIF :v_wAgyLdrTitle = 'FSAD'   /* ORIGSQL: Elsif V_Wagyldrtitle='FSAD' Then */
                THEN
                    -- If I_R_Agydisttrxn.Agyspinoffindicator='Y' And I_R_Agydisttrxn.Agyspinoffflag=1 Then
                    --above checking was disabled

                    IF :I_R_Agydisttrxn_FIELD_Spinstartdate IS NOT NULL
                    THEN
                        --spin off case

                        v_writingAgyLdr = :v_wAgencyLeader;

                        v_rule = 'PI - Direct Team';

                        v_RunningType = IFNULL(:v_RunningType,'')||'_SpinOff';

                        --         Log('C4');
                    ELSE 
                        --non spin off case

                        IF :I_R_Agydisttrxn_FIELD_Wagtclass <> '12' 
                        THEN
                            -- FSAD no need compare ga13 with district, as long as class=10, writingAgy always get PI  

                            SELECT
                                p.genericattribute4
                            INTO
                                v_wAgyLdrCurClass
                            FROM
                                cs_position p,
                                cs_period t
                            WHERE
                                p.name = :v_wAgyLdrCde
                                AND p.removeDate = :cdt_EndOfTime
                                AND t.periodseq = :Gv_Periodseq
                                AND p.effectiveStartDate <= t.enddate -1
                                AND p.effectiveEndDate > t.enddate-1;

                            --Log('C5');

                            IF :v_wAgyLdrCurClass <> '12' 
                            THEN
                                v_rule = 'PI - Direct Team';

                                v_writingAgyLdr = :v_wAgencyLeader;

                                --                  Log('C6');
                            ELSE 
                                v_rule = 'PI - Indirect Team';

                                v_writingAgyLdr = :v_wAgyLdrDistrict;

                                --                Log('C7');
                            END IF;
                        ELSE 
                            v_rule = 'PI - Indirect Team';

                            v_writingAgyLdr = :v_wAgyLdrDistrict;

                            --            Log('C8');
                        END IF;
                    END IF;
                    --spin off chking
                ELSEIF :v_wAgyLdrTitle IN ('FSM','AM')  /* ORIGSQL: elsif v_wAgyLdrTitle in ('FSM','AM') then */
                THEN
                    --
                    --  Log('C9');

                    IF :I_R_Agydisttrxn_FIELD_Agyspinoffindicator = 'N' 
                    AND :I_R_Agydisttrxn_FIELD_Agyspinoffflag = 1
                    THEN
                        --spin off case
                        BEGIN 
                            DECLARE EXIT HANDLER FOR SQL_ERROR_CODE 1299 /*1299=ERR_SQLSCRIPT_NO_DATA_FOUND*/
                                /* ORIGSQL: When No_Data_Found Then */
                                BEGIN
                                    /* ORIGSQL: raise Invalid_Manager; */
                                    SIGNAL INVALID_MANAGER;
                                END;

                                 
                            SELECT
                                Name
                            INTO
                                V_Manageragy
                            FROM
                                Cs_Position
                            WHERE
                                Ruleelementownerseq = :I_R_Agydisttrxn_FIELD_Managerseq
                                AND Removedate = :cdt_EndOfTime
                                AND Effectivestartdate <= :I_R_Agydisttrxn_FIELD_Versioningdate
                                AND effectiveEndDate > :I_R_Agydisttrxn_FIELD_Versioningdate;

                            /* ORIGSQL: Exception When No_Data_Found Then */
                        END;
                        --Log('C10');

                        v_rule = 'PI - Indirect Team';

                        v_writingAgyLdr = :V_Manageragy;

                        v_RunningType = IFNULL(:v_RunningType,'')||'_SpinOff';
                    ELSE 
                        --non spin off

                        IF :v_wAgyLdrDistrict = :v_commissionAgy
                        THEN
                            v_rule = 'PI - Indirect Team';

                            v_writingAgyLdr = :v_wAgyLdrDistrict;

                            --            Log('C11');
                        ELSE 
                            v_rule = 'PI - Indirect Team';

                            v_writingAgyLdr = :v_wAgyLdrDistrict;

                            --          Log('C12');
                        END IF;
                    END IF;
                    --spin off chking for um
                END IF;
                --Log('C13');

                --add version 5 (if payee is ever a standalone AM, and current title is FSAD, then it will set all in direct team) 
                SELECT
                    po.genericattribute11
                INTO
                    v_standalone
                FROM
                    cs_position po
                WHERE
                    po.name = :v_writingAgyLdr
                    AND PO.REMOVEDATE = :cdt_EndOfTime
                    AND po.effectivestartdate <= TO_DATE(ADD_SECONDS(:v_periodenddate,(86400*-1)))   /* ORIGSQL: v_periodenddate-1 */
                    AND po.effectiveenddate > TO_DATE(ADD_SECONDS(:v_periodenddate,(86400*-1)));  /* ORIGSQL: v_periodenddate-1 */

                /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.TBL_PIAOR_STANDALONE' not found */

                SELECT
                    COUNT(1)
                INTO
                    v_standalone2
                FROM
                    TBL_PIAOR_STANDALONE
                WHERE
                    agyname = :v_writingAgyLdr;

                IF :v_standalone = 'FSAD' 
                AND :v_standalone2 >= 1
                THEN
                    v_rule = 'PI - Direct Team';
                END IF;
                --end add

                --check crossover set up
                IF :v_setup <> 'X' 
                AND :v_wAgyLdrTitle IN ('FSD','FSAD','FSM','AM')
                THEN
                    vNewWritingAgy = DBMTK_USER_NAME.PK_STAGE_HOOK__comGetCrossoverAgy('PI', :v_wAgyLdrCde, :v_policyIssueDate);  /* ORIGSQL: comGetCrossoverAgy('PI',v_wAgyLdrCde,v_policyIssueDate) */
                    --add by nelson
                    --Log('C14');

                    IF :vNewWritingAgy IS NOT NULL
                    THEN
                        -- add by nelson

                        v_writingAgyLdr = 'SGY'||IFNULL(:vNewWritingAgy,'');
                        -- add by nelson

                        v_rule = 'PI - Direct Team';
                        -- add by nelson
                        --             Log('C15');
                    END IF;
                    -- add by nelson
                END IF;
            END IF;
            --eventtype check FOR PI
            --comDebugger('PIAOR DEBUGGER','v_rule1: '||v_rule);
            --Log('C16');
            --aor

            IF :I_R_Agydisttrxn_FIELD_Eventtypeid IN ('API','IFYC','FYC', 'SSCP')
            OR (I_R_Agydisttrxn_FIELD_Eventtypeid = 'RYC'
                AND :I_R_Agydisttrxn_FIELD_Productname IN ('LF','HS','PA','CS'))
            THEN
                --Log('C17');
                --add by nelson start

                IF :v_wAgyLdrTitle = 'FSD' 
                AND :v_wAgyLdrDistrict = :v_commissionAgy
                AND :v_wAgyLdrDistrict = :v_CurDistrict
                AND :v_LdrCurRole = 'FSD'
                THEN
                    v_AorRule = 'AOR - Direct Team';

                    V_Aorwagyldr = :v_CurDistrict;

                    --  Log('C18');
                ELSEIF :v_wAgyLdrTitle = 'FSAD'
                AND :v_wAgyLdrDistrict <> :v_CurDistrict
                AND :v_LdrCurRole = 'FSD'   /* ORIGSQL: Elsif v_wAgyLdrTitle = 'FSAD' and v_wAgyLdrDistrict<>v_CurDistrict and v_LdrCurRole ='FSD' then */
                THEN
                    v_AorRule = 'AOR - Indirect Team';

                    V_Aorwagyldr = :v_wAgyLdrDistrict;

                    --Log('C19');
                ELSEIF :v_wAgyLdrTitle = 'FSAD'
                AND (:I_R_Agydisttrxn_FIELD_Spinstartdate IS NOT NULL
                    OR :I_R_Agydisttrxn_FIELD_Spinenddate IS NOT NULL)  /* ORIGSQL: Elsif v_wAgyLdrTitle = 'FSAD' and (I_R_Agydisttrxn.Spinstartdate IS NOT NULL or I_R_Agydisttrxn.Spinenddate IS NOT NULL) then */
                THEN
                    --spin off case

                    v_AorRule = 'AOR - Direct Team';

                    V_Aorwagyldr = :v_wAgyLdrDistrict;

                    --                  Log('C20');

                    IF :I_R_Agydisttrxn_FIELD_Spindaterange > 8
                    OR (:I_R_Agydisttrxn_FIELD_actualOrphanPolicy <> 'O'
                    AND :I_R_Agydisttrxn_FIELD_Compensationdate > :I_R_Agydisttrxn_FIELD_Spinenddate)
                    THEN
                        v_OrphanPolicy = 'XO';
                        --- set the flag as 'XO', the transaction will not get PI or AOR, but stamp 1 to EB4 of trxn
                        --                    Log('C21');
                    END IF;
                ELSE 
                    v_AorRule = 'AOR - Indirect Team';

                    V_Aorwagyldr = :v_CurDistrict;

                    --                Log('C22');
                END IF;
                --add by nelson end

                --add version 5 (if payee is ever a standalone AM, it will reassign to current DM.) 
                SELECT
                    COUNT(1)
                INTO
                    v_standalone2
                FROM
                    TBL_PIAOR_STANDALONE
                WHERE
                    agyname = :V_Aorwagyldr;

                IF :v_standalone2 >= 1
                THEN
                    V_Aorwagyldr = :v_CurDistrict;
                END IF;
                --end add

                IF :v_setup <> 'X' 
                THEN
                    vAorNewWritingAgy = DBMTK_USER_NAME.PK_STAGE_HOOK__comGetCrossoverAgy('AOR', :v_wAgyLdrCde, :v_policyIssueDate);  /* ORIGSQL: comGetCrossoverAgy('AOR',v_wAgyLdrCde,v_policyIssueDate) */

                    --Log('C23');

                    IF :vAorNewWritingAgy IS NOT NULL
                    THEN
                        --Vnewwritingagy:='SGY'||Vnewwritingagy; commented by nelson

                        V_Aorwagyldr = 'SGY'||IFNULL(:vAorNewWritingAgy,'');
                        -- add by nelson

                        v_AorRule = 'AOR - Direct Team';

                        --               Log('C24');
                    END IF;
                END IF;
            END IF;
            --EVENTTYPE CHECK FOR AOR
            --comDebugger('PIAOR DEBUGGER','v_rule2'||v_rule);
            --Log('C25');

            IF :v_rule IS NOT NULL
            AND :I_R_Agydisttrxn_FIELD_Eventtypeid IN ('RYC','ORYC')
            THEN
                -- v_maxSetNumber:=v_maxSetNumber+1;
                ---   Log('C26'); 
                /* ORIGSQL: insert into sh_query_result (component,periodseq, genericSequence1, genericSequence2, genericAttribute1, genericAttribute2, genericAttribute3, genericAttribute4, genericAttribute5, genericDate1, gener(...) */
                INSERT INTO sh_query_result
                    (
                        component, periodseq,
                        genericSequence1 /* --txnseq */,
                        genericSequence2  /* --orderSeq */,
                        genericAttribute1 /* --wAgyLdr */,
                        genericAttribute2  /* --wAgyLdrTitle */,
                        genericAttribute3   /* --wAgy */,
                        genericAttribute4   /* --wAgyDistrict */,
                        genericAttribute5  /* --rule */,
                        genericDate1    /* --policyIssueDate */,
                        genericDate2     /* --compensationDate */,
                        genericNumber1  /* --setNumber */,
                        genericAttribute6  /* --BUMap */,
                        GENERICATTRIBUTE7,
                        Genericattribute8,
                        Genericattribute9,
                        Genericattribute10 /* --ga10 is the rule before redirect */,
                        Genericattribute11,
                        genericAttribute12
                    )
                VALUES (
                        'PI',
                        :Gv_Periodseq,
                        :I_R_Agydisttrxn_FIELD_Salestransactionseq,
                        :I_R_Agydisttrxn_FIELD_SALESORDERSEQ,
                        :v_writingAgyLdr,
                        :v_wAgyLdrTitle,
                        :v_wAgency,
                        :v_wAgyLdrDistrict,
                        :v_rule,
                        :v_policyIssueDate,
                        :I_R_Agydisttrxn_FIELD_Compensationdate,
                        :Gv_Setnumberpi,
                        :I_R_Agydisttrxn_FIELD_Businessunitmap,
                        :I_R_Agydisttrxn_FIELD_Eventtypeid,
                        :I_R_Agydisttrxn_FIELD_Productname,
                        'PI '||IFNULL(:v_RunningType,''),
                        :v_rule,
                        :I_R_Agydisttrxn_FIELD_Orphanpolicy  /* --REAL GA17 */,
                        :I_R_Agydisttrxn_FIELD_Txnclasscode
                );
            END IF;

            IF :v_AorRule IS NOT NULL
            AND :I_R_Agydisttrxn_FIELD_Eventtypeid IN ('RYC','API','IFYC','FYC', 'SSCP')
            THEN
                --v_maxSetNumber:=v_maxSetNumber+1;
                -- Log('C27'); 
                /* ORIGSQL: insert into sh_query_result (component,periodseq, genericSequence1, genericSequence2, genericAttribute1, genericAttribute2, genericAttribute3, genericAttribute4, genericAttribute5, genericDate1, gener(...) */
                INSERT INTO sh_query_result
                    (
                        component, periodseq,
                        genericSequence1 /* --txnseq */,
                        genericSequence2  /* --orderSeq */,
                        genericAttribute1 /* --wAgyLdr */,
                        genericAttribute2  /* --wAgyLdrTitle */,
                        genericAttribute3   /* --wAgy */,
                        genericAttribute4   /* --wAgyDistrict */,
                        genericAttribute5  /* --rule */,
                        genericDate1    /* --policyIssueDate */,
                        genericDate2     /* --compensationDate */,
                        genericNumber1  /* --setNumber */,
                        genericAttribute6  /* --BUMap */,
                        GENERICATTRIBUTE7 /* --eventtype */,
                        GENERICATTRIBUTE8 /* --productname */,
                        Genericattribute9 /* --running type */,
                        Genericattribute10 /* --rule before redicrect, because, after the SP, stagehook will update GA5 */,
                        Genericattribute11  /* --REAL GA17 */,
                        Genericdate3 /* --spin off start date */,
                        Genericnumber2 /* --spin off range */,
                        genericAttribute12 /* --txn classcode */
                    )
                VALUES (
                        'AOR',
                        :Gv_Periodseq,
                        :I_R_Agydisttrxn_FIELD_Salestransactionseq,
                        :I_R_Agydisttrxn_FIELD_SALESORDERSEQ,
                        :V_Aorwagyldr,
                        :v_wAgyLdrTitle,
                        :v_wAgency,
                        :v_wAgyLdrDistrict,
                        :v_AorRule,
                        :v_policyIssueDate,
                        :I_R_Agydisttrxn_FIELD_Compensationdate,
                        :gv_setnumberaor,
                        :I_R_Agydisttrxn_FIELD_Businessunitmap,
                        :I_R_Agydisttrxn_FIELD_Eventtypeid,
                        :I_R_Agydisttrxn_FIELD_Productname,
                        'AOR '||IFNULL(:v_RunningType,''),
                        :v_AorRule,
                        :v_OrphanPolicy,
                        :I_R_Agydisttrxn_FIELD_Spinstartdate,
                        :I_R_Agydisttrxn_FIELD_Spindaterange,
                        :I_R_Agydisttrxn_FIELD_Txnclasscode
                );
            END IF;
        END IF;
        -- wAgency IS NOT NULL

        v_rule = NULL;

        v_AorRule = NULL;

        --Log('C29');

        /* ORIGSQL: Exception When Invalid_Manager Then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__Comtransferpiaor') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__ComInitialpartition' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__ComInitialpartition''...' );
go

/* ORIGSQL: Procedure ComInitialpartition(I_Component In Varchar2, i_componentValue in varchar2, I_Periodseq In Int) As V_str Varchar2(1000); */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__ComInitialpartition
(
    IN I_Component VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                   /* ORIGSQL: I_Component IN Varchar2 */
    IN i_componentValue VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                        /* ORIGSQL: i_componentValue IN varchar2 */
    IN I_Periodseq BIGINT     /* ORIGSQL: I_Periodseq IN Int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */

    DECLARE V_str VARCHAR(1000);  /* ORIGSQL: V_str Varchar2(1000); */
    DECLARE V_Cnt BIGINT;  /* ORIGSQL: V_Cnt Int; */
    DECLARE v_partitionname VARCHAR(100) = 'SH_INITIAL_' || IFNULL(:I_Component,'');  /* ORIGSQL: v_partitionname varchar2(100) := 'SH_INITIAL_' || I_Component; */
    DECLARE V_subPartitionname VARCHAR(100) = UPPER('Sh_' || IFNULL(:I_Component,'') || '_' ||
        IFNULL(TO_VARCHAR(:I_Periodseq),''));  /* ORIGSQL: V_subPartitionname Varchar2(100) := UPPER('Sh_' || I_Component || '_' || I_Periodseq) ; */

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: When Others Then */
        BEGIN
            --dbms_output.put_line(sqlerrm);

            /* ORIGSQL: COMDEBUGGER('CLEAN UP PARTTION ERROR', sqlerrm) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comDebugger('CLEAN UP PARTTION ERROR', ::SQL_ERROR_MESSAGE 
            );  /* ORIGSQL: sqlerrm */

            /* sapdbmtk: Closing RETURN in exception handler commented out, not supported in HANA */
            --RETURN;
        END;

        /* ORIGSQL: DBMS_OUTPUT.PUT_LINE('CLEAN UP PARTTION' || V_subPartitionname || '---' || V_Cnt); */
        CALL sapdbmtk.sp_dbmtk_buffered_output_writeln('CLEAN UP PARTTION' || IFNULL(:V_subPartitionname,'') ||
            '---' || IFNULL(TO_VARCHAR(:V_Cnt),''));

        SELECT
            COUNT(*) 
        INTO
            V_Cnt
        FROM
            SYS.TABLE_PARTITIONS  /* RESOLVE: Catalog reference(partly converted): Oracle catalog 'USER_TAB_SUBPARTITIONS': verify conversion */
                                  /* ORIGSQL: User_Tab_SUBPartitions (Oracle catalog) */
        WHERE
            LEVEL_2_PARTITION>0 and SCHEMA_NAME = CURRENT_USER
            AND UPPER(TABLE_NAME) = 'SH_QUERY_RESULT'   /* ORIGSQL: Table_Name (column in Oracle catalog 'USER_TAB_SUBPARTITIONS') */
            AND UPPER(subpartition_name) = :V_subPartitionname;

        --Comdebugger('CLEAN UP PARTTION',V_subPartitionname||'---'||V_Cnt);

        IF :V_Cnt = 0
        THEN
            V_str = 'alter table SH_QUERY_RESULT modify partition ' ||
            IFNULL(:v_partitionname,'') || ' add subpartition ' ||
            IFNULL(:V_subPartitionname,'') || ' values (' || IFNULL(TO_VARCHAR(:I_Periodseq),'') || ')';

            --dbms_output.put_line(v_Str);

            -- Comdebugger('CLEAN UP PARTTION',V_Str);

            /* RESOLVE: Dynamically generated SQL: Dynamically generated SQL, as executed by Execute-Immediate, convert manually */
            /* ORIGSQL: execute immediate v_str; */
            EXECUTE IMMEDIATE :V_str;
        ELSE 
            V_str = 'ALTER TABLE sh_query_result truncate subpartition ' ||
            IFNULL(:V_subPartitionname,'');

            --Comdebugger('CLEAN UP PARTTION',V_Str);

            /* RESOLVE: Dynamically generated SQL: Dynamically generated SQL, as executed by Execute-Immediate, convert manually */
            /* ORIGSQL: execute immediate v_str; */
            EXECUTE IMMEDIATE :V_str;
        END IF; 

        RETURN;

        /* ORIGSQL: Exception When Others Then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__ComInitialpartition') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating function 'DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating function ''DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq''...' );
go

/* ORIGSQL: Function Comgeteventtypeseq(I_Eventtypeid In Varchar2) Return Int as v_eventtypeseq int; */
CREATE OR REPLACE FUNCTION DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq
(
    IN I_Eventtypeid VARCHAR(255)   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                    /* ORIGSQL: I_Eventtypeid IN Varchar2 */
)
RETURNS dbmtk_function_result BIGINT   /* ORIGSQL: Return Int */
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
AS
BEGIN
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE v_eventtypeseq BIGINT;  /* ORIGSQL: v_eventtypeseq int; */

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN 
            dbmtk_function_result = 0;
            /* sapdbmtk: Closing RETURN in exception handler commented out, not supported in HANA */
            --RETURN;
        END;



    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_EVENTTYPE' not found */

    SELECT
        datatypeseq
    INTO
        v_eventtypeseq
    FROM
        Cs_Eventtype
    WHERE
        Eventtypeid = :I_Eventtypeid
        AND removedate = :cdt_EndOfTime;

    dbmtk_function_result = :v_eventtypeseq;
    RETURN;

    /* ORIGSQL: exception when others then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('function', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__Comgeteventtypeseq') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating function 'DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating function ''DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq''...' );
go

/* ORIGSQL: Function Comgetcredittypeseq(I_credittypeid In Varchar2) Return Int as v_credittypeseq int; */
CREATE OR REPLACE FUNCTION DBMTK_USER_NAME.PK_STAGE_HOOK__Comgetcredittypeseq
(
    IN I_credittypeid VARCHAR(255)   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                                     /* ORIGSQL: I_credittypeid IN Varchar2 */
)
RETURNS dbmtk_function_result BIGINT   /* ORIGSQL: Return Int */
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
AS
BEGIN
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE v_credittypeseq BIGINT;  /* ORIGSQL: v_credittypeseq int; */

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN 
            dbmtk_function_result = 0;
            /* sapdbmtk: Closing RETURN in exception handler commented out, not supported in HANA */
            --RETURN;
        END;



    /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_CREDITTYPE' not found */

    SELECT
        datatypeseq
    INTO
        v_credittypeseq
    FROM
        Cs_Credittype
    WHERE
        credittypeid = :I_credittypeid
        AND removedate = :cdt_EndOfTime;

    dbmtk_function_result = :v_credittypeseq;
    RETURN;

    /* ORIGSQL: exception when others then */
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('function', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__Comgetcredittypeseq') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_classify' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_classify''...' );
go

/* ORIGSQL: procedure exec_pre_classify(stage in varchar2, period in varchar2, periodSeq in int, calendarSeq in int, processingUnitSeq in int) as begin */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_classify
(
    IN stage VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                             /* ORIGSQL: stage IN varchar2 */
    IN period VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                              /* ORIGSQL: period IN varchar2 */
    IN periodSeq BIGINT,   /* ORIGSQL: periodSeq IN int */
    IN calendarSeq BIGINT,   /* ORIGSQL: calendarSeq IN int */
    IN processingUnitSeq BIGINT     /* ORIGSQL: processingUnitSeq IN int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE gv_isYearEnd BIGINT; /* package/session variable */

    /* initialize session variables, if not yet done */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
    /* retrieve the package/session variables referenced in this procedure */
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ISYEAREND') AS BIGINT) INTO gv_isYearEnd FROM SYS.DUMMY ;
    /* end of package/session variables */

    --comDebugger('pre_classify',periodSeq||', stage:Pre-classify puSeq'||processingUnitSeq);
    /* ORIGSQL: Log('Start Pre classify') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Start Pre classify');

    /* ORIGSQL: sequencegenpkg.updateSeq('salesTransactionSeq') */
    CALL sequencegenpkg.updateSeq('salesTransactionSeq');  /* RESOLVE: Identifier not found: Cannot resolve procedure call 'sequencegenpkg.updateSeq' */

    /* ORIGSQL: Log('Done with sequence gen') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Done with sequence gen');

    IF :gv_isYearEnd = 1
    THEN
        /* ORIGSQL: Log('Start YrEnd PIAOR in pre_Classify') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Start YrEnd PIAOR in pre_Classify');

        --comDebugger('SP_TXNTXA_YREND_PIAOR','StageHook start for period ['||period||']'||'at ['||to_timestamp(sysdate)||']');
        --Commented by Suresh 20180424 to as part of PIAOR removal form SH
        --Sp_Txntxa_Yrend_Piaor(gv_PeriodSeq);
        -- comDebugger('SP_TXNTXA_YREND_PIAOR','StageHook start for period ['||period||']'||'at ['||to_timestamp(sysdate)||']');
    END IF;

    /* ORIGSQL: sequencegenpkg.updateSeq('salesTransactionSeq') */
    CALL sequencegenpkg.updateSeq('salesTransactionSeq'); 

    RETURN;
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__exec_pre_classify') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_allocate' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_allocate''...' );
go

/* ORIGSQL: procedure exec_pre_allocate(stage in varchar2, period in varchar2, periodSeq in int, calendarSeq in int, processingUnitSeq in int) as V_Periodstartdate date; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_allocate
(
    IN stage VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                             /* ORIGSQL: stage IN varchar2 */
    IN period VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                              /* ORIGSQL: period IN varchar2 */
    IN periodSeq BIGINT,   /* ORIGSQL: periodSeq IN int */
    IN calendarSeq BIGINT,   /* ORIGSQL: calendarSeq IN int */
    IN processingUnitSeq BIGINT     /* ORIGSQL: processingUnitSeq IN int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */
    DECLARE gv_calendarSeq BIGINT; /* package/session variable */
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */
    DECLARE V_Periodstartdate TIMESTAMP;  /* ORIGSQL: V_Periodstartdate date; */
    DECLARE V_Periodenddate TIMESTAMP;  /* ORIGSQL: V_Periodenddate date; */

    /* initialize session variables, if not yet done */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
    /* retrieve the package/session variables referenced in this procedure */
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CALENDARSEQ') AS BIGINT) INTO gv_calendarSeq FROM SYS.DUMMY ;
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
    /* end of package/session variables */ 

    SELECT
        Startdate,
        Enddate
    INTO
        V_Periodstartdate,
        V_Periodenddate
    FROM
        Cs_Period
    WHERE
        :periodSeq = :Gv_Periodseq
        AND :calendarSeq = :gv_calendarSeq
        AND removedate = :cdt_EndOfTime;

    /* ORIGSQL: Log('71 Periodseq ' || gv_Periodseq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('71 Periodseq '|| IFNULL(TO_VARCHAR(:Gv_Periodseq),''));

    /*Arjun 0523. Set ga4 to null for setnumber1*/   

    /* ORIGSQL: update cs_Transactionassignment ta SET genericattribute4=null, genericattribute10=null where tenantid='AIAS' and processingunitseq=gv_ProcessingUnitSeq and setnumber in (1,41,51) and Compensationdate (...) */
    UPDATE cs_Transactionassignment ta
        SET
        /* ORIGSQL: genericattribute4 = */
        genericattribute4 = NULL,
        /* ORIGSQL: genericattribute10 = */
        genericattribute10 = NULL 
    FROM
        cs_Transactionassignment ta
    WHERE
        tenantid = 'AIAS'
        AND processingUnitSeq = :Gv_Processingunitseq
        AND setnumber IN (1,41,51) /* --added 41/51 on 6/12 */
        AND Compensationdate >= :V_Periodstartdate
        AND Compensationdate < :V_Periodenddate;

    /* ORIGSQL: Log('71 Update GA4/10 to null '||SQL%ROWCOUNT) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('71 Update GA4/10 to null '||::ROWCOUNT);  

    /* ORIGSQL: commit; */
    COMMIT;

    /* ORIGSQL: Log('SP_UPDATE_TXN 100') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_UPDATE_TXN 100');

    /* ORIGSQL: SP_UPDATE_TXN(gv_PeriodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Sp_Update_Txn(:Gv_Periodseq);

    /* ORIGSQL: Log('SP_UPDATE_TXN 100') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_UPDATE_TXN 100');

    --Log('SP_TXA_PIAOR 101');
    --SP_TXA_PIAOR(gv_PeriodSeq);
    --Log('SP_TXA_PIAOR 101');

    /* ORIGSQL: Log('SP_TXA_NADOR_EXCEPTION 102') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_TXA_NADOR_EXCEPTION 102');

    /* ORIGSQL: SP_TXA_NADOR_EXCEPTION(gv_PeriodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__SP_TXA_NADOR_EXCEPTION(:Gv_Periodseq);

    /* ORIGSQL: Log('SP_TXA_NADOR_EXCEPTION 102') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_TXA_NADOR_EXCEPTION 102');

    --for revamp begin
    --Batch2
    /* ORIGSQL: Log('SP_TXA_OVERRIDING_ASSIGNMENT 201') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_TXA_OVERRIDING_ASSIGNMENT 201');

    /* ORIGSQL: SP_TXA_OVERRIDING_ASSIGNMENT(periodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__SP_TXA_OVERRIDING_ASSIGNMENT(:periodSeq);

    /* ORIGSQL: Log('SP_TXA_OVERRIDING_ASSIGNMENT 201') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_TXA_OVERRIDING_ASSIGNMENT 201');

    --for revamp end
    /* ORIGSQL: commit; */
    COMMIT;

    RETURN;
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__exec_pre_allocate') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__exec_post_allocate' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__exec_post_allocate''...' );
go

/* ORIGSQL: procedure exec_post_allocate(stage in varchar2, period in varchar2, periodSeq in int, calendarSeq in int, processingUnitSeq in int) AS BEGIN */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__exec_post_allocate
(
    IN stage VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                             /* ORIGSQL: stage IN varchar2 */
    IN period VARCHAR(255),   /* RESOLVE: Manual edits required: VARCHAR2 parameter(no length): user-configured length=255; adjust as needed */
                              /* ORIGSQL: period IN varchar2 */
    IN periodSeq BIGINT,   /* ORIGSQL: periodSeq IN int */
    IN calendarSeq BIGINT,   /* ORIGSQL: calendarSeq IN int */
    IN processingUnitSeq BIGINT     /* ORIGSQL: processingUnitSeq IN int */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */

    /* initialize session variables, if not yet done */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
    /* retrieve the package/session variables referenced in this procedure */
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
    /* end of package/session variables */

    --comDebugger('post_allowacte',periodSeq||',PUSeq'||processingUnitSeq);

    --execute nador validation
    /* ORIGSQL: Log('SP_UPDATE_NADOR 103') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_UPDATE_NADOR 103');

    /* ORIGSQL: SP_UPDATE_NADOR(gv_PeriodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_NADOR(:Gv_Periodseq);

    /* ORIGSQL: Log('SP_UPDATE_NADOR 103') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_UPDATE_NADOR 103');

    --execute pbu buyout

    /* ORIGSQL: Log('SP_UPDATE_PBUBUYOUT 104') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_UPDATE_PBUBUYOUT 104');

    /* ORIGSQL: SP_UPDATE_PBUBUYOUT(gv_PeriodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_PBUBUYOUT(:Gv_Periodseq);

    /* ORIGSQL: Log('SP_UPDATE_PBUBUYOUT 104') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_UPDATE_PBUBUYOUT 104');

    --execute do brunei quarterly
    /* ORIGSQL: Log('SP_UPDATE_DO_QUARTERLY 105') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_UPDATE_DO_QUARTERLY 105');

    /* ORIGSQL: SP_UPDATE_DO_QUARTERLY(gv_PeriodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_DO_QUARTERLY(:Gv_Periodseq);

    /* ORIGSQL: Log('SP_UPDATE_DO_QUARTERLY 105') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_UPDATE_DO_QUARTERLY 105');

    --Added for version 3 by Win Tan
    --for Fair BSC
    /* ORIGSQL: Log('[CB] SP_CLAWBACK_CALCULATION 202 start') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] SP_CLAWBACK_CALCULATION 202 start');

    /* ORIGSQL: SP_CLAWBACK_CALCULATION(periodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__SP_CLAWBACK_CALCULATION(:periodSeq);

    /* ORIGSQL: Log('[CB] SP_CLAWBACK_CALCULATION 202 end') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] SP_CLAWBACK_CALCULATION 202 end');

    --for Fair BSC end
    --for Fair BSC FA
    /* ORIGSQL: Log('[CB] SP_CLAWBACK_CALCULATION FA 202 start') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] SP_CLAWBACK_CALCULATION FA 202 start');

    /* ORIGSQL: SP_CLAWBACK_CALCULATION_FA(periodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__SP_CLAWBACK_CALCULATION_FA(:periodSeq);

    /* ORIGSQL: Log('[CB] SP_CLAWBACK_CALCULATION FA 202 end') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[CB] SP_CLAWBACK_CALCULATION FA 202 end');

    --for Fair BSC FA end
    --ensure the seq is updated
    /* ORIGSQL: Log('106') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('106');

    /* ORIGSQL: sequencegenpkg.updateSeq('salesTransactionSeq') */
    CALL sequencegenpkg.updateSeq('salesTransactionSeq');

    /* ORIGSQL: Log('106') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('106');
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__exec_post_allocate') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_classify_dbmtkoverloaded_1' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_classify_dbmtkoverloaded_1''...' );
go

/* ORIGSQL: procedure exec_pre_classify as begin */
/* sapdbmtk: Procedure declaration 'exec_pre_classify' is overloaded, renamed to 'exec_pre_classify_dbmtkoverloaded_1' */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_classify_dbmtkoverloaded_1
()
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */

    /* initialize session variables, if not yet done */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
    /* retrieve the package/session variables referenced in this procedure */
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
    /* end of package/session variables */

    --return;
    /* ORIGSQL: Cominit() */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comInit();

    IF :Gv_Processingunitseq != 38280596832649218
    THEN 
        RETURN;
    END IF;

    --clean up assignment
    /* ORIGSQL: Log('Comcleanassignment 106') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comcleanassignment 106');

    /* ORIGSQL: Comcleanassignment(Gv_Periodseq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Comcleanassignment(:Gv_Periodseq);

    /* ORIGSQL: Log('Comcleanassignment 106') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('Comcleanassignment 106');

    -- commented as PIAOR stagehook is not longer executed
    /*Log('exec_pre_classify 107');
    exec_pre_classify('Pre-classify',
                      gv_periodName,
                      gv_periodSeq,
                      gv_calendarSeq,
                  gv_processingUnitSeq);
    Log('exec_pre_classify 107');*/
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__exec_pre_classify_dbmtkoverloaded_1') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_allocate_dbmtkoverloaded_1' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_allocate_dbmtkoverloaded_1''...' );
go

/* ORIGSQL: procedure exec_pre_allocate as begin */
/* sapdbmtk: Procedure declaration 'exec_pre_allocate' is overloaded, renamed to 'exec_pre_allocate_dbmtkoverloaded_1' */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_allocate_dbmtkoverloaded_1
()
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */
    DECLARE Gv_Periodname VARCHAR(100); /* package/session variable */
    DECLARE gv_calendarSeq BIGINT; /* package/session variable */

    /* initialize session variables, if not yet done */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
    /* retrieve the package/session variables referenced in this procedure */
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
    SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODNAME') INTO Gv_Periodname FROM SYS.DUMMY ;
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CALENDARSEQ') AS BIGINT) INTO gv_calendarSeq FROM SYS.DUMMY ;
    /* end of package/session variables */

    --return;
    /* ORIGSQL: Log('comInit 108') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('comInit 108');

    /* ORIGSQL: comInit() */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comInit();

    --version 21 GST enhancement
    /* ORIGSQL: Log('SP_UPDATE_GST') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_UPDATE_GST');

    /* ORIGSQL: SP_UPDATE_GST(gv_PeriodSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_GST(:Gv_Periodseq);

    /* ORIGSQL: Log('SP_UPDATE_GST') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('SP_UPDATE_GST');

    IF :Gv_Processingunitseq != 38280596832649218
    THEN 
        RETURN;
    END IF;
    /* ORIGSQL: Log('comInit 108') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('comInit 108');

    /* ORIGSQL: Log('exec_pre_allocate 109') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('exec_pre_allocate 109');

    /* ORIGSQL: exec_pre_allocate('Pre-Allocate', gv_periodName, gv_periodSeq, gv_calendarSeq, gv_processingUnitSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__exec_pre_allocate('Pre-Allocate', :Gv_Periodname, :Gv_Periodseq, :gv_calendarSeq, :Gv_Processingunitseq);

    /* ORIGSQL: Log('exec_pre_allocate 109') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('exec_pre_allocate 109');
END;
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__exec_pre_allocate_dbmtkoverloaded_1') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__exec_post_allocate_dbmtkoverloaded_1' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__exec_post_allocate_dbmtkoverloaded_1''...' );
go

/* ORIGSQL: procedure exec_post_allocate as begin */
/* sapdbmtk: Procedure declaration 'exec_post_allocate' is overloaded, renamed to 'exec_post_allocate_dbmtkoverloaded_1' */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__exec_post_allocate_dbmtkoverloaded_1
()
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */
    DECLARE Gv_Periodname VARCHAR(100); /* package/session variable */
    DECLARE Gv_Periodseq BIGINT; /* package/session variable */
    DECLARE gv_calendarSeq BIGINT; /* package/session variable */

    /* initialize session variables, if not yet done */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
    /* retrieve the package/session variables referenced in this procedure */
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
    SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODNAME') INTO Gv_Periodname FROM SYS.DUMMY ;
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PERIODSEQ') AS BIGINT) INTO Gv_Periodseq FROM SYS.DUMMY ;
    SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_CALENDARSEQ') AS BIGINT) INTO gv_calendarSeq FROM SYS.DUMMY ;
    /* end of package/session variables */

    --return;
    /* ORIGSQL: Log('110') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('110');

    /* ORIGSQL: comInit() */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__comInit();

    IF :Gv_Processingunitseq != 38280596832649218
    THEN 
        RETURN;
    END IF;
    /* ORIGSQL: Log('exec_pre_allocate 110') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('exec_pre_allocate 110');

    /* ORIGSQL: Log('exec_post_allocate 111') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('exec_post_allocate 111');

    /* ORIGSQL: exec_post_allocate('Post-PostAllocate', gv_periodName, gv_periodSeq, gv_calendarSeq, gv_processingUnitSeq) */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__exec_post_allocate('Post-PostAllocate', :Gv_Periodname, :Gv_Periodseq, :gv_calendarSeq, :Gv_Processingunitseq);

    /* ORIGSQL: Log('exec_post_allocate 111') */
    CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('exec_post_allocate 111');
END;

-- version 21 GST enhancement
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__exec_post_allocate_dbmtkoverloaded_1') WITH HINT(IGNORE_PLAN_CACHE);
go

--********** Creating procedure 'DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_GST' ********************
go

CALL SQLSCRIPT_PRINT:PRINT_LINE( 'Creating procedure ''DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_GST''...' );
go

/* ORIGSQL: PROCEDURE SP_UPDATE_GST(I_PERIODSEQ IN INT) AS V_PERIODSEQ INT := I_PERIODSEQ; */
CREATE OR REPLACE PROCEDURE DBMTK_USER_NAME.PK_STAGE_HOOK__SP_UPDATE_GST
(
    IN I_PERIODSEQ BIGINT     /* ORIGSQL: I_PERIODSEQ IN INT */
)
LANGUAGE SQLSCRIPT
SQL SECURITY DEFINER
DEFAULT SCHEMA DBMTK_USER_NAME
/*READS SQL DATA*/ -- this procedure cannot be read-only
AS
BEGIN
    DECLARE gv_error VARCHAR(1000); /* package/session variable */
    DECLARE cdt_EndOfTime CONSTANT TIMESTAMP = DBMTK_USER_NAME.f_dbmtk_constant__PK_STAGE_HOOK__cdt_EndOfTime();
    DECLARE Gv_Processingunitseq BIGINT; /* package/session variable */

    /* sapdbmtk: one or more DECLARE statements below were moved upwards, before the first executable statement */

    DECLARE V_PERIODSEQ BIGINT = :I_PERIODSEQ;  /* ORIGSQL: V_PERIODSEQ INT := I_PERIODSEQ; */
    DECLARE V_PERIODSTARTDATE TIMESTAMP;  /* ORIGSQL: V_PERIODSTARTDATE DATE; */
    DECLARE V_PERIODENDDATE TIMESTAMP;  /* ORIGSQL: V_PERIODENDDATE DATE; */
    DECLARE V_CALENDARSEQ BIGINT;  /* ORIGSQL: V_CALENDARSEQ INT; */
    DECLARE V_PERIODTYPESEQ BIGINT;  /* ORIGSQL: V_PERIODTYPESEQ INT; */
    DECLARE V_COMPONENTVALUE VARCHAR(30) = 'GST';  /* ORIGSQL: V_COMPONENTVALUE VARCHAR2(30) := 'GST'; */
    DECLARE V_NORMALRATE BIGINT;  /* ORIGSQL: V_NORMALRATE INT; */
    DECLARE V_DEFAULTRATE BIGINT;  /* ORIGSQL: V_DEFAULTRATE INT; */
    DECLARE V_STRDATEFORMAT VARCHAR(30) = 'YYYY-MM-DD';  /* ORIGSQL: V_STRDATEFORMAT VARCHAR2(30) := 'YYYY-MM-DD'; */
    DECLARE V_GST_RATE DECIMAL(10,2);  /* ORIGSQL: V_GST_RATE NUMBER(10,2); */
    DECLARE V_ET1 DECIMAL(38,10);  /* ORIGSQL: V_ET1 NUMBER; */
    DECLARE V_ET2 DECIMAL(38,10);  /* ORIGSQL: V_ET2 NUMBER; */
    DECLARE V_ET3 DECIMAL(38,10);  /* ORIGSQL: V_ET3 NUMBER; */
    DECLARE V_ET4 DECIMAL(38,10);  /* ORIGSQL: V_ET4 NUMBER; */
    DECLARE V_ET5 DECIMAL(38,10);  /* ORIGSQL: V_ET5 NUMBER; */
    DECLARE V_ET6 DECIMAL(38,10);  /* ORIGSQL: V_ET6 NUMBER; */
    DECLARE V_ET7 DECIMAL(38,10);  /* ORIGSQL: V_ET7 NUMBER; */
    DECLARE V_ET8 DECIMAL(38,10);  /* ORIGSQL: V_ET8 NUMBER; */
    DECLARE V_ET9 DECIMAL(38,10);  /* ORIGSQL: V_ET9 NUMBER; */
    DECLARE V_ET10 DECIMAL(38,10);  /* ORIGSQL: V_ET10 NUMBER; */
    DECLARE V_ET11 DECIMAL(38,10);  /* ORIGSQL: V_ET11 NUMBER; */
    DECLARE V_ET12 DECIMAL(38,10);  /* ORIGSQL: V_ET12 NUMBER; */
    DECLARE V_ET13 DECIMAL(38,10);  /* ORIGSQL: V_ET13 NUMBER; */
    DECLARE V_UNITTYPENAME VARCHAR(30) = 'percent';  /* ORIGSQL: V_UNITTYPENAME VARCHAR2(30) := 'percent'; */
    DECLARE V_UNITTYPESEQ DECIMAL(38,10);  /* ORIGSQL: V_UNITTYPESEQ NUMBER; */
    DECLARE V_PU VARCHAR(30);  /* ORIGSQL: V_PU VARCHAR2(30); */

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
        /* ORIGSQL: when others then */
        BEGIN
            gv_error = 'Error [SP_UPDATE_GST]: ' ||
            ::SQL_ERROR_MESSAGE || ' - ' ||  /* ORIGSQL: sqlerrm */

            /* RESOLVE: Standard Package call(not converted): 'dbms_utility.format_error_backtrace' not supported, manual conversion required */
            dbms_utility.format_error_backtrace;
            /* Saving modified package/session variable 'gv_error': */ 
            SET SESSION 'DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR' = :gv_error;

            /* ORIGSQL: Log(gv_error) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log(:gv_error);

            /* ORIGSQL: rollback ; */
            ROLLBACK;

            /* sapdbmtk: Closing RETURN in exception handler commented out, not supported in HANA */
            --RETURN;
        END;

        /* initialize session variables, if not yet done */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__dbmtk_init_session_global();
        /* retrieve the package/session variables referenced in this procedure */
        SELECT SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_ERROR') INTO gv_error FROM SYS.DUMMY ;
        SELECT CAST(SESSION_CONTEXT('DBMTK_GLOBVAR_DBMTK_USER_NAME_PK_STAGE_HOOK_GV_PROCESSINGUNITSEQ') AS BIGINT) INTO Gv_Processingunitseq FROM SYS.DUMMY ;
        /* end of package/session variables */

        /* ORIGSQL: comInitialPartition('GST', v_componentValue, i_periodSeq) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__ComInitialpartition('GST', :V_COMPONENTVALUE, :I_PERIODSEQ);

        --Gv_Processingunitseq := 38280596832649218;

        /* ORIGSQL: Log('[GST] Periodseq is: ' || i_periodSeq) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[GST] Periodseq is: '|| IFNULL(TO_VARCHAR(:I_PERIODSEQ),'')); 

        SELECT
            startDate,
            endDate,
            periodTypeSeq,
            calendarSeq
        INTO
            V_PERIODSTARTDATE,
            V_PERIODENDDATE,
            V_PERIODTYPESEQ,
            V_CALENDARSEQ
        FROM
            cs_period
        WHERE
            tenantid = 'AIAS'
            AND periodseq = :V_PERIODSEQ
            AND removeDate = :cdt_EndOfTime;

        /* ORIGSQL: Log('[GST] v_periodStartDate is: ' || v_periodStartDate || ', v_periodEndDate is: ' || v_periodEndDate || ', v_periodTypeSeq is: ' || v_periodTypeSeq || ', v_calendarSeq is: ' || v_calendarSeq) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[GST] v_periodStartDate is: '|| IFNULL(TO_VARCHAR(:V_PERIODSTARTDATE),'') || ' , v_periodEndDate is: '|| IFNULL(TO_VARCHAR(:V_PERIODENDDATE),'') || ' , v_periodTypeSeq is: '|| IFNULL(TO_VARCHAR(:V_PERIODTYPESEQ),'') || ' , v_calendarSeq is: '|| IFNULL(TO_VARCHAR(:V_CALENDARSEQ),''));

        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_PROCESSINGUNIT' not found */

        SELECT
            NAME
        INTO
            V_PU
        FROM
            CS_PROCESSINGUNIT
        WHERE
            PROCESSINGUNITSEQ = :Gv_Processingunitseq;

        /* ORIGSQL: Log('[GST] V_PU is: ' || V_PU) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[GST] V_PU is: '|| IFNULL(:V_PU,''));

        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_UNITTYPE' not found */

        SELECT
            UNITTYPESEQ
        INTO
            V_UNITTYPESEQ
        FROM
            CS_UNITTYPE
        WHERE
            NAME = :V_UNITTYPENAME
            AND REMOVEDATE = :cdt_EndOfTime;

        V_ET1 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('APF');  /* ORIGSQL: Comgeteventtypeseq('APF') */

        V_ET2 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('APF Payable');  /* ORIGSQL: Comgeteventtypeseq('APF Payable') */

        V_ET3 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('API');  /* ORIGSQL: Comgeteventtypeseq('API') */

        V_ET4 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('FYC');  /* ORIGSQL: Comgeteventtypeseq('FYC') */

        V_ET5 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('SSCP');  /* ORIGSQL: Comgeteventtypeseq('SSCP') */

        V_ET6 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('RYC');  /* ORIGSQL: Comgeteventtypeseq('RYC') */

        V_ET7 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('FYC_TP');  /* ORIGSQL: Comgeteventtypeseq('FYC_TP') */

        V_ET8 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('RYC_TP');  /* ORIGSQL: Comgeteventtypeseq('RYC_TP') */

        V_ET9 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('TFR');  /* ORIGSQL: Comgeteventtypeseq('TFR') */

        V_ET10 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('TFS');  /* ORIGSQL: Comgeteventtypeseq('TFS') */

        V_ET11 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('FYC_INTRODUCER');  /* ORIGSQL: Comgeteventtypeseq('FYC_INTRODUCER') */

        -- version 22 For MAS Section86 project
        V_ET12 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('FYC_TPGI');  /* ORIGSQL: Comgeteventtypeseq('FYC_TPGI') */

        V_ET13 = DBMTK_USER_NAME.PK_STAGE_HOOK__Comgeteventtypeseq('RYC_TPGI');  /* ORIGSQL: Comgeteventtypeseq('RYC_TPGI') */

        /* ORIGSQL: execute immediate 'truncate table SH_GST_TMP_DATAPARTICIPANT'; */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.SH_GST_TMP_DATAPARTICIPANT' not found */

        /* ORIGSQL: truncate table SH_GST_TMP_DATAPARTICIPANT ; */
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SH_GST_TMP_DATAPARTICIPANT';

        /* ORIGSQL: Log('[GST] truncate table SH_GST_TMP_DATAPARTICIPANT') */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[GST] truncate table SH_GST_TMP_DATAPARTICIPANT'); 

        /* ORIGSQL: insert into SH_GST_TMP_DATAPARTICIPANT select SUBSTR(pa.USERID, 4), pa.payeeseq from cs_participant pa where pa.tenantid = 'AIAS' and pa.removeDate = cdt_EndOfTime and v_periodEndDate >= pa.effectiveS(...) */
        INSERT INTO SH_GST_TMP_DATAPARTICIPANT
            SELECT   /* ORIGSQL: select SUBSTR(pa.USERID, 4), pa.payeeseq from cs_participant pa where pa.tenantid = 'AIAS' and pa.removeDate = cdt_EndOfTime and v_periodEndDate >= pa.effectiveStartDate and v_periodEndDate < pa.effec(...) */
                SUBSTRING(pa.USERID,4),
                pa.payeeseq
            FROM
                cs_participant pa
            WHERE
                pa.tenantid = 'AIAS'
                AND pa.removeDate = :cdt_EndOfTime
                AND :V_PERIODENDDATE >= pa.effectiveStartDate
                AND :V_PERIODENDDATE < pa.effectiveEndDate
                AND GENERICBOOLEAN3 = 1;

        /* ORIGSQL: Log('[GST] insert into SH_GST_TMP_DATAPARTICIPANT ' ||SQL%ROWCOUNT) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[GST] insert into SH_GST_TMP_DATAPARTICIPANT '||::ROWCOUNT);  

        /* ORIGSQL: commit; */
        COMMIT;

        /* ORIGSQL: delete Sh_Query_Result where Component = v_componentValue and periodseq = v_periodseq and genericSequence2 = Gv_Processingunitseq; */
        DELETE
        FROM
            Sh_Query_Result
        WHERE
            Component = :V_COMPONENTVALUE
            AND periodseq = :V_PERIODSEQ
            AND genericSequence2 = :Gv_Processingunitseq;

        /* ORIGSQL: commit; */
        COMMIT;

        IF :V_PU = 'AGY_PU' 
        THEN 
            /* ORIGSQL: Insert Into Sh_Query_Result (Component, periodseq, value, genericSequence1, genericSequence2, GENERICATTRIBUTE1, GENERICATTRIBUTE2, GENERICATTRIBUTE3, GENERICDATE1, GENERICDATE2, GENERICBOOLEAN1) SELE(...) */
            INSERT INTO Sh_Query_Result
                (
                    Component, periodseq, value,
                    genericSequence1 /* -- SalesTransactionSeq */,
                    genericSequence2 /* -- processingunitseq */,
                    GENERICATTRIBUTE1 /* -- Commission agent code */,
                    GENERICATTRIBUTE2 /* -- Policy no */,
                    GENERICATTRIBUTE3 /* -- Component code */,
                    GENERICDATE1 /* -- Coverge issue date */,
                    GENERICDATE2 /* -- compensation date */,
                    GENERICBOOLEAN1 /* -- API Eligible Indicator */
                )
                SELECT   /* ORIGSQL: SELECT distinct v_componentValue, v_periodseq, txn.value, txn.salestransactionseq, txn.processingunitseq, txn.genericattribute12, txn.ponumber, txn.PRODUCTID, txn.genericdate2, txn.COMPENSATIONDATE, t(...) */
                    DISTINCT
                    :V_COMPONENTVALUE,
                    :V_PERIODSEQ,
                    txn.value,
                    txn.salestransactionseq,
                    txn.processingunitseq,
                    txn.genericattribute12,
                    txn.ponumber,
                    txn.PRODUCTID,
                    txn.genericdate2,
                    txn.COMPENSATIONDATE,
                    txn.GENERICBOOLEAN4
                FROM
                    Cs_Salestransaction Txn
                INNER JOIN
                    SH_GST_TMP_DATAPARTICIPANT tpa
                    ON txn.genericattribute12 = tpa.AGENTCODE
                WHERE
                    txn.tenantid = 'AIAS'
                    AND txn.processingunitseq = :Gv_Processingunitseq
                    AND txn.compensationDate >= :V_PERIODSTARTDATE
                    AND txn.compensationDate < :V_PERIODENDDATE
                    AND txn.eventtypeseq IN (:V_ET1,:V_ET2,:V_ET3,:V_ET4,:V_ET5,:V_ET6,:V_ET7,:V_ET8,:V_ET9,:V_ET10,:V_ET11,:V_ET12,:V_ET13);

            -- version 22 For MAS Section86 project
            /* ORIGSQL: Log('[GST] insert into Sh_Query_Result ' ||SQL%ROWCOUNT) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[GST] insert into Sh_Query_Result '||::ROWCOUNT);  

            /* ORIGSQL: commit; */
            COMMIT;

            /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
            /* ORIGSQL: merge into Sh_Query_Result qr using (SELECT cg.salestransactionseq, cg.GENERICNUMBER3 FROM cs_gaSalestransaction cg INNER JOIN Sh_Query_Result t1 ON t1.genericSequence1 = cg.salestransactionseq WHERE (...) */
            MERGE INTO Sh_Query_Result AS qr
                /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.CS_GASALESTRANSACTION' not found */
                USING
                (
                    SELECT   /* ORIGSQL: (select cg.salestransactionseq, cg.GENERICNUMBER3 from cs_gaSalestransaction cg INNER JOIN Sh_Query_Result t1 ON t1.genericSequence1 = cg.salestransactionseq WHERE cg.tenantid = 'AIAS' AND cg.processi(...) */
                        cg.salestransactionseq,
                        cg.GENERICNUMBER3
                    FROM
                        cs_gaSalestransaction cg
                    INNER JOIN
                        Sh_Query_Result t1
                        ON t1.genericSequence1 = cg.salestransactionseq
                    WHERE
                        cg.tenantid = 'AIAS'
                        AND cg.processingunitseq = :Gv_Processingunitseq
                        AND cg.compensationDate >= :V_PERIODSTARTDATE
                        AND cg.compensationDate < :V_PERIODENDDATE
                        AND cg.PAGENUMBER = 0
                        AND t1.Component = :V_COMPONENTVALUE
                        AND t1.GENERICBOOLEAN1 = 1
                        AND t1.periodseq = :V_PERIODSEQ
                ) AS r
                ON (qr.genericSequence1 = r.salestransactionseq
                    AND qr.GENERICBOOLEAN1 = 1
                    AND qr.Component = :V_COMPONENTVALUE
                AND qr.periodseq = :V_PERIODSEQ)
            WHEN MATCHED THEN
                UPDATE SET qr.value = r.GENERICNUMBER3;

            /* ORIGSQL: Log('[GST] update GENERICNUMBER3 for Sh_Query_Result ' ||SQL%ROWCOUNT) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[GST] update GENERICNUMBER3 for Sh_Query_Result '||::ROWCOUNT);  
        ELSEIF :V_PU = 'PD_PU'   /* ORIGSQL: ELSIF V_PU = 'PD_PU' THEN */
        THEN 
            /* ORIGSQL: Insert Into Sh_Query_Result (Component, periodseq, value, genericSequence1, genericSequence2, GENERICATTRIBUTE1, GENERICATTRIBUTE2, GENERICATTRIBUTE3, GENERICDATE1, GENERICDATE2, GENERICBOOLEAN1) SELE(...) */
            INSERT INTO Sh_Query_Result
                (
                    Component, periodseq, value,
                    genericSequence1 /* -- SalesTransactionSeq */,
                    genericSequence2 /* -- processingunitseq */,
                    GENERICATTRIBUTE1 /* -- Commission agent code */,
                    GENERICATTRIBUTE2 /* -- Policy no */,
                    GENERICATTRIBUTE3 /* -- Component code */,
                    GENERICDATE1 /* -- Coverge issue date */,
                    GENERICDATE2 /* -- compensation date */,
                    GENERICBOOLEAN1 /* -- API Eligible Indicator */
                )
                SELECT   /* ORIGSQL: SELECT distinct v_componentValue, v_periodseq, txn.value, txn.salestransactionseq, txn.processingunitseq, txn.genericattribute13, txn.ponumber, txn.PRODUCTID, txn.genericdate2, txn.COMPENSATIONDATE, t(...) */
                    DISTINCT
                    :V_COMPONENTVALUE,
                    :V_PERIODSEQ,
                    txn.value,
                    txn.salestransactionseq,
                    txn.processingunitseq,
                    txn.genericattribute13,
                    txn.ponumber,
                    txn.PRODUCTID,
                    txn.genericdate2,
                    txn.COMPENSATIONDATE,
                    txn.GENERICBOOLEAN4
                FROM
                    Cs_Salestransaction Txn
                INNER JOIN
                    SH_GST_TMP_DATAPARTICIPANT tpa
                    ON txn.genericattribute13 = tpa.AGENTCODE
                WHERE
                    txn.tenantid = 'AIAS'
                    AND txn.processingunitseq = :Gv_Processingunitseq
                    AND txn.compensationDate >= :V_PERIODSTARTDATE
                    AND txn.compensationDate < :V_PERIODENDDATE
                    AND txn.eventtypeseq IN (:V_ET1,:V_ET2,:V_ET3,:V_ET4,:V_ET5,:V_ET6,:V_ET7,:V_ET8,:V_ET9,:V_ET10,:V_ET11);

            /* ORIGSQL: Log('[GST] insert into Sh_Query_Result ' ||SQL%ROWCOUNT) */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[GST] insert into Sh_Query_Result '||::ROWCOUNT);  

            /* ORIGSQL: commit; */
            COMMIT;
        ELSE 
            /* ORIGSQL: Log('[GST] PU is not correct') */
            CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[GST] PU is not correct'); 

            RETURN;
        END IF;

        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.VW_LT_GST_RATE' not found */

        SELECT
            value
        INTO
            V_GST_RATE
        FROM
            vw_lt_gst_rate
        WHERE
            :V_PERIODSTARTDATE >= effectivestartdate
            AND :V_PERIODSTARTDATE < effectiveenddate;

        /* ORIGSQL: execute immediate 'truncate table GST_RATE_TMP'; */
        /* RESOLVE: Identifier not found: Table/view 'DBMTK_USER_NAME.GST_RATE_TMP' not found */

        /* ORIGSQL: truncate table GST_RATE_TMP ; */
        EXECUTE IMMEDIATE 'TRUNCATE TABLE GST_RATE_TMP';

        /* ORIGSQL: INSERT INTO GST_RATE_TMP (component, periodSeq, GENERICATTRIBUTE1, GENERICATTRIBUTE2, GENERICATTRIBUTE3, GENERICDATE1, gst_rate) SELECT distinct component, periodSeq, GENERICATTRIBUTE1, GENERICATTRIBU(...) */
        INSERT INTO GST_RATE_TMP
            (
                component,
                periodSeq,
                GENERICATTRIBUTE1,
                GENERICATTRIBUTE2,
                GENERICATTRIBUTE3,
                GENERICDATE1,
                gst_rate
            )
            SELECT   /* ORIGSQL: SELECT distinct component, periodSeq, GENERICATTRIBUTE1, GENERICATTRIBUTE2, GENERICATTRIBUTE3, MAX(GENERICDATE1), CASE WHEN SUM(value) >= 0 THEN V_GST_RATE ELSE (SELECT value FROM vw_lt_gst_rate where(...) */
                DISTINCT
                component,
                periodSeq,
                GENERICATTRIBUTE1  /* -- Commission agent code */, GENERICATTRIBUTE2  /* -- Policy no */, GENERICATTRIBUTE3  /* -- Component code */, MAX(GENERICDATE1) /* -- Coverge issue date */,
                CASE 
                    WHEN SUM(value) >= 0
                    THEN :V_GST_RATE
                    ELSE (
                        SELECT   /* ORIGSQL: (select value from vw_lt_gst_rate where GENERICDATE1 >= effectivestartdate and GENERICDATE1 < effectiveenddate) */
                            value
                        FROM
                            vw_lt_gst_rate
                        WHERE
                            GENERICDATE1 >=
                            effectivestartdate
                            AND GENERICDATE1 <
                            effectiveenddate
                    )
                END
                AS gst_rate
            FROM
                sh_query_result
            WHERE
                component = :V_COMPONENTVALUE
                AND periodSeq = :V_PERIODSEQ
                AND genericSequence2 = :Gv_Processingunitseq
            GROUP BY
                component,
                periodSeq,
                GENERICATTRIBUTE1,
                GENERICATTRIBUTE2,
                GENERICATTRIBUTE3,
                GENERICDATE1;

        /* ORIGSQL: Log('[GST] insert into GST_RATE_TMP ' ||SQL%ROWCOUNT) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[GST] insert into GST_RATE_TMP '||::ROWCOUNT);  

        /* ORIGSQL: commit; */
        COMMIT;

        /* RESOLVE: MERGE statement: Additional manual conversion of MERGE INTO may be required */
        /* ORIGSQL: merge into Sh_Query_Result qr using (SELECT component, periodSeq, GENERICATTRIBUTE1, GENERICATTRIBUTE2, GENERICATTRIBUTE3, GENERICDATE1, gst_rate FROM GST_RATE_TMP) AS r on (qr.component = r.component(...) */
        MERGE INTO Sh_Query_Result AS qr 
            USING
            (
                SELECT   /* ORIGSQL: (select component, periodSeq, GENERICATTRIBUTE1, GENERICATTRIBUTE2, GENERICATTRIBUTE3, GENERICDATE1, gst_rate from GST_RATE_TMP) */
                    component,
                    periodSeq,
                    GENERICATTRIBUTE1,
                    GENERICATTRIBUTE2,
                    GENERICATTRIBUTE3,
                    GENERICDATE1,
                    gst_rate
                FROM
                    GST_RATE_TMP
            ) AS r
            ON (qr.component = r.component
                AND qr.periodSeq = r.periodSeq
                AND qr.GENERICATTRIBUTE1 = r.GENERICATTRIBUTE1
                AND qr.GENERICATTRIBUTE2 = r.GENERICATTRIBUTE2
                AND qr.GENERICATTRIBUTE3 = r.GENERICATTRIBUTE3
            AND qr.GENERICDATE1 = r.GENERICDATE1)
        WHEN MATCHED THEN
            UPDATE SET qr.GENERICNUMBER1 = r.gst_rate;

        /* ORIGSQL: Log('[GST] update GST rate for Sh_Query_Result ' ||SQL%ROWCOUNT) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[GST] update GST rate for Sh_Query_Result '||::ROWCOUNT);  

        /* ORIGSQL: commit; */
        COMMIT;  

        /* ORIGSQL: update cs_gaSalestransaction ga SET ga.GENERICNUMBER9 = (SELECT r.GENERICNUMBER1 FROM sh_query_result r where r.Component = v_componentValue and r.periodSeq = v_periodseq and ga.salestransactionseq = (...) */
        UPDATE cs_gaSalestransaction ga 
            SET
            /* ORIGSQL: ga.GENERICNUMBER9 = */
            GENERICNUMBER9 = (
                /* RESOLVE: Review semantics in source vs. target DBMS: LIMIT/OFFSET without ORDER BY: consistent results not guaranteed */
                SELECT   /* ORIGSQL: (select r.GENERICNUMBER1 from sh_query_result r where r.Component = v_componentValue and r.periodSeq = v_periodseq and ga.salestransactionseq = r.genericsequence1 and ga.PROCESSINGUNITSEQ = Gv_Process(...) */
                    r.GENERICNUMBER1
                FROM
                    sh_query_result r
                WHERE
                    r.Component = :V_COMPONENTVALUE
                    AND r.periodSeq = :V_PERIODSEQ
                    AND ga.salestransactionseq = r.genericsequence1
                    AND ga.PROCESSINGUNITSEQ = :Gv_Processingunitseq
                LIMIT 1  /* ORIGSQL: rownum = 1 */
            ),
            /* ORIGSQL: ga.UNITTYPEFORGENERICNUMBER9 = */
            UNITTYPEFORGENERICNUMBER9 = :V_UNITTYPESEQ
        WHERE
            ga.PAGENUMBER = 0
            AND ga.tenantid = 'AIAS'
            AND 
            EXISTS
            (
                SELECT   /* ORIGSQL: (select 1 from sh_query_result sh where sh.genericSequence1 = ga.salestransactionSeq and sh.Component = v_componentValue and sh.periodSeq = v_periodseq and ga.PAGENUMBER = 0 and ga.tenantid = 'AIAS' a(...) */
                    1
                FROM
                    sh_query_result sh
                WHERE
                    sh.genericSequence1 = ga.salestransactionSeq
                    AND sh.Component = :V_COMPONENTVALUE
                    AND sh.periodSeq = :V_PERIODSEQ
                    AND ga.PAGENUMBER = 0
                    AND ga.tenantid = 'AIAS'
                    AND ga.PROCESSINGUNITSEQ = :Gv_Processingunitseq
                    AND ga.COMPENSATIONDATE = sh.GENERICDATE2
            );

        /* ORIGSQL: Log('[GST] update GST rate for cs_gaSalestransaction ' ||SQL%ROWCOUNT) */
        CALL DBMTK_USER_NAME.PK_STAGE_HOOK__Log('[GST] update GST rate for cs_gaSalestransaction '||::ROWCOUNT);  

        /* ORIGSQL: commit; */
        COMMIT;

        /* ORIGSQL: exception when others then */
    END;

    /* ORIGSQL: END PK_STAGE_HOOK; */
go
CALL sapdbmtk.sp_dbmtk_object_install_custom('procedure', 'DBMTK_USER_NAME', 'PK_STAGE_HOOK__SP_UPDATE_GST') WITH HINT(IGNORE_PLAN_CACHE);
go

/*
 * end of 'DBMTK_USER_NAME.PK_STAGE_HOOK.PACKAGE-BODY.sqlscript'
 */
go

